
Compiling and running t6p1p3d3

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.1.3-3, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test examines the significance limit of identifiers. } 
     4      -32 {  Although the Standard places no limit on the length of 
     5      -32    identifiers, nor does it specify any equivalences between 
     6      -32    identifiers except in the case of letters, it is not uncommon 
     7      -32    for processors to deviate from the Standard by mapping some 
     8      -32    identifiers into others.  The most common practice is simply to 
     9      -32    truncate the tail of long identifiers after some limit chosen 
    10      -32    for convenience (8,10,12,16).  This test is relevant to 
    11      -32    processors that so deviate, and attempts to deduce what 
    12      -32    significance limit is used.  Processors which accept all 
    13      -32    characters of identifiers as significant will simply report a 
    14      -32    limit greater than 20.  Processors which use some more 
    15      -32    sophisticated method of deviating, such as hashing a tail or 
    16      -32    preserving the true length, will not be detected and will 
    17      -32    probably evoke the same message. } 
    18      -32 {V3.0: Comment revised to be more understandable, and in light 
    19      -32    of changes introduced by DP7185.  Output modified. } 
    20      -32  
    21      -32 program t6p1p3d3(output); 
    22      -32 const 
    23      -32    i3i = 3; 
    24      -32    i4ii = 1; 
    25      -32    i5iii = 1; 
    26      -32    i6iiii = 1; 
    27      -32    i7iiiii = 1; 
    28      -32    i8iiiiii = 1; 
    29      -32    i9iiiiiii = 1; 
    30      -32    i10iiiiiii = 1; 
    31      -32    i11iiiiiiii = 1; 
    32      -32    i12iiiiiiiii = 1; 
    33      -32    i13iiiiiiiiii = 1; 
    34      -32    i14iiiiiiiiiii = 1; 
    35      -32    i15iiiiiiiiiiii = 1; 
    36      -32    i16iiiiiiiiiiiii = 1; 
    37      -32    i17iiiiiiiiiiiiii = 1; 
    38      -32    i18iiiiiiiiiiiiiii = 1; 
    39      -32    i19iiiiiiiiiiiiiiii = 1; 
    40      -32    i20iiiiiiiiiiiiiiiii = 1; 
    41      -32  
    42      -32 procedure signif; 
    43      -32 const 
    44      -32    i3j = 0; 
    45      -32    i4ij = 0; 
    46      -32    i5iij = 0; 
    47      -32    i6iiij = 0; 
    48      -32    i7iiiij = 0; 
    49      -32    i8iiiiij = 0; 
    50      -32    i9iiiiiij = 0; 
    51      -32    i10iiiiiij = 0; 
    52      -32    i11iiiiiiij = 0; 
    53      -32    i12iiiiiiiij = 0; 
    54      -32    i13iiiiiiiiij = 0; 
    55      -32    i14iiiiiiiiiij = 0; 
    56      -32    i15iiiiiiiiiiij = 0; 
    57      -32    i16iiiiiiiiiiiij = 0; 
    58      -32    i17iiiiiiiiiiiiij = 0; 
    59      -32    i18iiiiiiiiiiiiiij = 0; 
    60      -32    i19iiiiiiiiiiiiiiij = 0; 
    61      -32    i20iiiiiiiiiiiiiiiij = 0; 
    62      -32  
    63      -32 var 
    64      -32    x : integer; 
    65      -36 begin 
    66        3    x:=i3i + i4ii + i5iii + i6iiii + i7iiiii + i8iiiiii + 
    67       16       i9iiiiiii + i10iiiiiii + i11iiiiiiii + i12iiiiiiiii + 
    68       24       i13iiiiiiiiii + i14iiiiiiiiiii + i15iiiiiiiiiiii + 
    69       30       i16iiiiiiiiiiiii + i17iiiiiiiiiiiiii + i18iiiiiiiiiiiiiii + 
    70       36       i19iiiiiiiiiiiiiiii + i20iiiiiiiiiiiiiiiii; 
    71       41  
    72       41    if x = 20 then 
    73       45       writeln(' NUMBER OF SIGNIFICANT CHARACTERS >= 20') 
    74       51    else 
    75       54       writeln(' NUMBER OF SIGNIFICANT CHARACTERS = ', x) 
    76       63 end; 
i20iiiiiii unreferenced
i19iiiiiii unreferenced
i18iiiiiii unreferenced
i17iiiiiii unreferenced
i16iiiiiii unreferenced
i15iiiiiii unreferenced
i14iiiiiii unreferenced
i13iiiiiii unreferenced
i12iiiiiii unreferenced
i11iiiiiii unreferenced
i10iiiiiij unreferenced
i9iiiiiij  unreferenced
i8iiiiij   unreferenced
i7iiiij    unreferenced
i6iiij     unreferenced
i5iij      unreferenced
i4ij       unreferenced
i3j        unreferenced

    77       66  
    78       66 begin 
    79       66    writeln(' OUTPUT FROM TEST...6.1.3-3'); 
    80       76    signif; 
    81       78    writeln(' QUALITY...6.1.3-3') 
    82       84 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 OUTPUT FROM TEST...6.1.3-3
 NUMBER OF SIGNIFICANT CHARACTERS >= 20
 QUALITY...6.1.3-3

program complete

Compiling and running t6p1p5d10

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.1.5-10, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that there are no small limits on the 
     4      -32    number of real literals allowed by a processor. } 
     5      -32 {V3.0: New test derived from Algol 60 test 30. } 
     6      -32  
     7      -32 program t6p1p5d10(output); 
     8      -32  
     9      -32 var 
    10      -32    x : real; 
    11      -32  
    12      -32 begin 
    13        3 x := 0; 
    14        8 x := (x + 1.1) / 3.3; 
    15       14 x := (x + 2.2) / 6.6; 
    16       20 x := (x + 3.3) / 9.9; 
    17       26 x := (x + 4.4) / 13.2; 
    18       32 x := (x + 5.5) / 16.5; 
    19       38 x := (x + 6.6) / 19.8; 
    20       44 x := (x + 7.7) / 23.1; 
    21       50 x := (x + 8.8) / 26.4; 
    22       56 x := (x + 9.9) / 29.7; 
    23       62 x := (x + 11.0) / 33.0; 
    24       68 x := (x + 12.1) / 36.3; 
    25       74 x := (x + 13.2) / 39.6; 
    26       80 x := (x + 14.3) / 42.9; 
    27       86 x := (x + 15.4) / 46.2; 
    28       92 x := (x + 16.5) / 49.5; 
    29       98 x := (x + 17.6) / 52.8; 
    30      104 x := (x + 18.7) / 56.1; 
    31      110 x := (x + 19.8) / 59.4; 
    32      116 x := (x + 20.9) / 62.7; 
    33      122 x := (x + 22.0) / 66.0; 
    34      128 x := (x + 23.1) / 69.3; 
    35      134 x := (x + 24.2) / 72.6; 
    36      140 x := (x + 25.3) / 75.9; 
    37      146 x := (x + 26.4) / 79.2; 
    38      152 x := (x + 27.5) / 82.5; 
    39      158 x := (x + 28.6) / 85.8; 
    40      164 x := (x + 29.7) / 89.1; 
    41      170 x := (x + 30.8) / 92.4; 
    42      176 x := (x + 31.9) / 95.7; 
    43      182 x := (x + 33.0) / 99.0; 
    44      188 x := (x + 34.1) / 102.3; 
    45      194 x := (x + 35.2) / 105.6; 
    46      200 x := (x + 36.3) / 108.9; 
    47      206 x := (x + 37.4) / 112.2; 
    48      212 x := (x + 38.5) / 115.5; 
    49      218 x := (x + 39.6) / 118.8; 
    50      224 x := (x + 40.7) / 122.1; 
    51      230 x := (x + 41.8) / 125.4; 
    52      236 x := (x + 42.9) / 128.7; 
    53      242 x := (x + 44.0) / 132.0; 
    54      248 x := (x + 45.1) / 135.3; 
    55      254 x := (x + 46.2) / 138.6; 
    56      260 x := (x + 47.3) / 141.9; 
    57      266 x := (x + 48.4) / 145.2; 
    58      272 x := (x + 49.5) / 148.5; 
    59      278 x := (x + 50.6) / 151.8; 
    60      284 x := (x + 51.7) / 155.1; 
    61      290 x := (x + 52.8) / 158.4; 
    62      296 x := (x + 53.9) / 161.7; 
    63      302 x := (x + 55.0) / 165.0; 
    64      308 x := (x + 56.1) / 168.3; 
    65      314 x := (x + 57.2) / 171.6; 
    66      320 x := (x + 58.3) / 174.9; 
    67      326 x := (x + 59.4) / 178.2; 
    68      332 x := (x + 60.5) / 181.5; 
    69      338 x := (x + 61.6) / 184.8; 
    70      344 x := (x + 62.7) / 188.1; 
    71      350 x := (x + 63.8) / 191.4; 
    72      356 x := (x + 64.9) / 194.7; 
    73      362 x := (x + 66.0) / 198.0; 
    74      368 x := (x + 67.1) / 201.3; 
    75      374 x := (x + 68.2) / 204.6; 
    76      380 x := (x + 69.3) / 207.9; 
    77      386 x := (x + 70.4) / 211.2; 
    78      392 x := (x + 71.5) / 214.5; 
    79      398 x := (x + 72.6) / 217.8; 
    80      404 x := (x + 73.7) / 221.1; 
    81      410 x := (x + 74.8) / 224.4; 
    82      416 x := (x + 75.9) / 227.7; 
    83      422 x := (x + 77.0) / 231.0; 
    84      428 x := (x + 78.1) / 234.3; 
    85      434 x := (x + 79.2) / 237.6; 
    86      440 x := (x + 80.3) / 240.9; 
    87      446 x := (x + 81.4) / 244.2; 
    88      452 x := (x + 82.5) / 247.5; 
    89      458 x := (x + 83.6) / 250.8; 
    90      464 x := (x + 84.7) / 254.1; 
    91      470 x := (x + 85.8) / 257.4; 
    92      476 x := (x + 86.9) / 260.7; 
    93      482 x := (x + 88.0) / 264.0; 
    94      488 x := (x + 89.1) / 267.3; 
    95      494 x := (x + 90.2) / 270.6; 
    96      500 x := (x + 91.3) / 273.9; 
    97      506 x := (x + 92.4) / 277.2; 
    98      512 x := (x + 93.5) / 280.5; 
    99      518 x := (x + 94.6) / 283.8; 
   100      524 x := (x + 95.7) / 287.1; 
   101      530 x := (x + 96.8) / 290.4; 
   102      536 x := (x + 97.9) / 293.7; 
   103      542 x := (x + 99.0) / 297.0; 
   104      548 x := (x + 100.1) / 300.3; 
   105      554 x := (x + 101.2) / 303.6; 
   106      560 x := (x + 102.3) / 306.9; 
   107      566 x := (x + 103.4) / 310.2; 
   108      572 x := (x + 104.5) / 313.5; 
   109      578 x := (x + 105.6) / 316.8; 
   110      584 x := (x + 106.7) / 320.1; 
   111      590 x := (x + 107.8) / 323.4; 
   112      596 x := (x + 108.9) / 326.7; 
   113      602 x := (x + 110.0) / 330.0; 
   114      608 if (x >= 0.333) and (x <= 0.335) then 
   115      616    writeln(' QUALITY...6.1.5-10') 
   116      622 else 
   117      625    writeln(' FAIL...6.1.5-10') 
   118      631 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.1.5-10

program complete

Compiling and running t6p1p5d11

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.1.5-11, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that negative powers of the radix, stored 
     4      -32    as literal values, are converted exactly. } 
     5      -32 {  An implementation which does not correctly round literal 
     6      -32    values could fail this test for large values of the exponent. 
     7      -32    Such a failure indicates a poor quality implementation rather 
     8      -32    than one which is demonstrably incorrect according to the 
     9      -32    Standard. } 
    10      -32 {V3.1: Machar changed and forcestore call added. } 
    11      -32  
    12      -32 program t6p1p5d11(output); 
    13      -32  
    14      -32 const 
    15      -32    maxe = 30; 
    16      -32 var 
    17      -32    ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, 
    18      -32    maxexp: integer;  { integer parameters to machar } 
    19      -32    eps, epsneg, xmin, xmax: real; { real parameters to machar } 
    20      -32    i, errorcount: integer; 
    21      -32    arr: array [ 1 .. maxe ] of real; 
    22      -32  
    23      -32  
    24      -32 function forcestore(x: real): real; 
    25      -40    { see 'st' in 6.6.6.2-11 for details} 
    26      -40    var 
    27      -40       y: array[1..3] of real; 
    28      -64    begin 
    29        3    y[1] := x; y[2] := 0.0; y[3] := y[1] + y[2]; 
    30       38    y[1] := y[3]; forcestore := y[1] + y[2] 
    31       61    end; 
    32       65  
    33       65 procedure machar (var ibeta, it, irnd, ngrd, machep, negep, iexp, 
    34       65       minexp, maxexp: integer; var eps, epsneg, xmin, xmax: real); 
    35       65    { see 6.6.6.2-11 for details } 
    36       65    var 
    37      -84       i, iz, j, k, mx: integer; 
    38     -104       a, b, beta, betain, betam1, one, y, z, zero: real; 
    39     -176       underflo: boolean; 
    40     -177    function st(x: real): real; 
    41      -40       begin 
    42       65       st := forcestore(x); 
    43       71       end; 
    44       72  
    45       72    begin 
    46       72    one := 1.0; zero := 0.0; a := one + one; 
    47       82    while st(st(st(a + one) - a) - one) = zero do 
    48       98       a := a + a; 
    49      103    b := one + one; 
    50      107    while st(st(a + b) - a) = zero do 
    51      119       b := b + b; 
    52      124    ibeta := trunc (st(a + b) - a); beta := ibeta; 
    53      138    it := 0; b := one; 
    54      143    repeat 
    55      143       begin it := it + 1; b := b * beta end 
    56      153    until st(st(st(b + one) - b) - one) <> zero; 
    57      169    irnd := 0; 
    58      172    betam1 := beta - one; 
    59      176    if st(st((a + beta) + betam1) - (a + beta)) <> zero then 
    60      192       irnd := 1; 
    61      195    negep := it + 3; betain := one / beta; a := one; 
    62      207    for i := 1 to negep do 
    63      218       a := a * betain; 
    64      232    b := a; 
    65      234    while st(st(one - a) - one) = zero do 
    66      246       begin a := a * beta; negep := negep - 1 end; 
    67      257    negep := - negep; epsneg := a; 
    68      265    if (ibeta <> 2) and (irnd <> 0) then 
    69      275       begin 
    70      275       a := a * st(one + a) / (one + one); 
    71      287       if st(st(one - a) - one) <> zero then 
    72      299          epsneg := a; 
    73      302       end; 
    74      302    machep := - it - 3; a := b; 
    75      311    while st(st(one + a) - one) = zero do 
    76      323       begin a := a * beta; machep := machep + 1 end; 
    77      334    eps := a; 
    78      337    if (ibeta <> 2) and (irnd <> 0) then 
    79      347       begin 
    80      347       a := a * st(one + a) / (one + one); 
    81      359       if st(st(one + a) - one) <> zero then 
    82      371          eps := a; 
    83      374       end; 
    84      374    ngrd := 0; 
    85      377    if (irnd = 0) and (st(st(one + eps) * one - one) <> zero) then 
    86      397       ngrd := 1; 
    87      400    i := 0; k := 1; z := betain; underflo := false; 
    88      409    repeat 
    89      409       begin 
    90      409       y := z; z := y * y; a := z * one; 
    91      419       if (st(a + a) = zero) or (abs (z) >= y) then 
    92      432          underflo := true 
    93      432       else 
    94      436          begin i := i + 1; k := k + k end; 
    95      444       end 
    96      444    until underflo; 
    97      446    if ibeta <> 10 then 
    98      451       begin iexp := i + 1; mx := k + k end 
    99      460    else 
   100      461       begin iexp := 2; iz := ibeta; 
   101      467       while k >= iz do 
   102      471          begin iz := iz * ibeta; iexp := iexp + 1 end; 
   103      483       mx := iz + iz - 1; 
   104      489       end; 
   105      489    underflo := false; 
   106      492    repeat 
   107      492       begin 
   108      492       xmin := y; y := y * betain; a := y * one; 
   109      503       if (st(a + a) = zero) or (abs (y) >= xmin) 
   110      515             or (st(y * st(one + eps)) <= y) then 
   111      530          underflo := true 
   112      530       else 
   113      534          k := k + 1; 
   114      538       end 
   115      538    until underflo; 
   116      540    minexp := - k; 
   117      544    if (mx <= k + k - 3) and (ibeta <> 10) then 
   118      557       begin mx := mx + mx; iexp := iexp + 1 end; 
   119      567    maxexp := mx + minexp; i := maxexp + minexp; 
   120      579    if ibeta = 2 then 
   121      584       if (iexp = 8) and (it = 24) and (i = 4) then 
   122      598          maxexp := maxexp - 2 
   123      601       else if (iexp = 11) and (it = 53) and (i = 4) then 
   124      619          maxexp := maxexp - 2 
   125      622       else if i = 0 then 
   126      630          maxexp := maxexp - 1; 
   127      636    if i > 20 then 
   128      640       maxexp := maxexp - 1; 
   129      646    if a <> y then 
   130      650       maxexp := maxexp - 2; 
   131      656    xmax := one - epsneg; 
   132      662    if st(xmax * one) <> xmax then 
   133      672       xmax := one - st(beta * epsneg); 
   134      682    xmax := xmax / (beta * beta * beta * xmin); 
   135      695    i := maxexp + minexp + 3; 
   136      703    for j := 1 to i do 
   137      713       if ibeta = 2 then 
   138      718          xmax := xmax + xmax 
   139      721       else 
   140      726          xmax := xmax * beta; 
   141      742    end; 
   142      743  
   143      743  
   144      743  
   145      743  
   146      743 procedure test(radix: integer); 
   147      743    var 
   148      -36       x, y: real; 
   149      -52       i: integer; 
   150      -56    procedure equal(u, v: real); 
   151      -48       begin 
   152      743       if u <> v then 
   153      749          begin 
   154      749          errorcount := errorcount + 1; 
   155      753          if errorcount < 10 then 
   156      757             writeln(' ',u,v) 
   157      768          end 
   158      770       end; {equal} 
   159      771    begin 
   160      771    x := 1.0/radix; 
   161      778    { Test above division is exact } 
   162      778    equal(1.0, x * radix); 
   163      785    y := x; 
   164      787    for i := 1 to maxe do 
   165      797       begin 
   166      797       equal(y, arr[i] ); 
   167      806       y := forcestore( y * x ) 
   168      810       end 
   169      812    end; {test} 
   170      823  
   171      823 begin 
   172      823    machar( ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, 
   173      834       maxexp, eps, epsneg, xmin, xmax); 
   174      840    errorcount := 0; 
   175      842    if (ibeta = 2) or (ibeta = 4) or (ibeta = 8) or (ibeta = 16) then 
   176      858       begin 
   177      858       arr[1] := 0.5; 
   178      865       arr[2] := 0.25; 
   179      872       arr[3] := 0.125; 
   180      879       arr[4] := 0.0625; 
   181      886       arr[5] := 0.03125; 
   182      893       arr[6] := 0.015625; 
   183      900       arr[7] := 0.0078125; 
   184      907       arr[8] := 0.00390625; 
   185      914       arr[9] := 0.001953125; 
   186      921       arr[10] := 0.0009765625; 
   187      928       arr[11] := 0.00048828125; 
   188      935       arr[12] := 0.000244140625; 
   189      942       arr[13] := 0.0001220703125; 
   190      949       arr[14] := 0.00006103515625; 
   191      956       arr[15] := 0.000030517578125; 
   192      963       arr[16] := 0.0000152587890625; 
   193      970       arr[17] := 0.00000762939453125; 
   194      977       arr[18] := 0.000003814697265625; 
   195      984       arr[19] := 0.0000019073486328125; 
   196      991       arr[20] := 0.00000095367431640625; 
   197      998       arr[21] := 0.000000476837158203125; 
   198     1005       arr[22] := 0.0000002384185791015625; 
   199     1012       arr[23] := 0.00000011920928955078125; 
   200     1019       arr[24] := 0.000000059604644775390625; 
   201     1026       arr[25] := 0.0000000298023223876953125; 
   202     1033       arr[26] := 0.00000001490116119384765625; 
   203     1040       arr[27] := 0.000000007450580596923828125; 
   204     1047       arr[28] := 0.0000000037252902984619140625; 
   205     1054       arr[29] := 0.00000000186264514923095703125; 
   206     1061       arr[30] := 0.000000000931322574615478515625; 
   207     1068       test(2) 
   208     1070       end 
   209     1071    else if ibeta = 10 then 
   210     1076       begin 
   211     1076       arr[1] := 0.1; 
   212     1083       arr[2] := 0.01; 
   213     1090       arr[3] := 0.001; 
   214     1097       arr[4] := 0.0001; 
   215     1104       arr[5] := 0.00001; 
   216     1111       arr[6] := 0.000001; 
   217     1118       arr[7] := 0.0000001; 
   218     1125       arr[8] := 0.00000001; 
   219     1132       arr[9] := 0.000000001; 
   220     1139       arr[10] := 0.0000000001; 
   221     1146       arr[11] := 0.00000000001; 
   222     1153       arr[12] := 0.000000000001; 
   223     1160       arr[13] := 0.0000000000001; 
   224     1167       arr[14] := 0.00000000000001; 
   225     1174       arr[15] := 0.000000000000001; 
   226     1181       arr[16] := 0.0000000000000001; 
   227     1188       arr[17] := 0.00000000000000001; 
   228     1195       arr[18] := 0.000000000000000001; 
   229     1202       arr[19] := 0.0000000000000000001; 
   230     1209       arr[20] := 0.00000000000000000001; 
   231     1216       arr[21] := 0.000000000000000000001; 
   232     1223       arr[22] := 0.0000000000000000000001; 
   233     1230       arr[23] := 0.00000000000000000000001; 
   234     1237       arr[24] := 0.000000000000000000000001; 
   235     1244       arr[25] := 0.0000000000000000000000001; 
   236     1251       arr[26] := 0.00000000000000000000000001; 
   237     1258       arr[27] := 0.000000000000000000000000001; 
   238     1265       arr[28] := 0.0000000000000000000000000001; 
   239     1272       arr[29] := 0.00000000000000000000000000001; 
   240     1279       arr[30] := 0.000000000000000000000000000001; 
   241     1286       test(ibeta) 
   242     1288       end; 
   243     1289  
   244     1289    if errorcount > 0 then 
   245     1293       writeln(' FAIL...6.1.5-11, REAL VALUES (',errorcount,' TIMES)') 
   246     1306    else 
   247     1309       writeln(' QUALITY...6.1.5-11') 
   248     1315 end. 
i          unreferenced


Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.1.5-11

program complete

Compiling and running t6p1p5d12

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.1.5-12, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that negative powers of the radix, stored 
     4      -32    as literal values, are converted exactly. } 
     5      -32 {  An implementation which does not 
     6      -32    correctly round literal values could fail 
     7      -32    this test for large values of the exponent. Such a failure 
     8      -32    indicates a poor quality implementation rather than one 
     9      -32    which is demonstrably incorrect according to the Standard. } 
    10      -32 {V3.1: Machar changed and forcestore call added. } 
    11      -32  
    12      -32 program t6p1p5d12(output); 
    13      -32  
    14      -32 const 
    15      -32    maxe = 30; 
    16      -32 var 
    17      -32    ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, 
    18      -32    maxexp: integer;  { integer parameters to machar } 
    19      -32    eps, epsneg, xmin, xmax: real; { real parameters to machar } 
    20      -32    i, errorcount: integer; 
    21      -32    arr: array [ 1 .. maxe ] of real; 
    22      -32  
    23      -32  
    24      -32 function forcestore(x: real): real; 
    25      -40    { see 'st' in 6.6.6.2-11 for details} 
    26      -40    var 
    27      -40       y: array[1..3] of real; 
    28      -64    begin 
    29        3    y[1] := x; y[2] := 0.0; y[3] := y[1] + y[2]; 
    30       38    y[1] := y[3]; forcestore := y[1] + y[2] 
    31       61    end; 
    32       65  
    33       65 procedure machar (var ibeta, it, irnd, ngrd, machep, negep, iexp, 
    34       65       minexp, maxexp: integer; var eps, epsneg, xmin, xmax: real); 
    35       65    { see 6.6.6.2-11 for details } 
    36       65    var 
    37      -84       i, iz, j, k, mx: integer; 
    38     -104       a, b, beta, betain, betam1, one, y, z, zero: real; 
    39     -176       underflo: boolean; 
    40     -177    function st(x: real): real; 
    41      -40       begin 
    42       65       st := forcestore(x); 
    43       71       end; 
    44       72  
    45       72    begin 
    46       72    one := 1.0; zero := 0.0; a := one + one; 
    47       82    while st(st(st(a + one) - a) - one) = zero do 
    48       98       a := a + a; 
    49      103    b := one + one; 
    50      107    while st(st(a + b) - a) = zero do 
    51      119       b := b + b; 
    52      124    ibeta := trunc (st(a + b) - a); beta := ibeta; 
    53      138    it := 0; b := one; 
    54      143    repeat 
    55      143       begin it := it + 1; b := b * beta end 
    56      153    until st(st(st(b + one) - b) - one) <> zero; 
    57      169    irnd := 0; 
    58      172    betam1 := beta - one; 
    59      176    if st(st((a + beta) + betam1) - (a + beta)) <> zero then 
    60      192       irnd := 1; 
    61      195    negep := it + 3; betain := one / beta; a := one; 
    62      207    for i := 1 to negep do 
    63      218       a := a * betain; 
    64      232    b := a; 
    65      234    while st(st(one - a) - one) = zero do 
    66      246       begin a := a * beta; negep := negep - 1 end; 
    67      257    negep := - negep; epsneg := a; 
    68      265    if (ibeta <> 2) and (irnd <> 0) then 
    69      275       begin 
    70      275       a := a * st(one + a) / (one + one); 
    71      287       if st(st(one - a) - one) <> zero then 
    72      299          epsneg := a; 
    73      302       end; 
    74      302    machep := - it - 3; a := b; 
    75      311    while st(st(one + a) - one) = zero do 
    76      323       begin a := a * beta; machep := machep + 1 end; 
    77      334    eps := a; 
    78      337    if (ibeta <> 2) and (irnd <> 0) then 
    79      347       begin 
    80      347       a := a * st(one + a) / (one + one); 
    81      359       if st(st(one + a) - one) <> zero then 
    82      371          eps := a; 
    83      374       end; 
    84      374    ngrd := 0; 
    85      377    if (irnd = 0) and (st(st(one + eps) * one - one) <> zero) then 
    86      397       ngrd := 1; 
    87      400    i := 0; k := 1; z := betain; underflo := false; 
    88      409    repeat 
    89      409       begin 
    90      409       y := z; z := y * y; a := z * one; 
    91      419       if (st(a + a) = zero) or (abs (z) >= y) then 
    92      432          underflo := true 
    93      432       else 
    94      436          begin i := i + 1; k := k + k end; 
    95      444       end 
    96      444    until underflo; 
    97      446    if ibeta <> 10 then 
    98      451       begin iexp := i + 1; mx := k + k end 
    99      460    else 
   100      461       begin iexp := 2; iz := ibeta; 
   101      467       while k >= iz do 
   102      471          begin iz := iz * ibeta; iexp := iexp + 1 end; 
   103      483       mx := iz + iz - 1; 
   104      489       end; 
   105      489    underflo := false; 
   106      492    repeat 
   107      492       begin 
   108      492       xmin := y; y := y * betain; a := y * one; 
   109      503       if (st(a + a) = zero) or (abs (y) >= xmin) 
   110      515             or (st(y * st(one + eps)) <= y) then 
   111      530          underflo := true 
   112      530       else 
   113      534          k := k + 1; 
   114      538       end 
   115      538    until underflo; 
   116      540    minexp := - k; 
   117      544    if (mx <= k + k - 3) and (ibeta <> 10) then 
   118      557       begin mx := mx + mx; iexp := iexp + 1 end; 
   119      567    maxexp := mx + minexp; i := maxexp + minexp; 
   120      579    if ibeta = 2 then 
   121      584       if (iexp = 8) and (it = 24) and (i = 4) then 
   122      598          maxexp := maxexp - 2 
   123      601       else if (iexp = 11) and (it = 53) and (i = 4) then 
   124      619          maxexp := maxexp - 2 
   125      622       else if i = 0 then 
   126      630          maxexp := maxexp - 1; 
   127      636    if i > 20 then 
   128      640       maxexp := maxexp - 1; 
   129      646    if a <> y then 
   130      650       maxexp := maxexp - 2; 
   131      656    xmax := one - epsneg; 
   132      662    if st(xmax * one) <> xmax then 
   133      672       xmax := one - st(beta * epsneg); 
   134      682    xmax := xmax / (beta * beta * beta * xmin); 
   135      695    i := maxexp + minexp + 3; 
   136      703    for j := 1 to i do 
   137      713       if ibeta = 2 then 
   138      718          xmax := xmax + xmax 
   139      721       else 
   140      726          xmax := xmax * beta; 
   141      742    end; 
   142      743  
   143      743  
   144      743  
   145      743  
   146      743  
   147      743 procedure test(radix: integer); 
   148      743    var 
   149      -36       x, y: real; 
   150      -52       i: integer; 
   151      -56    procedure equal(u, v: real); 
   152      -48       begin 
   153      743       if u <> v then 
   154      749          begin 
   155      749          errorcount := errorcount + 1; 
   156      753          if errorcount < 10 then 
   157      757             writeln(' ',u,v) 
   158      768          end 
   159      770       end; {equal} 
   160      771    begin 
   161      771    x := 1.0/radix; 
   162      778    { Test above division is exact } 
   163      778    equal(1.0, x * radix); 
   164      785    y := x; 
   165      787    for i := 1 to maxe do 
   166      797       begin 
   167      797       equal(y, arr[i] ); 
   168      806       y := forcestore( y * x) 
   169      810       end 
   170      812    end; {test} 
   171      823  
   172      823 begin 
   173      823    machar( ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, 
   174      834       maxexp, eps, epsneg, xmin, xmax); 
   175      840    errorcount := 0; 
   176      842    if (ibeta = 2) or (ibeta = 4) or (ibeta = 8) or (ibeta = 16) then 
   177      858       begin 
   178      858       arr[1] := 0.5; 
   179      865       arr[2] := 0.25; 
   180      872       arr[3] := 0.125; 
   181      879       arr[4] := 0.625E-1; 
   182      886       arr[5] := 0.3125E-1; 
   183      893       arr[6] := 0.15625E-1; 
   184      900       arr[7] := 0.78125E-2; 
   185      907       arr[8] := 0.390625E-2; 
   186      914       arr[9] := 0.1953125E-2; 
   187      921       arr[10] := 0.9765625E-3; 
   188      928       arr[11] := 0.48828125E-3; 
   189      935       arr[12] := 0.244140625E-3; 
   190      942       arr[13] := 0.1220703125E-3; 
   191      949       arr[14] := 0.6103515625E-4; 
   192      956       arr[15] := 0.30517578125E-4; 
   193      963       arr[16] := 0.152587890625E-4; 
   194      970       arr[17] := 0.762939453125E-5; 
   195      977       arr[18] := 0.3814697265625E-5; 
   196      984       arr[19] := 0.19073486328125E-5; 
   197      991       arr[20] := 0.95367431640625E-6; 
   198      998       arr[21] := 0.476837158203125E-6; 
   199     1005       arr[22] := 0.2384185791015625E-6; 
   200     1012       arr[23] := 0.11920928955078125E-6; 
   201     1019       arr[24] := 0.59604644775390625E-7; 
   202     1026       arr[25] := 0.298023223876953125E-7; 
   203     1033       arr[26] := 0.1490116119384765625E-7; 
   204     1040       arr[27] := 0.7450580596923828125E-8; 
   205     1047       arr[28] := 0.37252902984619140625E-8; 
   206     1054       arr[29] := 0.186264514923095703125E-8; 
   207     1061       arr[30] := 0.931322574615478515625E-9; 
   208     1068       test(2) 
   209     1070       end 
   210     1071    else if ibeta = 10 then 
   211     1076       begin 
   212     1076       arr[1] := 0.1; 
   213     1083       arr[2] := 0.1E-1; 
   214     1090       arr[3] := 0.1E-2; 
   215     1097       arr[4] := 0.1E-3; 
   216     1104       arr[5] := 0.1E-4; 
   217     1111       arr[6] := 0.1E-5; 
   218     1118       arr[7] := 0.1E-6; 
   219     1125       arr[8] := 0.1E-7; 
   220     1132       arr[9] := 0.1E-8; 
   221     1139       arr[10] := 0.1E-9; 
   222     1146       arr[11] := 0.1E-10; 
   223     1153       arr[12] := 0.1E-11; 
   224     1160       arr[13] := 0.1E-12; 
   225     1167       arr[14] := 0.1E-13; 
   226     1174       arr[15] := 0.1E-14; 
   227     1181       arr[16] := 0.1E-15; 
   228     1188       arr[17] := 0.1E-16; 
   229     1195       arr[18] := 0.1E-17; 
   230     1202       arr[19] := 0.1E-18; 
   231     1209       arr[20] := 0.1E-19; 
   232     1216       arr[21] := 0.1E-20; 
   233     1223       arr[22] := 0.1E-21; 
   234     1230       arr[23] := 0.1E-22; 
   235     1237       arr[24] := 0.1E-23; 
   236     1244       arr[25] := 0.1E-24; 
   237     1251       arr[26] := 0.1E-25; 
   238     1258       arr[27] := 0.1E-26; 
   239     1265       arr[28] := 0.1E-27; 
   240     1272       arr[29] := 0.1E-28; 
   241     1279       arr[30] := 0.1E-29; 
   242     1286       test(ibeta) 
   243     1288       end; 
   244     1289  
   245     1289    if errorcount > 0 then 
   246     1293       writeln(' FAIL...6.1.5-12, REAL VALUES (',errorcount,' TIMES)') 
   247     1306    else 
   248     1309       writeln(' QUALITY...6.1.5-12') 
   249     1315 end. 
i          unreferenced


Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.1.5-12

program complete

Compiling and running t6p1p5d8

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.1.5-8, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that lines of up to 72 characters are 
     4      -32    permitted. } 
     5      -32 {V3.0: New test. The test that was here in previous versions 
     6      -32    has now been moved to 6.1.1-2 to correspond with DP7185. } 
     7      -32  
     8      -32 program t6p1p5d8(output); 
     9      -32 const 
    10      -32    i                                =                                 1; 
    11      -32 begin 
    12        3 if i = 1 then 
    13        9    writeln(' QUALITY...6.1.5-8') 
    14       15 else 
    15       18    writeln(' FAIL...6.1.5-8') 
    16       24 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.1.5-8

program complete

Compiling and running t6p1p5d9

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.1.5-9, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test contains very large integer and real constants. } 
     4      -32 {  This program is clearly 'correct', but the values exceed those 
     5      -32    of most likely implementations.  Really excellent 
     6      -32    implementations may pass, but the test is intended to explore 
     7      -32    the treatment the processor gives to such large numbers 
     8      -32    in its diagnostics. } 
     9      -32 {V3.0: New test. } 
    10      -32  
    11      -32 program t6p1p5d9(output); 
    12      -32 const i = 10000000000000000000000000; 
    12   ****                                      ^203
    13      -32       x = 1.0E99999; 
    13   ****                     ^194
    14      -32 begin 
    15        3    writeln(' THE VALUE OF I IS ', i); 
    16       16    writeln(' THE VALUE OF X IS ', x); 
    17       27    if (i <> 10000000000000000000000000) or (x <> 1.0E99999) then 
    17   ****                                        ^203                ^194
    18       35       writeln(' FAIL...6.1.5-9, VALUES WRONG') 
    19       41    else 
    20       44       writeln(' QUALITY...6.1.5-9, VERY LARGE VALUES') 
    21       50 end. 

Errors in program: 4

Error numbers in listing:
-------------------------
194  Exponent too large
203  Integer constant exceeds range

P5 Pascal interpreter vs. 1.4.x

Assembling/loading program

*** Source program contains errors: 4

program complete

Compiling and running t6p1p7d14

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.1.7-14, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that processors allow a reasonably large 
     4      -32    (20) number of constant strings in a program. } 
     5      -32 {V3.0: New test. } 
     6      -32  
     7      -32 program t6p1p7d14(output); 
     8      -32 const 
     9      -32    s1 = 'STRING 01: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    10      -32    s2 = 'STRING 02: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    11      -32    s3 = 'STRING 03: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    12      -32    s4 = 'STRING 04: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    13      -32    s5 = 'STRING 05: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    14      -32    s6 = 'STRING 06: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    15      -32    s7 = 'STRING 07: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    16      -32    s8 = 'STRING 08: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    17      -32    s9 = 'STRING 09: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    18      -32    s10= 'STRING 10: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    19      -32    s11= 'STRING 11: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    20      -32    s12= 'STRING 12: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    21      -32    s13= 'STRING 13: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    22      -32    s14= 'STRING 14: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    23      -32    s15= 'STRING 15: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    24      -32    s16= 'STRING 16: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    25      -32    s17= 'STRING 17: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    26      -32    s18= 'STRING 18: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    27      -32    s19= 'STRING 19: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    28      -32    s20= 'STRING 20: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; 
    29      -32 begin 
    30        3 if (s1 = s2) or (s3 = s4) or (s5 = s6) 
    31       15    or (s7 = s8) or (s9 = s10) 
    32       23    or (s11 = s12) or (s13 = s14) or (s15 = s16) 
    33       35    or (s17 = s18) or (s19 = s20) then 
    34       45    writeln(' FAIL...6.1.7-14') 
    35       51 else 
    36       54    writeln(' QUALITY...6.1.7-14') 
    37       60 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.1.7-14

program complete

Compiling and running t6p2p1d11

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.2.1-11, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that 128 procedures are permitted in a 
     4      -32    procedure-declaration-part and function-declaration-part. } 
     5      -32 {V3.1: Renumbered from 6.2.1-15. } 
     6      -32  
     7      -32 program t6p2p1d11(output); 
     8      -32 var 
     9      -32    sum: integer; 
    10      -32 procedure p1; 
    11      -32    begin sum := 1 end; 
    12        8 procedure p2; 
    13        8    begin p1; sum := sum + 1 end; 
    14       17 procedure p3; 
    15       17    begin p2; sum := sum + 1 end; 
    16       26 procedure p4; 
    17       26    begin p3; sum := sum + 1 end; 
    18       35 procedure p5; 
    19       35    begin p4; sum := sum + 1 end; 
    20       44 procedure p6; 
    21       44    begin p5; sum := sum + 1 end; 
    22       53 procedure p7; 
    23       53    begin p6; sum := sum + 1 end; 
    24       62 procedure p8; 
    25       62    begin p7; sum := sum + 1 end; 
    26       71 procedure p9; 
    27       71    begin p8; sum := sum + 1 end; 
    28       80 procedure p10; 
    29       80    begin p9; sum := sum + 1 end; 
    30       89 procedure p11; 
    31       89    begin p10; sum := sum + 1 end; 
    32       98 procedure p12; 
    33       98    begin p11; sum := sum + 1 end; 
    34      107 procedure p13; 
    35      107    begin p12; sum := sum + 1 end; 
    36      116 procedure p14; 
    37      116    begin p13; sum := sum + 1 end; 
    38      125 procedure p15; 
    39      125    begin p14; sum := sum + 1 end; 
    40      134 procedure p16; 
    41      134    begin p15; sum := sum + 1 end; 
    42      143 procedure p17; 
    43      143    begin p16; sum := sum + 1 end; 
    44      152 procedure p18; 
    45      152    begin p17; sum := sum + 1 end; 
    46      161 procedure p19; 
    47      161    begin p18; sum := sum + 1 end; 
    48      170 procedure p20; 
    49      170    begin p19; sum := sum + 1 end; 
    50      179 procedure p21; 
    51      179    begin p20; sum := sum + 1 end; 
    52      188 procedure p22; 
    53      188    begin p21; sum := sum + 1 end; 
    54      197 procedure p23; 
    55      197    begin p22; sum := sum + 1 end; 
    56      206 procedure p24; 
    57      206    begin p23; sum := sum + 1 end; 
    58      215 procedure p25; 
    59      215    begin p24; sum := sum + 1 end; 
    60      224 procedure p26; 
    61      224    begin p25; sum := sum + 1 end; 
    62      233 procedure p27; 
    63      233    begin p26; sum := sum + 1 end; 
    64      242 procedure p28; 
    65      242    begin p27; sum := sum + 1 end; 
    66      251 procedure p29; 
    67      251    begin p28; sum := sum + 1 end; 
    68      260 procedure p30; 
    69      260    begin p29; sum := sum + 1 end; 
    70      269 procedure p31; 
    71      269    begin p30; sum := sum + 1 end; 
    72      278 procedure p32; 
    73      278    begin p31; sum := sum + 1 end; 
    74      287 procedure p33; 
    75      287    begin p32; sum := sum + 1 end; 
    76      296 procedure p34; 
    77      296    begin p33; sum := sum + 1 end; 
    78      305 procedure p35; 
    79      305    begin p34; sum := sum + 1 end; 
    80      314 procedure p36; 
    81      314    begin p35; sum := sum + 1 end; 
    82      323 procedure p37; 
    83      323    begin p36; sum := sum + 1 end; 
    84      332 procedure p38; 
    85      332    begin p37; sum := sum + 1 end; 
    86      341 procedure p39; 
    87      341    begin p38; sum := sum + 1 end; 
    88      350 procedure p40; 
    89      350    begin p39; sum := sum + 1 end; 
    90      359 procedure p41; 
    91      359    begin p40; sum := sum + 1 end; 
    92      368 procedure p42; 
    93      368    begin p41; sum := sum + 1 end; 
    94      377 procedure p43; 
    95      377    begin p42; sum := sum + 1 end; 
    96      386 procedure p44; 
    97      386    begin p43; sum := sum + 1 end; 
    98      395 procedure p45; 
    99      395    begin p44; sum := sum + 1 end; 
   100      404 procedure p46; 
   101      404    begin p45; sum := sum + 1 end; 
   102      413 procedure p47; 
   103      413    begin p46; sum := sum + 1 end; 
   104      422 procedure p48; 
   105      422    begin p47; sum := sum + 1 end; 
   106      431 procedure p49; 
   107      431    begin p48; sum := sum + 1 end; 
   108      440 procedure p50; 
   109      440    begin p49; sum := sum + 1 end; 
   110      449 procedure p51; 
   111      449    begin p50; sum := sum + 1 end; 
   112      458 procedure p52; 
   113      458    begin p51; sum := sum + 1 end; 
   114      467 procedure p53; 
   115      467    begin p52; sum := sum + 1 end; 
   116      476 procedure p54; 
   117      476    begin p53; sum := sum + 1 end; 
   118      485 procedure p55; 
   119      485    begin p54; sum := sum + 1 end; 
   120      494 procedure p56; 
   121      494    begin p55; sum := sum + 1 end; 
   122      503 procedure p57; 
   123      503    begin p56; sum := sum + 1 end; 
   124      512 procedure p58; 
   125      512    begin p57; sum := sum + 1 end; 
   126      521 procedure p59; 
   127      521    begin p58; sum := sum + 1 end; 
   128      530 procedure p60; 
   129      530    begin p59; sum := sum + 1 end; 
   130      539 procedure p61; 
   131      539    begin p60; sum := sum + 1 end; 
   132      548 procedure p62; 
   133      548    begin p61; sum := sum + 1 end; 
   134      557 procedure p63; 
   135      557    begin p62; sum := sum + 1 end; 
   136      566 procedure p64; 
   137      566    begin p63; sum := sum + 1 end; 
   138      575 procedure p65; 
   139      575    begin p64; sum := sum + 1 end; 
   140      584 procedure p66; 
   141      584    begin p65; sum := sum + 1 end; 
   142      593 procedure p67; 
   143      593    begin p66; sum := sum + 1 end; 
   144      602 procedure p68; 
   145      602    begin p67; sum := sum + 1 end; 
   146      611 procedure p69; 
   147      611    begin p68; sum := sum + 1 end; 
   148      620 procedure p70; 
   149      620    begin p69; sum := sum + 1 end; 
   150      629 procedure p71; 
   151      629    begin p70; sum := sum + 1 end; 
   152      638 procedure p72; 
   153      638    begin p71; sum := sum + 1 end; 
   154      647 procedure p73; 
   155      647    begin p72; sum := sum + 1 end; 
   156      656 procedure p74; 
   157      656    begin p73; sum := sum + 1 end; 
   158      665 procedure p75; 
   159      665    begin p74; sum := sum + 1 end; 
   160      674 procedure p76; 
   161      674    begin p75; sum := sum + 1 end; 
   162      683 procedure p77; 
   163      683    begin p76; sum := sum + 1 end; 
   164      692 procedure p78; 
   165      692    begin p77; sum := sum + 1 end; 
   166      701 procedure p79; 
   167      701    begin p78; sum := sum + 1 end; 
   168      710 procedure p80; 
   169      710    begin p79; sum := sum + 1 end; 
   170      719 procedure p81; 
   171      719    begin p80; sum := sum + 1 end; 
   172      728 procedure p82; 
   173      728    begin p81; sum := sum + 1 end; 
   174      737 procedure p83; 
   175      737    begin p82; sum := sum + 1 end; 
   176      746 procedure p84; 
   177      746    begin p83; sum := sum + 1 end; 
   178      755 procedure p85; 
   179      755    begin p84; sum := sum + 1 end; 
   180      764 procedure p86; 
   181      764    begin p85; sum := sum + 1 end; 
   182      773 procedure p87; 
   183      773    begin p86; sum := sum + 1 end; 
   184      782 procedure p88; 
   185      782    begin p87; sum := sum + 1 end; 
   186      791 procedure p89; 
   187      791    begin p88; sum := sum + 1 end; 
   188      800 procedure p90; 
   189      800    begin p89; sum := sum + 1 end; 
   190      809 procedure p91; 
   191      809    begin p90; sum := sum + 1 end; 
   192      818 procedure p92; 
   193      818    begin p91; sum := sum + 1 end; 
   194      827 procedure p93; 
   195      827    begin p92; sum := sum + 1 end; 
   196      836 procedure p94; 
   197      836    begin p93; sum := sum + 1 end; 
   198      845 procedure p95; 
   199      845    begin p94; sum := sum + 1 end; 
   200      854 procedure p96; 
   201      854    begin p95; sum := sum + 1 end; 
   202      863 procedure p97; 
   203      863    begin p96; sum := sum + 1 end; 
   204      872 procedure p98; 
   205      872    begin p97; sum := sum + 1 end; 
   206      881 procedure p99; 
   207      881    begin p98; sum := sum + 1 end; 
   208      890 procedure p100; 
   209      890    begin p99; sum := sum + 1 end; 
   210      899 procedure p101; 
   211      899    begin p100; sum := sum + 1 end; 
   212      908 procedure p102; 
   213      908    begin p101; sum := sum + 1 end; 
   214      917 procedure p103; 
   215      917    begin p102; sum := sum + 1 end; 
   216      926 procedure p104; 
   217      926    begin p103; sum := sum + 1 end; 
   218      935 procedure p105; 
   219      935    begin p104; sum := sum + 1 end; 
   220      944 procedure p106; 
   221      944    begin p105; sum := sum + 1 end; 
   222      953 procedure p107; 
   223      953    begin p106; sum := sum + 1 end; 
   224      962 procedure p108; 
   225      962    begin p107; sum := sum + 1 end; 
   226      971 procedure p109; 
   227      971    begin p108; sum := sum + 1 end; 
   228      980 procedure p110; 
   229      980    begin p109; sum := sum + 1 end; 
   230      989 procedure p111; 
   231      989    begin p110; sum := sum + 1 end; 
   232      998 procedure p112; 
   233      998    begin p111; sum := sum + 1 end; 
   234     1007 procedure p113; 
   235     1007    begin p112; sum := sum + 1 end; 
   236     1016 procedure p114; 
   237     1016    begin p113; sum := sum + 1 end; 
   238     1025 procedure p115; 
   239     1025    begin p114; sum := sum + 1 end; 
   240     1034 procedure p116; 
   241     1034    begin p115; sum := sum + 1 end; 
   242     1043 procedure p117; 
   243     1043    begin p116; sum := sum + 1 end; 
   244     1052 procedure p118; 
   245     1052    begin p117; sum := sum + 1 end; 
   246     1061 procedure p119; 
   247     1061    begin p118; sum := sum + 1 end; 
   248     1070 procedure p120; 
   249     1070    begin p119; sum := sum + 1 end; 
   250     1079 procedure p121; 
   251     1079    begin p120; sum := sum + 1 end; 
   252     1088 procedure p122; 
   253     1088    begin p121; sum := sum + 1 end; 
   254     1097 procedure p123; 
   255     1097    begin p122; sum := sum + 1 end; 
   256     1106 procedure p124; 
   257     1106    begin p123; sum := sum + 1 end; 
   258     1115 procedure p125; 
   259     1115    begin p124; sum := sum + 1 end; 
   260     1124 procedure p126; 
   261     1124    begin p125; sum := sum + 1 end; 
   262     1133 procedure p127; 
   263     1133    begin p126; sum := sum + 1 end; 
   264     1142 procedure p128; 
   265     1142    begin p127; sum := sum + 1 end; 
   266     1151 begin 
   267     1151 p128; 
   268     1155 if sum = 128 then 
   269     1159    writeln(' QUALITY...6.2.1-11') 
   270     1165 else 
   271     1168    writeln(' FAIL...6.2.1-11') 
   272     1174 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.2.1-11

program complete

Compiling and running t6p2p1d12

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.2.1-12, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that a large number of types (50) may be 
     4      -32    declared in a program. } 
     5      -32 {  It is an attempt to discover any small limit 
     6      -32    imposed on the number of types by a processor. } 
     7      -32 {V3.0: All variables have been assigned values. Writes 
     8      -32    to output modified. Was previously 6.2.1-8. } 
     9      -32  
    10      -32 program t6p2p1d12(output); 
    11      -32 type 
    12      -32    t1 = 0..1; 
    13      -32    t2 = 0..2; 
    14      -32    t3 = 0..3; 
    15      -32    t4 = 0..4; 
    16      -32    t5 = 0..5; 
    17      -32    t6 = 0..6; 
    18      -32    t7 = 0..7; 
    19      -32    t8 = 0..8; 
    20      -32    t9 = 0..9; 
    21      -32    t10 = 0..10; 
    22      -32    t11 = 0..11; 
    23      -32    t12 = 0..12; 
    24      -32    t13 = 0..13; 
    25      -32    t14 = 0..14; 
    26      -32    t15 = 0..15; 
    27      -32    t16 = 0..16; 
    28      -32    t17 = 0..17; 
    29      -32    t18 = 0..18; 
    30      -32    t19 = 0..19; 
    31      -32    t20 = 0..20; 
    32      -32    t21 = 0..21; 
    33      -32    t22 = 0..22; 
    34      -32    t23 = 0..23; 
    35      -32    t24 = 0..24; 
    36      -32    t25 = 0..25; 
    37      -32    t26 = 0..26; 
    38      -32    t27 = 0..27; 
    39      -32    t28 = 0..28; 
    40      -32    t29 = 0..29; 
    41      -32    t30 = 0..30; 
    42      -32    t31 = 0..31; 
    43      -32    t32 = 0..32; 
    44      -32    t33 = 0..33; 
    45      -32    t34 = 0..34; 
    46      -32    t35 = 0..35; 
    47      -32    t36 = 0..36; 
    48      -32    t37 = 0..37; 
    49      -32    t38 = 0..38; 
    50      -32    t39 = 0..39; 
    51      -32    t40 = 0..40; 
    52      -32    t41 = 0..41; 
    53      -32    t42 = 0..42; 
    54      -32    t43 = 0..43; 
    55      -32    t44 = 0..44; 
    56      -32    t45 = 0..45; 
    57      -32    t46 = 0..46; 
    58      -32    t47 = 0..47; 
    59      -32    t48 = 0..48; 
    60      -32    t49 = 0..49; 
    61      -32    t50 = 0..50; 
    62      -32 var 
    63      -32    v1 : t1; 
    64      -32    v2 : t2; 
    65      -32    v3 : t3; 
    66      -32    v4 : t4; 
    67      -32    v5 : t5; 
    68      -32    v6 : t6; 
    69      -32    v7 : t7; 
    70      -32    v8 : t8; 
    71      -32    v9 : t9; 
    72      -32    v10 : t10; 
    73      -32    v11 : t11; 
    74      -32    v12 : t12; 
    75      -32    v13 : t13; 
    76      -32    v14 : t14; 
    77      -32    v15 : t15; 
    78      -32    v16 : t16; 
    79      -32    v17 : t17; 
    80      -32    v18 : t18; 
    81      -32    v19 : t19; 
    82      -32    v20 : t20; 
    83      -32    v21 : t21; 
    84      -32    v22 : t22; 
    85      -32    v23 : t23; 
    86      -32    v24 : t24; 
    87      -32    v25 : t25; 
    88      -32    v26 : t26; 
    89      -32    v27 : t27; 
    90      -32    v28 : t28; 
    91      -32    v29 : t29; 
    92      -32    v30 : t30; 
    93      -32    v31 : t31; 
    94      -32    v32 : t32; 
    95      -32    v33 : t33; 
    96      -32    v34 : t34; 
    97      -32    v35 : t35; 
    98      -32    v36 : t36; 
    99      -32    v37 : t37; 
   100      -32    v38 : t38; 
   101      -32    v39 : t39; 
   102      -32    v40 : t40; 
   103      -32    v41 : t41; 
   104      -32    v42 : t42; 
   105      -32    v43 : t43; 
   106      -32    v44 : t44; 
   107      -32    v45 : t45; 
   108      -32    v46 : t46; 
   109      -32    v47 : t47; 
   110      -32    v48 : t48; 
   111      -32    v49 : t49; 
   112      -32    v50 : t50; 
   113      -32 begin 
   114        3    v1 := 1;     v2 := v1 +1; v3 := v2 +1; v4 := v3 +1; v5 := v4 +1; 
   115       28    v6 := v5 +1; v7 := v6 +1; v8 := v7 +1; v9 := v8 +1; v10:= v9 +1; 
   116       53    v11:= v10+1; v12:= v11+1; v13:= v12+1; v14:= v13+1; v15:= v14+1; 
   117       78    v16:= v15+1; v17:= v16+1; v18:= v17+1; v19:= v18+1; v20:= v19+1; 
   118      103    v21:= v20+1; v22:= v21+1; v23:= v22+1; v24:= v23+1; v25:= v24+1; 
   119      128    v26:= v25+1; v27:= v26+1; v28:= v27+1; v29:= v28+1; v30:= v29+1; 
   120      153    v31:= v30+1; v32:= v31+1; v33:= v32+1; v34:= v33+1; v35:= v34+1; 
   121      178    v36:= v35+1; v37:= v36+1; v38:= v37+1; v39:= v38+1; v40:= v39+1; 
   122      203    v41:= v40+1; v42:= v41+1; v43:= v42+1; v44:= v43+1; v45:= v44+1; 
   123      228    v46:= v45+1; v47:= v46+1; v48:= v47+1; v49:= v48+1; v50:= v49+1; 
   124      253    if (v50 = 50) then 
   125      257       writeln(' QUALITY...6.2.1-12') 
   126      263    else 
   127      266       writeln(' FAIL...6.2.1-12') 
   128      272 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.2.1-12

program complete

Compiling and running t6p2p1d13

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.2.1-13, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that a large number of labels (50) may be 
     4      -32    declared in a program. } 
     5      -32 {  It is an attempt to detect a small processor limit on the 
     6      -32    number of labels. NOTE: A goto-statement whose label is 
     7      -32    attached to the immediately next statement is correct Pascal, 
     8      -32    and hence this program should be acceptable to a Standard 
     9      -32    Pascal processor.  The provision of warnings of this unusual 
    10      -32    situation is satisfactory, but rejecting the program is not. } 
    11      -32 {V3.0: A note added to indicate that null gotos are correct Pascal. 
    12      -32    Program modified to actually use all labels. 
    13      -32    Was previously 6.2.1-9. } 
    14      -32  
    15      -32 program t6p2p1d13(output); 
    16      -32 label 
    17      -32    1,2,3,4,5,6,7,8,9,10, 
    18      -32    11,12,13,14,15,16,17,18,19,20, 
    19      -32    21,22,23,24,25,26,27,28,29,30, 
    20      -32    31,32,33,34,35,36,37,38,39,40, 
    21      -32    41,42,43,44,45,46,47,48,49,50; 
    22      -32 begin 
    23        3    goto 1; 
    24        6    1:  goto 2; 
    25        7    2:  goto 3; 
    26        8    3:  goto 4; 
    27        9    4:  goto 5; 
    28       10    5:  goto 6; 
    29       11    6:  goto 7; 
    30       12    7:  goto 8; 
    31       13    8:  goto 9; 
    32       14    9:  goto 10; 
    33       15    10: goto 11; 
    34       16    11: goto 12; 
    35       17    12: goto 13; 
    36       18    13: goto 14; 
    37       19    14: goto 15; 
    38       20    15: goto 16; 
    39       21    16: goto 17; 
    40       22    17: goto 18; 
    41       23    18: goto 19; 
    42       24    19: goto 20; 
    43       25    20: goto 21; 
    44       26    21: goto 22; 
    45       27    22: goto 23; 
    46       28    23: goto 24; 
    47       29    24: goto 25; 
    48       30    25: goto 26; 
    49       31    26: goto 27; 
    50       32    27: goto 28; 
    51       33    28: goto 29; 
    52       34    29: goto 30; 
    53       35    30: goto 31; 
    54       36    31: goto 32; 
    55       37    32: goto 33; 
    56       38    33: goto 34; 
    57       39    34: goto 35; 
    58       40    35: goto 36; 
    59       41    36: goto 37; 
    60       42    37: goto 38; 
    61       43    38: goto 39; 
    62       44    39: goto 40; 
    63       45    40: goto 41; 
    64       46    41: goto 42; 
    65       47    42: goto 43; 
    66       48    43: goto 44; 
    67       49    44: goto 45; 
    68       50    45: goto 46; 
    69       51    46: goto 47; 
    70       52    47: goto 48; 
    71       53    48: goto 49; 
    72       54    49: goto 50; 
    73       55    50: writeln(' QUALITY...6.2.1-13') 
    74       61 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.2.1-13

program complete

Compiling and running t6p2p1d14

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.2.1-14, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that 128 constant definitions are allowed 
     4      -32    in one constant-definition-part. } 
     5      -32 {V3.0: New test. } 
     6      -32  
     7      -32 program t6p2p1d14(output); 
     8      -32 const 
     9      -32   c1  =   28 ;  c2  = - c1 ;  c3  = - c2 ;  c4  = - c3 ;  c5  = - c4 ; 
    10      -32   c6  = - c5 ;  c7  = - c6 ;  c8  = - c7 ;  c9  = - c8 ;  c10 = - c9 ; 
    11      -32   c11 = - c10;  c12 = - c11;  c13 = - c12;  c14 = - c13;  c15 = - c14; 
    12      -32   c16 = - c15;  c17 = - c16;  c18 = - c17;  c19 = - c18;  c20 = - c19; 
    13      -32   c21 = - c20;  c22 = - c21;  c23 = - c22;  c24 = - c23;  c25 = - c24; 
    14      -32   c26 = - c25;  c27 = - c26;  c28 = - c27;  c29 = - c28;  c30 = - c29; 
    15      -32   c31 = - c30;  c32 = - c31;  c33 = - c32;  c34 = - c33;  c35 = - c34; 
    16      -32   c36 = - c35;  c37 = - c36;  c38 = - c37;  c39 = - c38;  c40 = - c39; 
    17      -32   c41 = - c40;  c42 = - c41;  c43 = - c42;  c44 = - c43;  c45 = - c44; 
    18      -32   c46 = - c45;  c47 = - c46;  c48 = - c47;  c49 = - c48;  c50 = - c49; 
    19      -32   c51 = - c50;  c52 = - c51;  c53 = - c52;  c54 = - c53;  c55 = - c54; 
    20      -32   c56 = - c55;  c57 = - c56;  c58 = - c57;  c59 = - c58;  c60 = - c59; 
    21      -32   c61 = - c60;  c62 = - c61;  c63 = - c62;  c64 = - c63;  c65 = - c64; 
    22      -32   c66 = - c65;  c67 = - c66;  c68 = - c67;  c69 = - c68;  c70 = - c69; 
    23      -32   c71 = - c70;  c72 = - c71;  c73 = - c72;  c74 = - c73;  c75 = - c74; 
    24      -32   c76 = - c75;  c77 = - c76;  c78 = - c77;  c79 = - c78;  c80 = - c79; 
    25      -32   c81 = - c80;  c82 = - c81;  c83 = - c82;  c84 = - c83;  c85 = - c84; 
    26      -32   c86 = - c85;  c87 = - c86;  c88 = - c87;  c89 = - c88;  c90 = - c89; 
    27      -32   c91 = - c90;  c92 = - c91;  c93 = - c92;  c94 = - c93;  c95 = - c94; 
    28      -32   c96 = - c95;  c97 = - c96;  c98 = - c97;  c99 = - c98;  c100= - c99; 
    29      -32   c101= -c100;  c102= -c101;  c103= -c102;  c104= -c103;  c105= -c104; 
    30      -32   c106= -c105;  c107= -c106;  c108= -c107;  c109= -c108;  c110= -c109; 
    31      -32   c111= -c110;  c112= -c111;  c113= -c112;  c114= -c113;  c115= -c114; 
    32      -32   c116= -c115;  c117= -c116;  c118= -c117;  c119= -c118;  c120= -c119; 
    33      -32   c121= -c120;  c122= -c121;  c123= -c122;  c124= -c123;  c125= -c124; 
    34      -32   c126= -c125;  c127= -c126;  c128= -c127; 
    35      -32 begin 
    36        3 if c128 = -28 then 
    37       10    writeln(' QUALITY...6.2.1-14') 
    38       16 else 
    39       19    writeln(' FAIL...6.2.1-14') 
    40       25 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.2.1-14

program complete

Compiling and running t6p4p3p2d7

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.4.3.2-7, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that large arrays can be declared. } 
     4      -32 {V3.0: New test. } 
     5      -32  
     6      -32 program t6p4p3p2d7(output); 
     7      -32 type 
     8      -32    ar = array[0 .. 1023] of integer; 
     9      -32 var 
    10      -32    x: record 
    11      -32       ar1, ar2, ar3, ar4, ar5: ar 
    12      -32       end; 
    13      -32 begin 
    14        3 x.ar1[0] := 1;  x.ar1[1023] := - 1; 
    15       18 x.ar2[0] := 2;  x.ar2[1023] := - 2; 
    16       31 x.ar3[0] := 3;  x.ar3[1023] := - 3; 
    17       44 x.ar4[0] := 4;  x.ar4[1023] := - 4; 
    18       57 x.ar5[0] := 5;  x.ar5[1023] := - 5; 
    19       70 if (x.ar1[0] + x.ar1[1023] <> 0) or 
    20       83    (x.ar2[0] + x.ar2[1023] <> 0) or 
    21       97    (x.ar3[0] + x.ar3[1023] <> 0) or 
    22      111    (x.ar4[0] + x.ar4[1023] <> 0) or 
    23      125    (x.ar5[0] + x.ar5[1023] <> 0) then 
    24      140    writeln(' FAIL...6.4.3.2-7') 
    25      146 else 
    26      149    writeln(' QUALITY...6.4.3.2-7') 
    27      155 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.4.3.2-7

program complete

Compiling and running t6p4p3p2d8

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.4.3.2-8, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that 8 index-types can appear in an 
     4      -32    array-type. } 
     5      -32 {V3.0: New test. } 
     6      -32  
     7      -32 program t6p4p3p2d8(output); 
     8      -32 type 
     9      -32    t1 = 0 .. 1; 
    10      -32    t2 = 1 .. 2; 
    11      -32    t3 = 2 .. 3; 
    12      -32    t4 = 3 .. 4; 
    13      -32    t5 = 4 .. 5; 
    14      -32    t6 = 5 .. 6; 
    15      -32    t7 = 6 .. 7; 
    16      -32    t8 = 7 .. 8; 
    17      -32    ta = array[ t1, t2, t3, t4, t5, t6, t7, t8] of integer; 
    18      -32 var 
    19      -32    a: ta; 
    20      -32 begin 
    21        3 a[0, 1, 2, 3, 4, 5, 6, 7] := 1; 
    22       39 a[1, 2, 3, 4, 5, 6, 7, 8] := a[0, 1, 2, 3, 4, 5, 6, 7] + 1; 
    23      107 if a[1, 2, 3, 4, 5, 6, 7, 8] = 2 then 
    24      143    writeln(' QUALITY...6.4.3.2-8') 
    25      149 else 
    26      152    writeln(' FAIL...6.4.3.2-8') 
    27      158 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.4.3.2-8

program complete

Compiling and running t6p4p3p3d14

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.4.3.3-14, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that 128 case-constant values are permitted 
     4      -32    in a variant record. } 
     5      -32 {V3.0: New test. } 
     6      -32  
     7      -32 program t6p4p3p3d14(output); 
     8      -32 type 
     9      -32    t128 = 0 .. 127; 
    10      -32    vrec = record 
    11      -32           case t: t128 of 
    12      -32           0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 
    13      -32           10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 
    14      -32           20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 
    15      -32           30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 
    16      -32           40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 
    17      -32           50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 
    18      -32           60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 
    19      -32           70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 
    20      -32           80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 
    21      -32           90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 
    22      -32           100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 
    23      -32           110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 
    24      -32           120, 121, 122, 123, 124, 125, 126, 127 
    25      -32              :(i: integer) 
    26      -32           end; 
    27      -32 var 
    28      -32    v: vrec; 
    29      -32 begin 
    30        3    v.t := 0; 
    31        9    v.i := 120; 
    32      142    v.t := 127; 
    33      146    v.i := -3; 
    34      280    v.t := 0; 
    35      284    if v.i = -3 then 
    36      420       writeln(' QUALITY...6.4.3.3-14') 
    37      426    else 
    38      429       writeln(' FAIL...6.4.3.3-14') 
    39      435 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.4.3.3-14

program complete

Compiling and running t6p4p3p3d15

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.4.3.3-15, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that 50 record-sections can appear in 
     4      -32    the fixed part of a record. } 
     5      -32 {V3.0: New test. } 
     6      -32  
     7      -32 program t6p4p3p3d15(output); 
     8      -32 type longrec = record 
     9      -32                 i1: integer;  i2: integer; 
    10      -32                 i3: integer;  i4: integer; 
    11      -32                 i5: integer;  i6: integer; 
    12      -32                 i7: integer;  i8: integer; 
    13      -32                 i9: integer; i10: integer; 
    14      -32                i11: integer; i12: integer; 
    15      -32                i13: integer; i14: integer; 
    16      -32                i15: integer; i16: integer; 
    17      -32                i17: integer; i18: integer; 
    18      -32                i19: integer; i20: integer; 
    19      -32                i21: integer; i22: integer; 
    20      -32                i23: integer; i24: integer; 
    21      -32                i25: integer; i26: integer; 
    22      -32                i27: integer; i28: integer; 
    23      -32                i29: integer; i30: integer; 
    24      -32                i31: integer; i32: integer; 
    25      -32                i33: integer; i34: integer; 
    26      -32                i35: integer; i36: integer; 
    27      -32                i37: integer; i38: integer; 
    28      -32                i39: integer; i40: integer; 
    29      -32                i41: integer; i42: integer; 
    30      -32                i43: integer; i44: integer; 
    31      -32                i45: integer; i46: integer; 
    32      -32                i47: integer; i48: integer; 
    33      -32                i49: integer; i50: integer 
    34      -32                end; 
    35      -32 var 
    36      -32    v: longrec; 
    37      -32 begin 
    38        3    v.i1  := 1;         v.i2  := v.i1 + 1; 
    39       11    v.i3  := v.i2 + 1;  v.i4  := v.i3 + 1; 
    40       19    v.i5  := v.i4 + 1;  v.i6  := v.i5 + 1; 
    41       27    v.i7  := v.i6 + 1;  v.i8  := v.i7 + 1; 
    42       35    v.i9  := v.i8 + 1;  v.i10 := v.i9 + 1; 
    43       43    v.i11 := v.i10 + 1; v.i12 := v.i11 + 1; 
    44       51    v.i13 := v.i12 + 1; v.i14 := v.i13 + 1; 
    45       59    v.i15 := v.i14 + 1; v.i16 := v.i15 + 1; 
    46       67    v.i17 := v.i16 + 1; v.i18 := v.i17 + 1; 
    47       75    v.i19 := v.i18 + 1; v.i20 := v.i19 + 1; 
    48       83    v.i21 := v.i20 + 1; v.i22 := v.i21 + 1; 
    49       91    v.i23 := v.i22 + 1; v.i24 := v.i23 + 1; 
    50       99    v.i25 := v.i24 + 1; v.i26 := v.i25 + 1; 
    51      107    v.i27 := v.i26 + 1; v.i28 := v.i27 + 1; 
    52      115    v.i29 := v.i28 + 1; v.i30 := v.i29 + 1; 
    53      123    v.i31 := v.i30 + 1; v.i32 := v.i31 + 1; 
    54      131    v.i33 := v.i32 + 1; v.i34 := v.i33 + 1; 
    55      139    v.i35 := v.i34 + 1; v.i36 := v.i35 + 1; 
    56      147    v.i37 := v.i36 + 1; v.i38 := v.i37 + 1; 
    57      155    v.i39 := v.i38 + 1; v.i40 := v.i39 + 1; 
    58      163    v.i41 := v.i40 + 1; v.i42 := v.i41 + 1; 
    59      171    v.i43 := v.i42 + 1; v.i44 := v.i43 + 1; 
    60      179    v.i45 := v.i44 + 1; v.i46 := v.i45 + 1; 
    61      187    v.i47 := v.i46 + 1; v.i48 := v.i47 + 1; 
    62      195    v.i49 := v.i48 + 1; v.i50 := v.i49 + 1; 
    63      203    if v.i50 = 50 then 
    64      207       writeln(' QUALITY...6.4.3.3-15') 
    65      213    else 
    66      216       writeln(' FAIL...6.4.3.3-15') 
    67      222 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.4.3.3-15

program complete

Compiling and running t6p4p3p3d16

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.4.3.3-16, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that 30 distinct variants are 
     4      -32    permitted in a record. } 
     5      -32 {V3.0: New test. } 
     6      -32  
     7      -32 program t6p4p3p3d16(output); 
     8      -32 type 
     9      -32    t30 = 1 .. 30; 
    10      -32    manyvariants = record 
    11      -32                   case t: t30 of 
    12      -32                    1: ( i1: integer);  2: ( i2: integer); 
    13      -32                    3: ( i3: integer);  4: ( i4: integer); 
    14      -32                    5: ( i5: integer);  6: ( i6: integer); 
    15      -32                    7: ( i7: integer);  8: ( i8: integer); 
    16      -32                    9: ( i9: integer); 10: (i10: integer); 
    17      -32                   11: (i11: integer); 12: (i12: integer); 
    18      -32                   13: (i13: integer); 14: (i14: integer); 
    19      -32                   15: (i15: integer); 16: (i16: integer); 
    20      -32                   17: (i17: integer); 18: (i18: integer); 
    21      -32                   19: (i19: integer); 20: (i20: integer); 
    22      -32                   21: (i21: integer); 22: (i22: integer); 
    23      -32                   23: (i23: integer); 24: (i24: integer); 
    24      -32                   25: (i25: integer); 26: (i26: integer); 
    25      -32                   27: (i27: integer); 28: (i28: integer); 
    26      -32                   29: (i29: integer); 30: (i30: integer) 
    27      -32                   end; 
    28      -32 var 
    29      -32    v: manyvariants; 
    30      -32 begin 
    31        3    v.t := 1; 
    32        9    v.i1 := 1; 
    33       15    v.t := v.t + 29; 
    34       21    v.i30 := -6; 
    35       28    if (v.t = 30) and (v.i30 = -6) then 
    36       41       writeln(' QUALITY...6.4.3.3-16') 
    37       47    else 
    38       50       writeln(' FAIL...6.4.3.3-16') 
    39       56 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.4.3.3-16

program complete

Compiling and running t6p4p3p4d4

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.4.3.4-4, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test is an implementation of Warshall's algorithm 
     4      -32    in Pascal. } 
     5      -32 {  It serves to give a program which can be used both to time a 
     6      -32    simple procedure using sets, and which can measure the space 
     7      -32    requirements. In both cases the measurements of the procedure 
     8      -32    warshallsalgorithm are to be compared. 
     9      -32    By way of comparison, the Tasmanian compiler on the Burroughs 
    10      -32    B6700 yielded     space = 231 bytes ( 1848 bits) 
    11      -32    and               time  = 0.7 seconds 
    12      -32    NOTE: This program contains two calls on a non-standard real 
    13      -32    function processtime, which conceptually returns the time 
    14      -32    spent in processing the program to the point of invocation. 
    15      -32    There is no standard way of asking for this information, and 
    16      -32    users of the package must supply a local definition. } 
    17      -32 {V3.0: Comment revised to include a note on processtime calls. 
    18      -32    Was previously 6.4.3.4-5. } 
    19      -32  
    20      -32 program t6p4p3p4d4(output); 
    21      -32 const 
    22      -32    size = 79;   {array is (size+1) by (size+1) square} 
    23      -32    words = 4;   {size div 16} 
    24      -32    bitsperword = 16;   {assume everyone allows this} 
    25      -32    bitsminus1 = 15;   {bitsperword-1} 
    26      -32 type 
    27      -32    btype = array [0..size] of array [0..words] 
    28      -32          of set of 0..bitsminus1; 
    29      -32 var 
    30      -32    seed:integer; 
    31      -32    t1,t2:real; 
    32      -32    original,closure:btype; 
    33      -32  
    34      -32 function processtime : real; 
    35      -32 begin 
    36        3    processtime := 0.0; 
    37        7 end;  { dummy function } 
    38        8  
    39        8 function generate:integer; 
    40        8 begin 
    41        8    seed:=57*seed+1; 
    42       16    generate := (seed mod (size+1)); 
    43       22    seed:=seed mod 571 
    44       23 end;   {of generate} 
    45       27  
    46       27 procedure fill(var a:btype; p:integer); 
    47       27 var 
    48      -40    i:0..size; 
    49      -44    j:0..bitsminus1; 
    50      -48    k,l:0..maxint; 
    51      -56 begin 
    52       27    for j:=0 to words do a[0][j]:=[]; 
    53       61    for i:=1 to size do a[i]:=a[0]; 
    54       92    for k:=1 to p do begin 
    55      103       i:=generate; 
    56      107       l:=generate; 
    57      111       j:=l div bitsperword; 
    58      116       a[i][j] := a[i][j]+[(l mod bitsperword)] 
    59      135    end 
    60      138 end;   {of fill} 
    61      150  
    62      150 procedure print(var b:btype); 
    63      150 var 
    64      -36    i,j:0..size; 
    65      -44 begin 
    66      150    for i:=0 to size do begin 
    67      163       write(' '); 
    68      169       for j:=0 to size do begin 
    69      180          if (j mod bitsperword) in b[i][j div bitsperword] then 
    70      195             write('+') 
    71      200          else 
    72      202             write('-') 
    73      207       end; 
    74      219       writeln 
    75      219    end 
    76      222 end;   {of print} 
    77      234  
    78      234 procedure warshallsalgorithm(var a,b:btype); 
    79      234    {examine the code to see how many bytes of 8-bits are required} 
    80      234 var 
    81      -40    i,j:0..size; 
    82      -48    k:0..words; 
    83      -52 begin 
    84      234    b:=a; 
    85      239    for i:=0 to size do 
    86      250       for j:=0 to size do 
    87      261          if (i mod bitsperword) in b[j][i div bitsperword] then 
    88      276             for k:=0 to words do 
    89      287                b[j][k] := b[j][k]+b[i][k] 
    90      309 end;   {of warshallsalgorithm} 
    91      347  
    92      347 begin    {of main program} 
    93      347    seed:=1; 
    94      351    fill(original,125); 
    95      355    t1:=processtime;   {ie begin timing however you do it} 
    96      358    warshallsalgorithm(original,closure); 
    97      362    t2:=processtime;   {ie stop timing} 
    98      365    writeln(' TIME=',t2-t1); 
    99      378    writeln(' ORIGINAL MATRIX'); 
   100      386    print(original); 
   101      389    writeln(' TRANSITIVE CLOSURE'); 
   102      397    print(closure); 
   103      400    writeln(' QUALITY...6.4.3.4-4') 
   104      406 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 TIME= 0.000000000000000e+00
 ORIGINAL MATRIX
 --------------------------------------------------------------------------------
 -------------------------------------------------------------+------------------
 ------+-------------------------------------------------------------------------
 --------------------------------------------------------------------------------
 ----------------------+-----------------------+---------------------------------
 -----------------------------------------------------------------------+--------
 -----------------------------------+-----------------------+-------+------------
 -----------------------+---------------------------------------+----------------
 ----------------+---------------------------------------+-----------------------
 --------------------------------------------------------------------------------
 --------------------------------------------------------------------------------
 ------------+---------------+---------------------------------------------------
 -------------+-----------------------+-------------------------------+----------
 -----------------+--------------------------------------------------------------
 -------------------------------------------------------------+------------------
 --------------+-------+---------------------------------------------------------
 --------------------------------------------------------------------------------
 ----------------------+---------------------------------------------------------
 -------------------------------+-------+---------------------------------------+
 ---------------------------------------------------+-----------------------+----
 -------+------------------------------------------------------------------------
 -----------------------------------------------------------+--------------------
 ----+---------------------------------------------------------------+-----------
 --------------------------------+-----------------------------------------------
 --------------------------------------------------------------------------------
 -------------+------------------------------------------------------------------
 -------------------------+------------------------------------------------------
 -----------------------------+--------------------------------------------------
 ------+-------------------------------------------------------------------------
 ----------+---------------------------------------------------------------------
 --------------------------------------------------------------------------------
 ------------------+-------------------------------------------------------+-----
 --------------------------------------------------------------------------------
 ---------------+-------+-----------------------------------------------+--------
 ---------------------------+---------------------------------------+------------
 --------------------+---------------+-------+-----------------------------------
 --------+-----------------------------------------------+-----------------------
 ----------------------------+---------------+-------------------------------+---
 --------------------------------------------------------------------------------
 --------------------------------------------------------------------------------
 --------------------------------------------------------------------------------
 -------------------------------------------------------------------------+------
 --------------------------+-----------------------------------------------------
 ----------------------------------------------+-----------------------+---------
 --------------------------------------------------------------------------------
 -------------------------------------------+---------------+-------+------------
 -------+-----------------------+-------------------------------+-------+--------
 -------------------+-----------------------------------------------+------------
 ------------+-------+-----------------------------------------------------------
 ----------------------------------------+-------------------------------+-------
 ----------------------------------------------------------------------------+---
 ------------------------------------------------------------------------+-------
 -+---------------+---------------------------------------+----------------------
 -------------------------------------+-------+----------------------------------
 -+-----------------------+---------------------------------------+--------------
 --+-----------------------------------------------------------------------------
 ------------------------------+-------------------------------------------------
 ----------+-------------------------------------------------------+-------------
 ---------------------------+----------------------------------------------------
 --------------------------------------------------------------------------------
 -------------------+------------------------------------------------------------
 ---------------------------------------+-------+--------------------------------
 ----------------+-----------------------+-------+-------------------------------
 ------------+---------------+---------------------------------------------------
 +-----------------------+-------+-----------------------------------------------
 -+-------+---------------+-------------------------------+----------------------
 -------------+-------------------------------+-------------------------------+--
 --------------------------------------------------------------------------------
 ------------------------------------------+-------------------------------+-----
 ------+---------------+---------------------------------------------------------
 --------------------------------------------------------------------------------
 ------------------------------+-------------------------------+-------+---------
 ---------------+-----------------------+----------------------------------------
 -----------------------------------+--------------------------------------------
 -----------------------------------------------+-----------------------+-------+
 +-------------------------------+-----------------------------------------------
 --------------------------------------------------------------------------------
 +---------------------------------------+---------------------------------------
 -----------------+---------------------------------------+-------+--------------
 -----+-----------------------+-------------------------------+------------------
 TRANSITIVE CLOSURE
 --------------------------------------------------------------------------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 --------------------------------------------------------------------------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 ----------------+-------------+-------------------------+-----------------------
 --------------------------------------------------------------------------------
 --------------------------------------------------------------------------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 --------------------------------------------------------------------------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 -----------------------------------------------------------+--------------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 --------------------------------+-----------------------------------------------
 --------------------------------------------------------------------------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 ----------+------------------+--------------------------------------------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 ----------+---------------------------------------------------------------------
 --------------------------------------------------------------------------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 --------------------------------------------------------------------------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 ----------+----------------+-+-------------------------------------+------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 --------+-------+-------------+-------------------------+-----------------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 --------------------------------------------------------------------------------
 --------------------------------------------------------------------------------
 --------------------------------------------------------------------------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++++++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 --------------------------------------------------------------------------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+++-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 ----------------------------------------------------------------------------+---
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 ++--+++++-+-+++++++++-++-++-+++++--+++-++-+++++++--+----++-+-+++--+++++++-++++-+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+++++++--+----+--+-+++---++++++-+++--+
 ++--+++++++-+++++++++-++-++-+++++--+++-++-+++++++--+----++-+-+++-++++++++-++++-+
 +-+-+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 ------------------------------+-------------------------------------------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+++++++--+----+--+-+++--+++++++-++++-+
 ----------+----------------+-+--------------------------------------------------
 --------------------------------------------------------------------------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +-----------------------+-------+-----------------------------------------------
 ++--+++++++-+++++++++-++-++-+++++--+++-++-+++++++--+----++-+-+++--+++++++-++++-+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+++++++--+----+--+-+++---++++++-++++-+
 --------------------------------------------------------------------------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 --------------------------------------------------------------------------------
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 +-------------------------------+-----------------------------------------------
 --------------------------------------------------------------------------------
 +---------------------------------------+---------------------------------------
 ++--+++++++-+++++++++-++-++-+++++--+++-++-+++++++--+----++-+-+++-++++++++-++++-+
 +---+++++-+-+++++++++-++-++-+++++--+++-++-+-+-+++--+----+--+-+++---++++++-+++--+
 QUALITY...6.4.3.4-4

program complete

Compiling and running t6p5p1d2

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.5.1-2, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that 300 identifiers are allowed in a 
     4      -32    variable-declaration-part. } 
     5      -32 {V3.0: Upgrade of existing test. } 
     6      -32  
     7      -32 program t6p5p1d2(output); 
     8      -32 var 
     9      -32    i000,i001,i002,i003,i004,i005,i006,i007,i008,i009, 
    10      -32    i010,i011,i012,i013,i014,i015,i016,i017,i018,i019, 
    11      -32    i020,i021,i022,i023,i024,i025,i026,i027,i028,i029, 
    12      -32    i030,i031,i032,i033,i034,i035,i036,i037,i038,i039, 
    13      -32    i040,i041,i042,i043,i044,i045,i046,i047,i048,i049, 
    14      -32    i050,i051,i052,i053,i054,i055,i056,i057,i058,i059, 
    15      -32    i060,i061,i062,i063,i064,i065,i066,i067,i068,i069, 
    16      -32    i070,i071,i072,i073,i074,i075,i076,i077,i078,i079, 
    17      -32    i080,i081,i082,i083,i084,i085,i086,i087,i088,i089, 
    18      -32    i090,i091,i092,i093,i094,i095,i096,i097,i098,i099, 
    19      -32    i100,i101,i102,i103,i104,i105,i106,i107,i108,i109, 
    20      -32    i110,i111,i112,i113,i114,i115,i116,i117,i118,i119, 
    21      -32    i120,i121,i122,i123,i124,i125,i126,i127,i128,i129, 
    22      -32    i130,i131,i132,i133,i134,i135,i136,i137,i138,i139, 
    23      -32    i140,i141,i142,i143,i144,i145,i146,i147,i148,i149, 
    24      -32    i150,i151,i152,i153,i154,i155,i156,i157,i158,i159, 
    25      -32    i160,i161,i162,i163,i164,i165,i166,i167,i168,i169, 
    26      -32    i170,i171,i172,i173,i174,i175,i176,i177,i178,i179, 
    27      -32    i180,i181,i182,i183,i184,i185,i186,i187,i188,i189, 
    28      -32    i190,i191,i192,i193,i194,i195,i196,i197,i198,i199, 
    29      -32    i200,i201,i202,i203,i204,i205,i206,i207,i208,i209, 
    30      -32    i210,i211,i212,i213,i214,i215,i216,i217,i218,i219, 
    31      -32    i220,i221,i222,i223,i224,i225,i226,i227,i228,i229, 
    32      -32    i230,i231,i232,i233,i234,i235,i236,i237,i238,i239, 
    33      -32    i240,i241,i242,i243,i244,i245,i246,i247,i248,i249, 
    34      -32    i250,i251,i252,i253,i254,i255,i256,i257,i258,i259, 
    35      -32    i260,i261,i262,i263,i264,i265,i266,i267,i268,i269, 
    36      -32    i270,i271,i272,i273,i274,i275,i276,i277,i278,i279, 
    37      -32    i280,i281,i282,i283,i284,i285,i286,i287,i288,i289, 
    38      -32    i290,i291,i292,i293,i294,i295,i296,i297,i298,i299 
    39      -32    : integer; 
    40      -32 procedure setvalues( i: integer; 
    41      -36                  var i1, i2, i3, i4, i5, i6, i7, i8, i9, i10:integer); 
    42      -76    begin 
    43        3    i1 := i; 
    44        8    i2 := i1 + 1; 
    45       14    i3 := i2 + 2; 
    46       20    i4 := i3 + 3; 
    47       26    i5 := i4 + 4; 
    48       32    i6 := i5 + 5; 
    49       38    i7 := i6 + 6; 
    50       44    i8 := i7 + 7; 
    51       50    i9 := i8 + 8; 
    52       56    i10 := i9 + 9 
    53       59    end; 
    54       63 begin 
    55       63    setvalues(0,i000,i001,i002,i003,i004,i005,i006,i007,i008,i009); 
    56       78    setvalues(i009,i010,i011,i012,i013,i014,i015,i016,i017,i018,i019); 
    57       91    setvalues(i019,i020,i021,i022,i023,i024,i025,i026,i027,i028,i029); 
    58      104    setvalues(i029,i030,i031,i032,i033,i034,i035,i036,i037,i038,i039); 
    59      117    setvalues(i039,i040,i041,i042,i043,i044,i045,i046,i047,i048,i049); 
    60      130    setvalues(i049,i050,i051,i052,i053,i054,i055,i056,i057,i058,i059); 
    61      143    setvalues(i059,i060,i061,i062,i063,i064,i065,i066,i067,i068,i069); 
    62      156    setvalues(i069,i070,i071,i072,i073,i074,i075,i076,i077,i078,i079); 
    63      169    setvalues(i079,i080,i081,i082,i083,i084,i085,i086,i087,i088,i089); 
    64      182    setvalues(i089,i090,i091,i092,i093,i094,i095,i096,i097,i098,i099); 
    65      195    setvalues(i099,i100,i101,i102,i103,i104,i105,i106,i107,i108,i109); 
    66      208    setvalues(i109,i110,i111,i112,i113,i114,i115,i116,i117,i118,i119); 
    67      221    setvalues(i119,i120,i121,i122,i123,i124,i125,i126,i127,i128,i129); 
    68      234    setvalues(i129,i130,i131,i132,i133,i134,i135,i136,i137,i138,i139); 
    69      247    setvalues(i139,i140,i141,i142,i143,i144,i145,i146,i147,i148,i149); 
    70      260    setvalues(i149,i150,i151,i152,i153,i154,i155,i156,i157,i158,i159); 
    71      273    setvalues(i159,i160,i161,i162,i163,i164,i165,i166,i167,i168,i169); 
    72      286    setvalues(i169,i170,i171,i172,i173,i174,i175,i176,i177,i178,i179); 
    73      299    setvalues(i179,i180,i181,i182,i183,i184,i185,i186,i187,i188,i189); 
    74      312    setvalues(i189,i190,i191,i192,i193,i194,i195,i196,i197,i198,i199); 
    75      325    setvalues(i199,i200,i201,i202,i203,i204,i205,i206,i207,i208,i209); 
    76      338    setvalues(i209,i210,i211,i212,i213,i214,i215,i216,i217,i218,i219); 
    77      351    setvalues(i219,i220,i221,i222,i223,i224,i225,i226,i227,i228,i229); 
    78      364    setvalues(i229,i230,i231,i232,i233,i234,i235,i236,i237,i238,i239); 
    79      377    setvalues(i239,i240,i241,i242,i243,i244,i245,i246,i247,i248,i249); 
    80      390    setvalues(i249,i250,i251,i252,i253,i254,i255,i256,i257,i258,i259); 
    81      403    setvalues(i259,i260,i261,i262,i263,i264,i265,i266,i267,i268,i269); 
    82      416    setvalues(i269,i270,i271,i272,i273,i274,i275,i276,i277,i278,i279); 
    83      429    setvalues(i279,i280,i281,i282,i283,i284,i285,i286,i287,i288,i289); 
    84      442    setvalues(i289,i290,i291,i292,i293,i294,i295,i296,i297,i298,i299); 
    85      455    if i299 = 1350 then 
    86      459       writeln(' QUALITY...6.5.1-2') 
    87      465    else 
    88      468       writeln(' FAIL...6.5.1-2') 
    89      474 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.5.1-2

program complete

Compiling and running t6p5p3d1

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.5.3-1, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that the three forms of addressing (indexing, 
     4      -32    indirection and field selection) do not interact incorrectly. } 
     5      -32 {V3.1: New test. } 
     6      -32  
     7      -32 program t6p5p3d1(output); 
     8      -32 type 
     9      -32    subscript = -1 .. 1; 
    10      -32    ptarr = ^arr; 
    11      -32    ptrec = ^rec; 
    12      -32    arr = array [subscript] of record 
    13      -32                                 a: ptarr; 
    14      -32                                 b: ptrec; 
    15      -32                                 c: array [subscript] of integer; 
    16      -32                               end; 
    17      -32    rec = record 
    18      -32             x: arr; 
    19      -32             y: ptarr; 
    20      -32             z: ptrec; 
    21      -32          end; 
    22      -32 var 
    23      -32    p, q: array [subscript] of rec; 
    24      -32    i, j, k : subscript; 
    25      -32    y: ptarr; 
    26      -32    z: ptrec; 
    27      -32    fail: boolean; 
    28      -32    caseno: integer; 
    29      -32 procedure checkequal(x, y: integer); 
    30      -40    begin 
    31        3    if x <> y then 
    32        9       begin 
    33        9       fail := true; 
    34       12       writeln('NOT EQUAL ', x, y, 'CASE NO ', caseno); 
    35       33       end; 
    36       33    caseno := caseno + 1 
    37       34    end; 
    38       38 begin 
    39       38 y := nil; 
    40       43 z := nil; 
    41       46 for i := -1 to 1 do 
    42       58    begin 
    43       58    p[i].y := y; 
    44       67    p[i].z := z; 
    45       76    new( q[i].y ); 
    46       84    y := q[i].y; 
    47       92    new( q[i].z ); 
    48      100    z := q[i].z; 
    49      108    for j := -1 to 1 do 
    50      120       begin 
    51      120       p[i].x[j].a := nil; 
    52      132       p[i].x[j].b := nil; 
    53      145       q[i].x[j].a := nil; 
    54      157       q[i].x[j].b := nil; 
    55      170       for k := -1 to 1 do 
    56      182          begin 
    57      182          p[i].x[j].c[k] := i + j + k; 
    58      202          q[i].x[j].c[k] := p[i].x[j].c[k] + 100; 
    59      234          end; 
    60      245       end; 
    61      256    y^ := p[i].x; 
    62      264    z^ := q[i]; 
    63      272    end; 
    64      283 for i := 1 downto -1 do 
    65      295    begin 
    66      295    for j := -1 to 1 do 
    67      307       begin 
    68      307       p[i].x[j].a := q[-i*j].y; 
    69      327       q[i].x[j].a := q[i*abs(j)].y; 
    70      347       p[i].x[j].b := q[abs(i)*j].z; 
    71      368       q[i].x[j].b := q[-i*j].z; 
    72      389       end; 
    73      400    end; 
    74      411 p[-1].x[-1].a^[-1].a := q[-1].y; 
    75      438 q[-1].x[-1].a^[0].a := q[0].y; 
    76      463 p[1].x[1].a^[-1].b := p[1].z; 
    77      488 q[-1].y^[0].b := p[-1].x[0].b; 
    78      514 p[0].y^[1].b := p[-1].x[-1].b; 
    79      540 p[-1].x[-1].b^.x[-1].a := q[0].y; 
    80      566 q[-1].x[-1].b^.x[-1].b := q[-1].x[-1].b; 
    81      599 q[-1].z^.x[0].a := q[0].y; 
    82      619 p[1].x[-1].b^.x[0].b := q[0].z; 
    83      644 q[1].x[1].b^.x[1].a := q[-1].y; 
    84      668 q[-1].z^.x[1].b := q[1].x[-1].b; 
    85      694 p[-1].x[0].a^[-1].a := q[1].y; 
    86      719 q[-1].x[0].a^[-1].b := q[1].z; 
    87      745 p[0].x[-1].a^[0].a := p[1].y; 
    88      769 q[0].x[-1].a^[0].b := q[1].z; 
    89      794 p[0].x[0].a^[1].a := q[-1].y; 
    90      818 p[0].x[0].a^[1].a := q[-1].y; 
    91      842 q[0].x[0].a^[1].b := p[1].x[-1].b; 
    92      871 p[0].x[-1].b^.x[-1].a := q[1].y; 
    93      896 q[0].x[1].b^.x[-1].b := q[0].x[-1].b; 
    94      926 p[0].x[0].b^.x[0].a := p[1].y; 
    95      949 q[0].x[0].b^.x[0].b := p[1].z; 
    96      973 p[0].x[1].b^.x[1].a := q[-1].y; 
    97      997 q[0].x[1].b^.x[1].b := q[-1].z; 
    98     1022 p[1].x[-1].a^[-1].a := q[1].y; 
    99     1047 q[1].x[1].a^[-1].b := q[-1].z; 
   100     1073 p[-1].x[1].a^[0].a := q[1].y; 
   101     1097 q[1].y^[0].b := q[-1].z; 
   102     1118 q[1].y^[1].a := q[-1].y; 
   103     1138 q[1].y^[1].b := q[1].z; 
   104     1158 p[-1].x[1].b^.x[-1].a := q[-1].y; 
   105     1184 q[-1].x[1].b^.x[-1].b := q[-1].z; 
   106     1211 q[1].x[-1].b^.x[0].a := q[0].y; 
   107     1235 p[1].x[1].b^.x[0].b := q[0].z; 
   108     1259 q[1].z^.x[1].a := q[1].y; 
   109     1278 q[1].z^.x[1].b := q[1].z; 
   110     1298 fail := false; 
   111     1301 caseno := 1; 
   112     1303 checkequal(p[p[-1].x[-1].c[-1]+2].x[-1].a^[-1].c[1], -1 ); 
   113     1349 checkequal(q[-1].x[-1].a^[-1].a^[0].a^[-1].c[0], -1 ); 
   114     1390 checkequal(q[-1].x[-1].a^[0].a^[-1].c[0], -1 ); 
   115     1424 checkequal(q[1].y^[-1].c[0], 0 ); 
   116     1445 checkequal(q[p[-1].x[0].c[0]].x[0].c[1], 100 ); 
   117     1478 checkequal(p[-1].x[1].a^[-1].a^[-1].b^.x[0].c[1], 100 ); 
   118     1517 with p[0].x[0].b^ do 
   119     1530    begin 
   120     1530    checkequal(x[-1].a^[-1].c[0], 0 ); 
   121     1552    checkequal(x[0].c[-1], 99 ); 
   122     1567    checkequal(x[1].c[0], 101 ); 
   123     1581    end; 
   124     1582 checkequal(q[-1].y^[-1].b^.x[-1].b^.x[0].c[-1], 99 ); 
   125     1618 checkequal(q[1].z^.x[-1].b^.x[0].c[-1], 98 ); 
   126     1646 checkequal(q[-1].z^.x[0].c[-1], 98 ); 
   127     1668 checkequal(p[0].x[1].a^[0].b^.x[0].c[1], 102 ); 
   128     1698 checkequal(q[1].x[0].b^.x[0].a^[1].c[-1], 0 ); 
   129     1729 if fail then 
   130     1731    writeln(' FAIL...6.5.3-1') 
   131     1737 else 
   132     1740    writeln(' QUALITY...6.5.3-1') 
   133     1746 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.5.3-1

program complete

Compiling and running t6p5p3p2d3

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.5.3.2-3, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that array indices can be nested 10 deep. } 
     4      -32 {V3.0: New test. } 
     5      -32  
     6      -32 program t6p5p3p2d3(output); 
     7      -32 var 
     8      -32    ok: boolean; 
     9      -32    i : integer; 
    10      -32    c : array [1 .. 3] of integer; 
    11      -32 begin 
    12        3    for i := 1 to 3 do 
    13       15       c[i] := i + 1; 
    14       34    ok := true; 
    15       37    for i := 1 to 3 do 
    16       47 if c[c[c[c[c[c[c[c[c[c[i]-1]-1]-1]-1]-1]-1]-1]-1]-1] 
    17      115               <> i + 1 then 
    18      121          ok := false; 
    19      134    if ok then 
    20      136       writeln(' QUALITY...6.5.3.2-3') 
    21      142    else 
    22      145       writeln(' FAIL...6.5.3.2-3') 
    23      151 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.5.3.2-3

program complete

Compiling and running t6p5p3p2d4

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.5.3.2-4, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that 8-dimensional arrays are permitted. } 
     4      -32 {V3.0: New test. } 
     5      -32  
     6      -32 program t6p5p3p2d4(output); 
     7      -32 var 
     8      -32    v: array [0 .. 1] of array [0 .. 1] of array [0 .. 1] of 
     9      -32       array [0 .. 1] of array [0 .. 1] of array [0 .. 1] of 
    10      -32       array [0 .. 1] of array [0 .. 1] of integer; 
    11      -32 begin 
    12        3    v[0][0][0][0][0][0][0][0] := 0; 
    13       32    v[1, 1, 1, 1, 1, 1, 1, 1] := 1; 
    14       59    if (v[1][1][1][1][1][1][1][1] <> 1) or 
    15       87       (v[0, 0, 0, 0, 0, 0, 0, 0] <> 0) then 
    16      117       writeln(' FAIL...6.5.3.2-4') 
    17      123    else 
    18      126       writeln(' QUALITY...6.5.3.2-4') 
    19      132 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.5.3.2-4

program complete

Compiling and running t6p5p3p2d5

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.5.3.2-5, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that 8-dimensional arrays are permitted. } 
     4      -32 {V3.0: New test. } 
     5      -32  
     6      -32 program t6p5p3p2d5(output); 
     7      -32 type 
     8      -32    t1 = array [0 .. 1] of integer; 
     9      -32    t2 = array [0 .. 1] of t1; 
    10      -32    t3 = array [0 .. 1] of t2; 
    11      -32    t4 = array [0 .. 1] of t3; 
    12      -32    t5 = array [0 .. 1] of t4; 
    13      -32    t6 = array [0 .. 1] of t5; 
    14      -32    t7 = array [0 .. 1] of t6; 
    15      -32    t8 = array [0 .. 1] of t7; 
    16      -32 var 
    17      -32    v: t8; 
    18      -32 begin 
    19        3    v[0][0][0][0][0][0][0][0] := 0; 
    20       32    v[1, 1, 1, 1, 1, 1, 1, 1] := 1; 
    21       59    if (v[1][1][1][1][1][1][1][1] <> 1) or 
    22       87       (v[0, 0, 0, 0, 0, 0, 0, 0] <> 0) then 
    23      117       writeln(' FAIL...6.5.3.2-5') 
    24      123    else 
    25      126       writeln(' QUALITY...6.5.3.2-5') 
    26      132 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.5.3.2-5

program complete

Compiling and running t6p6p1d8

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.6.1-8, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that procedures may be nested to 15 levels. } 
     4      -32 {  The test may detect a small processor limit.  The limit may 
     5      -32    arise due to failure of a register allocation scheme, a limited 
     6      -32    reserved size for a display, or a field set aside for lexical 
     7      -32    level information, or some combination of these. } 
     8      -32 {V3.0: Altered to add better execution test. 
     9      -32    Writes revised - PASS changed to QUALITY, and FAIL 
    10      -32    elaborated. Was previously 6.6.1-7. } 
    11      -32  
    12      -32 program t6p6p1d8(output); 
    13      -32 var 
    14      -32    v0, ans:integer; 
    15      -32  
    16      -32 procedure p1; 
    17      -32 var 
    18      -32    v1: integer; 
    19      -36    procedure p2; 
    20      -32    var 
    21      -32       v2: integer; 
    22      -36       procedure p3; 
    23      -32       var 
    24      -32          v3: integer; 
    25      -36          procedure p4; 
    26      -32          var 
    27      -32             v4: integer; 
    28      -36             procedure p5; 
    29      -32             var 
    30      -32                v5: integer; 
    31      -36                procedure p6; 
    32      -32                var 
    33      -32                   v6: integer; 
    34      -36                   procedure p7; 
    35      -32                   var 
    36      -32                      v7: integer; 
    37      -36                      procedure p8; 
    38      -32                      var 
    39      -32                         v8: integer; 
    40      -36                         procedure p9; 
    41      -32                         var 
    42      -32                            v9: integer; 
    43      -36                            procedure p10; 
    44      -32                            var 
    45      -32                               v10: integer; 
    46      -36                               procedure p11; 
    47      -32                               var 
    48      -32                                  v11: integer; 
    49      -36                                  procedure p12; 
    50      -32                                  var 
    51      -32                                     v12: integer; 
    52      -36                                     procedure p13; 
    53      -32                                     var 
    54      -32                                        v13: integer; 
    55      -36                                        procedure p14; 
    56      -32                                        var 
    57      -32                                           v14: integer; 
    58      -36                                           procedure p15; 
    59      -32                                           begin 
    60        3                                              ans := v14 + v13 
    61        6                                           end; 
    62       10                                        begin 
    63       10                                           v14 := v13 + v12; 
    64       16                                           p15 
    65       16                                        end; 
    66       19                                     begin 
    67       19                                        v13 := v12 + v11; 
    68       25                                        p14 
    69       25                                     end; 
    70       28                                  begin 
    71       28                                     v12 := v11 + v10; 
    72       34                                     p13 
    73       34                                  end; 
    74       37                               begin 
    75       37                                  v11 := v10 + v9; 
    76       43                                  p12 
    77       43                               end; 
    78       46                            begin 
    79       46                               v10 := v9 + v8; 
    80       52                               p11 
    81       52                            end; 
    82       55                         begin 
    83       55                            v9 := v8 + v7; 
    84       61                            p10 
    85       61                         end; 
    86       64                      begin 
    87       64                         v8 := v7 + v6; 
    88       70                         p9 
    89       70                      end; 
    90       73                   begin 
    91       73                      v7 := v6 + v5; 
    92       79                      p8 
    93       79                   end; 
    94       82                begin 
    95       82                   v6 := v5 + v4; 
    96       88                   p7 
    97       88                end; 
    98       91             begin 
    99       91                v5 := v4 + v3; 
   100       97                p6 
   101       97             end; 
   102      100          begin 
   103      100             v4 := v3 + v2; 
   104      106             p5 
   105      106          end; 
   106      109       begin 
   107      109          v3 := v2 + v1; 
   108      115          p4 
   109      115       end; 
   110      118    begin 
   111      118       v2 := v1 + v0; 
   112      124       p3 
   113      124    end; 
   114      127 begin 
   115      127    v1 := v0 + 1; 
   116      133    p2 
   117      133 end; 
   118      136  
   119      136 begin 
   120      136    v0 := 0; 
   121      140    p1; 
   122      142    if ans = 610 then 
   123      146       writeln(' QUALITY...6.6.1-8') 
   124      152    else 
   125      155       writeln(' FAIL...6.6.1-8') 
   126      161 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.6.1-8

program complete

Compiling and running t6p6p3p1d6

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.6.3.1-6, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that 50 formal parameter sections can 
     4      -32    appear in one parameter list. } 
     5      -32 {V3.1: Parameter section extended from 30 to 50. } 
     6      -32  
     7      -32 program t6p6p3p1d6(output); 
     8      -32 var 
     9      -32    sum: integer; 
    10      -32  
    11      -32 procedure p(  i1: integer;  i2: integer; 
    12      -40               i3: integer;  i4: integer; 
    13      -48               i5: integer;  i6: integer; 
    14      -56               i7: integer;  i8: integer; 
    15      -64               i9: integer; i10: integer; 
    16      -72              i11: integer; i12: integer; 
    17      -80              i13: integer; i14: integer; 
    18      -88              i15: integer; i16: integer; 
    19      -96              i17: integer; i18: integer; 
    20     -104              i19: integer; i20: integer; 
    21     -112              i21: integer; i22: integer; 
    22     -120              i23: integer; i24: integer; 
    23     -128              i25: integer; i26: integer; 
    24     -136              i27: integer; i28: integer; 
    25     -144              i29: integer; i30: integer; 
    26     -152              i31: integer; i32: integer; 
    27     -160              i33: integer; i34: integer; 
    28     -168              i35: integer; i36: integer; 
    29     -176              i37: integer; i38: integer; 
    30     -184              i39: integer; i40: integer; 
    31     -192              i41: integer; i42: integer; 
    32     -200              i43: integer; i44: integer; 
    33     -208              i45: integer; i46: integer; 
    34     -216              i47: integer; i48: integer; 
    35     -224              i49: integer; i50: integer); 
    36     -232    begin 
    37        3    sum := i1 + i2 + i3 + i4 + i5 + i6 + i7 + i8 + i9 + i10; 
    38       25    sum := sum 
    39       25        + i11 + i12 + i13 + i14 + i15 + i16 + i17 + i18 + i19 + i20; 
    40       47    sum := sum 
    41       47        + i21 + i22 + i23 + i24 + i25 + i26 + i27 + i28 + i29 + i30; 
    42       69    sum := sum 
    43       69        + i31 + i32 + i33 + i34 + i35 + i36 + i37 + i38 + i39 + i40; 
    44       91    sum := sum 
    45       91        + i41 + i42 + i43 + i44 + i45 + i46 + i47 + i48 + i49 + i50; 
    46      113    end; 
    47      114 begin 
    48      114 sum := 0; 
    49      118 p(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 
    50      129   11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 
    51      139   21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 
    52      149   31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 
    53      159   41, 42, 43, 44, 45, 46, 47, 48, 49, -1200); 
    54      171 if sum = 25 then 
    55      175    writeln(' QUALITY...6.6.3.1-6') 
    56      181 else 
    57      184    writeln(' FAIL...6.6.3.1-6') 
    58      190 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.6.3.1-6

program complete

Compiling and running t6p6p5p3d12

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.6.5.3-12, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program tests that the procedure dispose is implemented 
     4      -32    and is not merely a dummy, or that the store is large enough 
     5      -32    not to need dispose. } 
     6      -32 {V3.1: Comment changed. } 
     7      -32  
     8      -32 program t6p6p5p3d12(output); 
     9      -32 type rec = record 
    10      -32            a: array [0 .. 1023] of integer 
    11      -32            end; 
    12      -32      ptr = ^ rec; 
    13      -32 var 
    14      -32    x: ptr; 
    15      -32    sum, i: integer; 
    16      -32 begin 
    17        3 sum := 0; 
    18        7 for i:= 1 to 1023 do 
    19       17    begin 
    20       17    new(x); 
    21       20    x^.a[0] := 1; 
    22       27    sum := sum + x^.a[0]; 
    23       36    dispose(x) 
    24       39    end; 
    25       49 if sum <> 1023 then 
    26       53    writeln(' FAIL...6.6.5.3-12') 
    27       59 else 
    28       62    writeln(' QUALITY...6.6.5.3-12') 
    29       68 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.6.5.3-12

program complete

Compiling and running t6p6p6p2d10

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.6.6.2-10, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks the implementation of the ln function. } 
     4      -32 {  For FORTRAN version, see 'Software Manual for the Elementary 
     5      -32    Functions', Prentice-Hall 1980, W.J.Cody and W.Waite pp54-59. 
     6      -32    Failure indicates the implementation is worse than that given 
     7      -32    by Cody and Waite, but exceptional argument values could 
     8      -32    produce a large maximum relative error without indicating a 
     9      -32    numerically poor routine. } 
    10      -32 {V3.1: Machar changed and forcestore calls added. } 
    11      -32  
    12      -32 program t6p6p6p2d10(output); 
    13      -32  
    14      -32 var 
    15      -32  
    16      -32  
    17      -32 {     data required 
    18      -32  
    19      -32          none 
    20      -32  
    21      -32       other subprograms in this package 
    22      -32  
    23      -32          machar -  as for 6.6.6.2-6 
    24      -32          random -  as for 6.6.6.2-6 
    25      -32  
    26      -32  
    27      -32       standard subprograms required 
    28      -32  
    29      -32          abs, ln, sqrt 
    30      -32                                                                       } 
    31      -32  
    32      -32    i, ibeta, iexp, irnd, it, i1, j, k1, k2, k3, machep, 
    33      -32       maxexp, minexp, n, negep, ngrd: integer; 
    34      -32    ix: 1 .. 30268;   iy: 1 .. 30306;   iz: 1 .. 30322; 
    35      -32    a, ait, albeta, b, beta, c, d, del, eight, eps, epsneg, half, one, 
    36      -32       ran, r6, r7, tenth, w, x, xl, xmax, xmin, xn, x1, y, z, zero, zz: 
    37      -32       real; 
    38      -32    failed: boolean; 
    39      -32  
    40      -32  
    41      -32 function forcestore(x: real): real; 
    42      -40    { see 'st' in 6.6.6.2-11 for details} 
    43      -40    var 
    44      -40       y: array[1..3] of real; 
    45      -64    begin 
    46        3    y[1] := x; y[2] := 0.0; y[3] := y[1] + y[2]; 
    47       38    y[1] := y[3]; forcestore := y[1] + y[2] 
    48       61    end; 
    49       65  
    50       65 procedure machar (var ibeta, it, irnd, ngrd, machep, negep, iexp, 
    51       65       minexp, maxexp: integer; var eps, epsneg, xmin, xmax: real); 
    52       65    { see 6.6.6.2-11 for details } 
    53       65    var 
    54      -84       i, iz, j, k, mx: integer; 
    55     -104       a, b, beta, betain, betam1, one, y, z, zero: real; 
    56     -176       underflo: boolean; 
    57     -177    function st(x: real): real; 
    58      -40       begin 
    59       65       st := forcestore(x); 
    60       71       end; 
    61       72  
    62       72    begin 
    63       72    one := 1.0; zero := 0.0; a := one + one; 
    64       82    while st(st(st(a + one) - a) - one) = zero do 
    65       98       a := a + a; 
    66      103    b := one + one; 
    67      107    while st(st(a + b) - a) = zero do 
    68      119       b := b + b; 
    69      124    ibeta := trunc (st(a + b) - a); beta := ibeta; 
    70      138    it := 0; b := one; 
    71      143    repeat 
    72      143       begin it := it + 1; b := b * beta end 
    73      153    until st(st(st(b + one) - b) - one) <> zero; 
    74      169    irnd := 0; 
    75      172    betam1 := beta - one; 
    76      176    if st(st((a + beta) + betam1) - (a + beta)) <> zero then 
    77      192       irnd := 1; 
    78      195    negep := it + 3; betain := one / beta; a := one; 
    79      207    for i := 1 to negep do 
    80      218       a := a * betain; 
    81      232    b := a; 
    82      234    while st(st(one - a) - one) = zero do 
    83      246       begin a := a * beta; negep := negep - 1 end; 
    84      257    negep := - negep; epsneg := a; 
    85      265    if (ibeta <> 2) and (irnd <> 0) then 
    86      275       begin 
    87      275       a := a * st(one + a) / (one + one); 
    88      287       if st(st(one - a) - one) <> zero then 
    89      299          epsneg := a; 
    90      302       end; 
    91      302    machep := - it - 3; a := b; 
    92      311    while st(st(one + a) - one) = zero do 
    93      323       begin a := a * beta; machep := machep + 1 end; 
    94      334    eps := a; 
    95      337    if (ibeta <> 2) and (irnd <> 0) then 
    96      347       begin 
    97      347       a := a * st(one + a) / (one + one); 
    98      359       if st(st(one + a) - one) <> zero then 
    99      371          eps := a; 
   100      374       end; 
   101      374    ngrd := 0; 
   102      377    if (irnd = 0) and (st(st(one + eps) * one - one) <> zero) then 
   103      397       ngrd := 1; 
   104      400    i := 0; k := 1; z := betain; underflo := false; 
   105      409    repeat 
   106      409       begin 
   107      409       y := z; z := y * y; a := z * one; 
   108      419       if (st(a + a) = zero) or (abs (z) >= y) then 
   109      432          underflo := true 
   110      432       else 
   111      436          begin i := i + 1; k := k + k end; 
   112      444       end 
   113      444    until underflo; 
   114      446    if ibeta <> 10 then 
   115      451       begin iexp := i + 1; mx := k + k end 
   116      460    else 
   117      461       begin iexp := 2; iz := ibeta; 
   118      467       while k >= iz do 
   119      471          begin iz := iz * ibeta; iexp := iexp + 1 end; 
   120      483       mx := iz + iz - 1; 
   121      489       end; 
   122      489    underflo := false; 
   123      492    repeat 
   124      492       begin 
   125      492       xmin := y; y := y * betain; a := y * one; 
   126      503       if (st(a + a) = zero) or (abs (y) >= xmin) 
   127      515             or (st(y * st(one + eps)) <= y) then 
   128      530          underflo := true 
   129      530       else 
   130      534          k := k + 1; 
   131      538       end 
   132      538    until underflo; 
   133      540    minexp := - k; 
   134      544    if (mx <= k + k - 3) and (ibeta <> 10) then 
   135      557       begin mx := mx + mx; iexp := iexp + 1 end; 
   136      567    maxexp := mx + minexp; i := maxexp + minexp; 
   137      579    if ibeta = 2 then 
   138      584       if (iexp = 8) and (it = 24) and (i = 4) then 
   139      598          maxexp := maxexp - 2 
   140      601       else if (iexp = 11) and (it = 53) and (i = 4) then 
   141      619          maxexp := maxexp - 2 
   142      622       else if i = 0 then 
   143      630          maxexp := maxexp - 1; 
   144      636    if i > 20 then 
   145      640       maxexp := maxexp - 1; 
   146      646    if a <> y then 
   147      650       maxexp := maxexp - 2; 
   148      656    xmax := one - epsneg; 
   149      662    if st(xmax * one) <> xmax then 
   150      672       xmax := one - st(beta * epsneg); 
   151      682    xmax := xmax / (beta * beta * beta * xmin); 
   152      695    i := maxexp + minexp + 3; 
   153      703    for j := 1 to i do 
   154      713       if ibeta = 2 then 
   155      718          xmax := xmax + xmax 
   156      721       else 
   157      726          xmax := xmax * beta; 
   158      742    end; 
   159      743  
   160      743  
   161      743  
   162      743  
   163      743  
   164      743 function random: real; 
   165      743  
   166      743  
   167      743    { For details, see test 6.6.6.2-6   } 
   168      743  
   169      743    var 
   170      -32       ni, k, r: integer; 
   171      -44       x: real; 
   172      -52    begin 
   173      743    k := ix div 177; 
   174      749    r := ix - k * 177; 
   175      755    ni := - k - k + 171 * r; 
   176      764    if ni < 0 then 
   177      768       ix := ni + 30269 
   178      769    else 
   179      774       ix := ni; 
   180      777    k := iy div 176; 
   181      781    r := iy - k * 176; 
   182      787    ni := - 35 * k + r * 172; 
   183      796    if ni < 0 then 
   184      800       iy := ni + 30307 
   185      801    else 
   186      806       iy := ni; 
   187      809    k := iz div 178; 
   188      813    r := iz - k * 178; 
   189      819    ni := - 63 * k + r * 170; 
   190      828    if ni < 0 then 
   191      832       iz := ni + 30323 
   192      833    else 
   193      838       iz := ni; 
   194      841    x := ix/30269.0 + iy/30307.0 + iz/30323.0; 
   195      856    random := x - trunc(x) 
   196      859    end  {random} ; 
   197      863  
   198      863  
   199      863 procedure printtestrun (n: integer; lb, ub: real; 
   200      863                         big, equal, small: integer; 
   201      863                         rdigits, radix: integer; 
   202      863                         maxerror, xmaxerror, rmserror: real); 
   203      863 var 
   204      -96    loss: real;  { Limit for loss in accuracy, see test 6.6.6.2-6 } 
   205     -104 begin 
   206      863    loss := 4.0 * (1.0 + ln(4.0)/albeta) / 3.0; 
   207      876    writeln('      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL') 
   208      882       ; 
   209      884    writeln('   (',lb,',',ub,')'); 
   210      904    writeln; 
   211      907    writeln('  THE RESULT WAS TOO LARGE',big:5,' TIMES, AND'); 
   212      922    writeln('   EQUAL', equal:5, ' TIMES' ); 
   213      937    writeln('   TOO SMALL',small:5,' TIMES'); 
   214      952    writeln; 
   215      955    writeln('  THERE ARE', it:4, ' BASE', ibeta:4, 
   216      971       ' SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER' ); 
   217      977    if maxerror <> zero then 
   218      981       w := ln(abs(maxerror))/albeta 
   219      984    else 
   220      988       w := -999.0; 
   221      991    writeln('  THE MAXIMUM RELATIVE ERROR OF',maxerror,'=', 
   222     1003          ibeta:4,' ** ',w:7:2); 
   223     1016    writeln('   OCCURRED FOR X =',xmaxerror); 
   224     1027    if w + ait < zero then 
   225     1033       w := zero 
   226     1033    else 
   227     1036       w := w + ait; 
   228     1040    writeln('   ESTIMATED LOSS OF BASE', ibeta:4, 
   229     1049       ' SIGNIFICANT DIGITS IS', w:7:2); 
   230     1059    if w > loss then 
   231     1063       failed := true; 
   232     1066    if rmserror <> zero then 
   233     1070       w := ln(abs(rmserror))/albeta 
   234     1073    else 
   235     1077       w := -999.0; 
   236     1080    writeln('  ROOT-MEAN-SQUARE RELATIVE ERROR =',rmserror, 
   237     1089          '=',ibeta:4,' ** ',w:7:2); 
   238     1105    if w + ait < zero then 
   239     1111       w := zero 
   240     1111    else 
   241     1114       w := w + ait; 
   242     1118    writeln('   ESTIMATED LOSS OF BASE', ibeta:4, 
   243     1127       ' SIGNIFICANT DIGITS IS', w:7:2); 
   244     1137    if w > 0.5 * loss then 
   245     1143       failed := true; 
   246     1146    writeln 
   247     1146 end; 
radix      unreferenced
rdigits    unreferenced
n          unreferenced
 { printtestrun } 
   248     1150  
   249     1150  
   250     1150 function sign(a1, a2 : real) : real; 
   251     1150 begin 
   252     1150   if - a2 < 0 then 
   253     1158     sign := -abs(a1) 
   254     1160   else 
   255     1163     sign := abs(a1) 
   256     1165 end; 
   257     1167  
   258     1167  
   259     1167 begin  {Main program} 
   260     1167    iz := 1; 
   261     1172    iy := 10001; 
   262     1175    ix := 4987; 
   263     1178    machar ( ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, 
   264     1187      maxexp, eps, epsneg, xmin, xmax ); 
   265     1193    failed := false; 
   266     1196    beta := ibeta; 
   267     1199    albeta := ln(beta); 
   268     1202    ait := it; 
   269     1205    j := it div 3; 
   270     1209    zero := 0.0; 
   271     1211    half := 1/2; 
   272     1217    eight := 8.0; 
   273     1219    tenth := 0.1; 
   274     1221    one := 1.0; 
   275     1223    c := one; 
   276     1225  
   277     1225    for i := 1 to j do 
   278     1235       c := c / beta; 
   279     1249  
   280     1249    b := one + c; 
   281     1253    a := one - c; 
   282     1257    n := 2000; 
   283     1259    xn := n; 
   284     1262    i1 := 0; 
   285     1264  
   286     1264    {   random argument accuracy tests   } 
   287     1264  
   288     1264    for j := 1 to 4 do 
   289     1274       begin 
   290     1274       k1 := 0; 
   291     1276       k3 := 0; 
   292     1278       x1 := zero; 
   293     1280       r6 := zero; 
   294     1282       r7 := zero; 
   295     1284       del := (b - a) / xn; 
   296     1290       xl := a; 
   297     1292  
   298     1292       for i := 1 to n do 
   299     1302          begin 
   300     1302          x := del * random + xl; 
   301     1309          case j of 
   302     1311          1: 
   303     1311             begin 
   304     1311                y := forcestore(x - half) - half; 
   305     1319                zz := ln(x); 
   306     1322                z := one / 3.0; 
   307     1326                z := y * (z - y / 4.0); 
   308     1334                z := (z - half) * y * y + y 
   309     1341             end; 
   310     1345          2: 
   311     1345             begin 
   312     1345                x := forcestore(x + eight) - eight; 
   313     1353                y := x + x / 16.0; 
   314     1359                z := ln(x); 
   315     1362                zz := ln(y) - 7.7746816434842581E-5; 
   316     1367                zz := zz - 31.0 / 512.0 
   317     1369             end; 
   318     1374          3: 
   319     1374             begin 
   320     1374                x := forcestore(x + eight) - eight; 
   321     1382                y := x + x * tenth; 
   322     1388                z := ln(x) / ln(10.0); 
   323     1394                zz := ln(y) / ln(10.0) - 3.7706015822504075E-4; 
   324     1402                zz := zz - 21.0 / 512.0 
   325     1404             end; 
   326     1409          4: 
   327     1409             begin 
   328     1409                z := ln(x * x); 
   329     1414                zz := ln(x); 
   330     1417                zz := zz + zz 
   331     1418             end 
   332     1421          end; 
   333     1430          w := one; 
   334     1432          if z <> zero then 
   335     1436            w := (z - zz) / z; 
   336     1442          z := sign(w, z); 
   337     1447          if z > zero then 
   338     1451             k1 := k1 + 1; 
   339     1455          if z < zero then 
   340     1459             k3 := k3 + 1; 
   341     1463          w := abs(w); 
   342     1466          if w > r6 then 
   343     1470             begin 
   344     1470             r6 := w; 
   345     1472             x1 := x 
   346     1472             end; 
   347     1474          r7 := r7 + w * w; 
   348     1480          xl := xl + del 
   349     1481          end; 
   350     1494  
   351     1494       k2 := n - k3 - k1; 
   352     1500       r7 := sqrt(r7 / xn); 
   353     1505       case j of 
   354     1507       1: 
   355     1507          writeln(' TEST OF LN(X) VS TAYLOR SERIES EXPANSION', 
   356     1513             ' OF LN(1+Y)'); 
   357     1520       2: 
   358     1520          writeln(' TEST OF LN(X) VS LN(17X/16)-LN(17/16)'); 
   359     1529       3: 
   360     1529          writeln(' TEST OF LN(X) VS LN(11X/10)-LN(11/10)'); 
   361     1538       4: 
   362     1538          writeln(' TEST OF LN(X*X) VS 2 * LN(X)') 
   363     1544       end; 
   364     1555       writeln; 
   365     1558       printtestrun(n, a, b, k1, k2, k3, it, ibeta, r6, x1, r7); 
   366     1571       case j of 
   367     1573          1: begin 
   368     1573             a := sqrt(half); 
   369     1576             b := 15.0 / 16.0 
   370     1577             end; 
   371     1581          2: begin 
   372     1581             a := sqrt(tenth); 
   373     1584             b := 0.9 
   374     1584             end; 
   375     1587          3,4: 
   376     1587             begin 
   377     1587             a := 16.0; 
   378     1589             b := 240.0 
   379     1589             end 
   380     1591          end 
   381     1600       end; 
   382     1610  
   383     1610    {   special tests   } 
   384     1610  
   385     1610    writeln(' THE IDENTITY LN(X) = - LN(1/X) WILL BE TESTED'); 
   386     1618    writeln; 
   387     1621    writeln('        X         F(X) + F(1/X)'); 
   388     1629    writeln; 
   389     1632  
   390     1632    for i := 1 to 5 do 
   391     1642       begin 
   392     1642       x := random; 
   393     1645       x := x + x + 15.0; 
   394     1651       y := one / x; 
   395     1655       z := ln(x) + ln(y); 
   396     1661       writeln(' ',x,z) 
   397     1672       end; 
   398     1684  
   399     1684    writeln; 
   400     1687    writeln(' TEST OF SPECIAL ARGUMENTS'); 
   401     1695    writeln; 
   402     1698    x := one; 
   403     1700    y := ln(x); 
   404     1703    writeln(' LN(1.0) = ', y); 
   405     1714    writeln; 
   406     1717    x := xmin; 
   407     1719    y := ln(x); 
   408     1722    writeln(' LN(XMIN) = LN(', x, ') = ', y); 
   409     1740    writeln; 
   410     1743    x := xmax; 
   411     1745    y := ln(x); 
   412     1748    writeln(' LN(XMAX) = LN(', x, ') = ', y); 
   413     1766    writeln; 
   414     1769  
   415     1769    {   Test 6.6.6.2-4 checks that an error is produced 
   416     1769       when  ln is called with a negative argument.   } 
   417     1769  
   418     1769    if failed then 
   419     1771       writeln(' FAIL...6.6.6.2-10') 
   420     1777    else 
   421     1780       writeln(' QUALITY...6.6.6.2-10') 
   422     1786 end. 
d          unreferenced
ran        unreferenced


Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 TEST OF LN(X) VS TAYLOR SERIES EXPANSION OF LN(1+Y)

      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL
   ( 9.999923706054688e-01, 1.000007629394531e+00)

  THE RESULT WAS TOO LARGE    0 TIMES, AND
   EQUAL 2000 TIMES
   TOO SMALL    0 TIMES

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 0.000000000000000e+00=   2 ** -999.00
   OCCURRED FOR X = 0.000000000000000e+00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00
  ROOT-MEAN-SQUARE RELATIVE ERROR = 0.000000000000000e+00=   2 ** -999.00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 TEST OF LN(X) VS LN(17X/16)-LN(17/16)

      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL
   ( 7.071067811865476e-01, 9.375000000000000e-01)

  THE RESULT WAS TOO LARGE  529 TIMES, AND
   EQUAL 1471 TIMES
   TOO SMALL    0 TIMES

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 2.220432140694462e-16=   2 **  -52.00
   OCCURRED FOR X = 7.787995634905958e-01
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   1.00
  ROOT-MEAN-SQUARE RELATIVE ERROR = 8.346054263785336e-17=   2 **  -53.41
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 TEST OF LN(X) VS LN(11X/10)-LN(11/10)

      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL
   ( 3.162277660168379e-01, 9.000000000000000e-01)

  THE RESULT WAS TOO LARGE 1163 TIMES, AND
   EQUAL  837 TIMES
   TOO SMALL    0 TIMES

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 6.042715851110278e-16=   2 **  -50.56
   OCCURRED FOR X = 8.532996551919485e-01
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   2.44
  ROOT-MEAN-SQUARE RELATIVE ERROR = 1.623053434370160e-16=   2 **  -52.45
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.55

 TEST OF LN(X*X) VS 2 * LN(X)

      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL
   ( 1.600000000000000e+01, 2.400000000000000e+02)

  THE RESULT WAS TOO LARGE    0 TIMES, AND
   EQUAL 1951 TIMES
   TOO SMALL   49 TIMES

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 2.210607717124350e-16=   2 **  -52.01
   OCCURRED FOR X = 5.557881151021112e+01
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.99
  ROOT-MEAN-SQUARE RELATIVE ERROR = 2.572207330816903e-17=   2 **  -55.11
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 THE IDENTITY LN(X) = - LN(1/X) WILL BE TESTED

        X         F(X) + F(1/X)

  1.551903302512485e+01-4.440892098500626e-16
  1.546353046039002e+01 0.000000000000000e+00
  1.533186951253343e+01-4.440892098500626e-16
  1.531695886404519e+01 0.000000000000000e+00
  1.618568731540587e+01 0.000000000000000e+00

 TEST OF SPECIAL ARGUMENTS

 LN(1.0) =  0.000000000000000e+00

 LN(XMIN) = LN( 5.56268464626800e-309) = -7.097827128933840e+02

 LN(XMAX) = LN( 8.98846567431158e+307) =  7.090895657128241e+02

 QUALITY...6.6.6.2-10

program complete

Compiling and running t6p6p6p2d6

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.6.6.2-6, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks the implementation of the sqrt function. } 
     4      -32 {  For FORTRAN version, see 'Software Manual for the Elementary 
     5      -32    Functions', Prentice-Hall 1980, W.J.Cody and W.Waite pp31-34. 
     6      -32    Failure indicates the implementation is worse than that given 
     7      -32    by Cody and Waite, but exceptional argument values could 
     8      -32    produce a large maximum relative error without indicating a 
     9      -32    numerically poor routine. } 
    10      -32 {V3.1: Machar changed and forcestore added. } 
    11      -32  
    12      -32 program t6p6p6p2d6(output); 
    13      -32  
    14      -32 var 
    15      -32  
    16      -32 {      data required 
    17      -32  
    18      -32           none 
    19      -32  
    20      -32        other subprograms in this package 
    21      -32  
    22      -32           machar - An environmental inquiry program providing 
    23      -32                    information on the floating-point arithmetic 
    24      -32                    system.  Note that the call to machar can 
    25      -32                    be deleted provided the following six 
    26      -32                    parameters are assigned the values indicated: 
    27      -32  
    28      -32                    ibeta    -  The radix of the floating-point 
    29      -32                                representation 
    30      -32                    it       -  The number of base ibeta digits in the 
    31      -32                                floating-point significand 
    32      -32                    eps      -  The smallest positive floating-point 
    33      -32                                number such that 1.0+eps <> 1.0 . In 
    34      -32                                particular, if either ibeta=2 or irnd=0, 
    35      -32                                eps = ibeta ** machep, otherwise, 
    36      -32                                eps = (ibeta  **  machep)/2 
    37      -32                    epsneg   -  A small positive floating-point number 
    38      -32                                such that 1.0-epsneg <> 1.0 . In 
    39      -32                                particular, if ibeta=2 or irnd=0, 
    40      -32                                epsneg = ibeta ** negeps, 
    41      -32                                otherwise, epsneg = (ibeta ** negeps)/2 . 
    42      -32                                Because negeps is bounded below 
    43      -32                                by -(it+3), epsneg may not be the 
    44      -32                                smallest number which can alter 
    45      -32                                1.0 by subtraction. 
    46      -32                    xmin     -  The smallest non-vanishing floating-point 
    47      -32                                power of the radix. In particular, 
    48      -32                                xmin = ibeta ** minexp . 
    49      -32                    xmax     -  The largest finite floating-point number. 
    50      -32                                In particular, 
    51      -32                                xmax = (1.0-epsneg)*ibeta ** maxexp . 
    52      -32                                Note - on some machines, xmax will 
    53      -32                                be only the second, or perhaps third, 
    54      -32                                largest number, being too small by 
    55      -32                                1 or 2 units in the last digit of 
    56      -32                                the significand. 
    57      -32  
    58      -32         randl(x) - A function subprogram returning logarithmically 
    59      -32                    distributed random real numbers.  In particular, 
    60      -32                           a * randl(ln(b/a)) 
    61      -32                    is logarithmically distributed over (a,b) 
    62      -32  
    63      -32           random - A function subprogram returning random real 
    64      -32                    numbers uniformly distributed over (0,1) 
    65      -32  
    66      -32  
    67      -32        standard subprograms required 
    68      -32  
    69      -32            abs, ln, exp, sqrt 
    70      -32                                                                       } 
    71      -32  
    72      -32    i, ibeta, iexp,  irnd, it, j, k1, k2, k3, machep, maxexp, 
    73      -32    minexp, n, negep, ngrd : integer; 
    74      -32    ix: 1 .. 30268;   iy: 1 .. 30306;   iz: 1 .. 30322; 
    75      -32    { Seeds for the function random which must be initialised. 
    76      -32      They must be > 0 and less than 30269, 30307 and 30323 
    77      -32      respectively. They should not be equal. } 
    78      -32    a, ait, albeta, b, beta, c, eps, epsneg, one, r6, r7, sqbeta, w, 
    79      -32    x, xmax, xmin, xn, x1, y, z, zero: real; 
    80      -32    failed: boolean; 
    81      -32  
    82      -32 function forcestore(x: real): real; 
    83      -40    { see 'st' in 6.6.6.2-11 for details} 
    84      -40    var 
    85      -40       y: array[1..3] of real; 
    86      -64    begin 
    87        3    y[1] := x; y[2] := 0.0; y[3] := y[1] + y[2]; 
    88       38    y[1] := y[3]; forcestore := y[1] + y[2] 
    89       61    end; 
    90       65  
    91       65 procedure machar (var ibeta, it, irnd, ngrd, machep, negep, iexp, 
    92       65       minexp, maxexp: integer; var eps, epsneg, xmin, xmax: real); 
    93       65    { see 6.6.6.2-11 for details } 
    94       65    var 
    95      -84       i, iz, j, k, mx: integer; 
    96     -104       a, b, beta, betain, betam1, one, y, z, zero: real; 
    97     -176       underflo: boolean; 
    98     -177    function st(x: real): real; 
    99      -40       begin 
   100       65       st := forcestore(x); 
   101       71       end; 
   102       72  
   103       72    begin 
   104       72    one := 1.0; zero := 0.0; a := one + one; 
   105       82    while st(st(st(a + one) - a) - one) = zero do 
   106       98       a := a + a; 
   107      103    b := one + one; 
   108      107    while st(st(a + b) - a) = zero do 
   109      119       b := b + b; 
   110      124    ibeta := trunc (st(a + b) - a); beta := ibeta; 
   111      138    it := 0; b := one; 
   112      143    repeat 
   113      143       begin it := it + 1; b := b * beta end 
   114      153    until st(st(st(b + one) - b) - one) <> zero; 
   115      169    irnd := 0; 
   116      172    betam1 := beta - one; 
   117      176    if st(st((a + beta) + betam1) - (a + beta)) <> zero then 
   118      192       irnd := 1; 
   119      195    negep := it + 3; betain := one / beta; a := one; 
   120      207    for i := 1 to negep do 
   121      218       a := a * betain; 
   122      232    b := a; 
   123      234    while st(st(one - a) - one) = zero do 
   124      246       begin a := a * beta; negep := negep - 1 end; 
   125      257    negep := - negep; epsneg := a; 
   126      265    if (ibeta <> 2) and (irnd <> 0) then 
   127      275       begin 
   128      275       a := a * st(one + a) / (one + one); 
   129      287       if st(st(one - a) - one) <> zero then 
   130      299          epsneg := a; 
   131      302       end; 
   132      302    machep := - it - 3; a := b; 
   133      311    while st(st(one + a) - one) = zero do 
   134      323       begin a := a * beta; machep := machep + 1 end; 
   135      334    eps := a; 
   136      337    if (ibeta <> 2) and (irnd <> 0) then 
   137      347       begin 
   138      347       a := a * st(one + a) / (one + one); 
   139      359       if st(st(one + a) - one) <> zero then 
   140      371          eps := a; 
   141      374       end; 
   142      374    ngrd := 0; 
   143      377    if (irnd = 0) and (st(st(one + eps) * one - one) <> zero) then 
   144      397       ngrd := 1; 
   145      400    i := 0; k := 1; z := betain; underflo := false; 
   146      409    repeat 
   147      409       begin 
   148      409       y := z; z := y * y; a := z * one; 
   149      419       if (st(a + a) = zero) or (abs (z) >= y) then 
   150      432          underflo := true 
   151      432       else 
   152      436          begin i := i + 1; k := k + k end; 
   153      444       end 
   154      444    until underflo; 
   155      446    if ibeta <> 10 then 
   156      451       begin iexp := i + 1; mx := k + k end 
   157      460    else 
   158      461       begin iexp := 2; iz := ibeta; 
   159      467       while k >= iz do 
   160      471          begin iz := iz * ibeta; iexp := iexp + 1 end; 
   161      483       mx := iz + iz - 1; 
   162      489       end; 
   163      489    underflo := false; 
   164      492    repeat 
   165      492       begin 
   166      492       xmin := y; y := y * betain; a := y * one; 
   167      503       if (st(a + a) = zero) or (abs (y) >= xmin) 
   168      515             or (st(y * st(one + eps)) <= y) then 
   169      530          underflo := true 
   170      530       else 
   171      534          k := k + 1; 
   172      538       end 
   173      538    until underflo; 
   174      540    minexp := - k; 
   175      544    if (mx <= k + k - 3) and (ibeta <> 10) then 
   176      557       begin mx := mx + mx; iexp := iexp + 1 end; 
   177      567    maxexp := mx + minexp; i := maxexp + minexp; 
   178      579    if ibeta = 2 then 
   179      584       if (iexp = 8) and (it = 24) and (i = 4) then 
   180      598          maxexp := maxexp - 2 
   181      601       else if (iexp = 11) and (it = 53) and (i = 4) then 
   182      619          maxexp := maxexp - 2 
   183      622       else if i = 0 then 
   184      630          maxexp := maxexp - 1; 
   185      636    if i > 20 then 
   186      640       maxexp := maxexp - 1; 
   187      646    if a <> y then 
   188      650       maxexp := maxexp - 2; 
   189      656    xmax := one - epsneg; 
   190      662    if st(xmax * one) <> xmax then 
   191      672       xmax := one - st(beta * epsneg); 
   192      682    xmax := xmax / (beta * beta * beta * xmin); 
   193      695    i := maxexp + minexp + 3; 
   194      703    for j := 1 to i do 
   195      713       if ibeta = 2 then 
   196      718          xmax := xmax + xmax 
   197      721       else 
   198      726          xmax := xmax * beta; 
   199      742    end; 
   200      743  
   201      743  
   202      743  
   203      743  
   204      743  
   205      743  
   206      743 function random: real; 
   207      743  
   208      743    { I D Hill and B A Wichmann, Applied Statistics, 
   209      743      Vol 31, 1982, pp 188-190. } 
   210      743  
   211      743    { The tests using random are: 6.4.3.5-5, 6.4.3.5-8, 6.6.6.2-6, 
   212      743      6.6.6.2-7, 6.6.6.2-8, 6.6.6.2-9 and 6.6.6.2-10. } 
   213      743  
   214      743    { This function uses three multiplicative congruence 
   215      743      generators to provide approximately 48-bit random 
   216      743      sequences from three 16-bit integer ones. The three 
   217      743      sequences are: 
   218      743            ix := (ix * 171) mod 30269 
   219      743            iy := (iy * 172) mod 30307 
   220      743      and   iz := (iz * 170) mod 30323 
   221      743      Since 30269, 30307 and 30323 are primes, all sequences can be 
   222      743      of maximal length (see Seminumerical Algorithms, D E Knuth, 
   223      743      Addison Wesley 1969, p19). The simple steps above cannot 
   224      743      be performed without overflow on a 16-bit machine. This 
   225      743      is avoided by writing: 
   226      743            iy = k * 176 + r 
   227      743      where    0 <= k <= 172 
   228      743      and      0 <= r <= 175 
   229      743      Then     172 * iy = k * 176 * 172 + r * 172 
   230      743                        = k * 30272 + r * 172 
   231      743                        = - k * 35 + r * 172 mod 30307 
   232      743      Similarly 
   233      743      with     iz = k * 178 + r 
   234      743               170 * iz = - k * 63 + r * 170 mod 30323. 
   235      743      and with ix = k * 177 + r 
   236      743               171 * ix = - k * 2 + r * 171 mod 30269 
   237      743      The values are now bounded for a 16-bit machine. 
   238      743      The period is about 2.78E13. 
   239      743      The fractional part of the sum of the three values as a 
   240      743      fraction of the prime modulus gives the real random value. } 
   241      743  
   242      743    var 
   243      -32       ni, k, r: integer; 
   244      -44       x: real; 
   245      -52    begin 
   246      743    { calculate k and r for ix } 
   247      743    k := ix div 177; 
   248      749    r := ix - k * 177; 
   249      755    ni := - k - k + 171 * r; 
   250      764    { -342 <= ni <= 30096, so now reduce range } 
   251      764    if ni < 0 then 
   252      768       ix := ni + 30269 
   253      769    else 
   254      774       ix := ni; 
   255      777    { k and r for iy generator } 
   256      777    k := iy div 176; 
   257      781    r := iy - k * 176; 
   258      787    ni := - 35 * k + r * 172; 
   259      796    { reduce range, -6020 <= ni <= 30100 } 
   260      796    if ni < 0 then 
   261      800       iy := ni + 30307 
   262      801    else 
   263      806       iy := ni; 
   264      809    { now the same for iz } 
   265      809    k := iz div 178; 
   266      813    r := iz - k * 178; 
   267      819    ni := - 63 * k + r * 170; 
   268      828    { reduce range, -10710 <= ni <= 30090 } 
   269      828    if ni < 0 then 
   270      832       iz := ni + 30323 
   271      833    else 
   272      838       iz := ni; 
   273      841    x := ix/30269.0 + iy/30307.0 + iz/30323.0; 
   274      856    random := x - trunc(x) 
   275      859    end  {random} ; 
   276      863  
   277      863  
   278      863 function randl (x: real ): real; 
   279      863  
   280      863 {     returns pseudo random numbers logarithmically distributed 
   281      863       over (1,exp(x)).  thus a*randl(ln(b/a)) is logarithmically 
   282      863       distributed in (a,b). 
   283      863  
   284      863       other subroutines required 
   285      863  
   286      863          exp(x) - the exponential routine 
   287      863  
   288      863          random - a function program returning random real 
   289      863                   numbers uniformly distributed over (0,1). 
   290      863                                                                   } 
   291      863  
   292      863  
   293      863 begin 
   294      863    randl := exp ( x * random ) 
   295      869 end; 
   296      872  
   297      872  
   298      872 procedure printtestrun (n: integer; lb, ub: real; 
   299      872                         big, equal, small: integer; 
   300      872                         rdigits, radix: integer; 
   301      872                         maxerror, xmaxerror, rmserror: real); 
   302      872 var 
   303      -96    loss: real;  { Limit for loss in accuracy } 
   304     -104 begin 
   305      872    { The limit for loss in accuracy corresponds to 4/3(BASE 
   306      872      digit plus 2 bits) for the Maximum Relative Error and to 
   307      872      half this for the Root Mean Square error. Such limits are 
   308      872      only exceeded by routines which are believed to contain 
   309      872      numerically poor algorithms except for isolated argument 
   310      872      values. 
   311      872      Hence MRE <= 4, RMS <= 2 for a binary machine 
   312      872        and MRE <= 2, RMS <= 1 for a hexadecimal machine. 
   313      872      This is an NPL addition to the Cody and Waite tests. } 
   314      872    loss := 4.0 * (1.0 + ln(4.0)/albeta)/3.0; 
   315      885    writeln('      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL') 
   316      891       ; 
   317      893    writeln('   (',lb,',',ub,')'); 
   318      913    writeln; 
   319      916    writeln('  THE RESULT WAS TOO LARGE',big:5,' TIMES, AND'); 
   320      931    writeln('   EQUAL', equal:5, ' TIMES' ); 
   321      946    writeln('   TOO SMALL',small:5,' TIMES'); 
   322      961    writeln; 
   323      964    writeln('  THERE ARE', it:4, ' BASE', ibeta:4, 
   324      980       ' SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER' ); 
   325      986    if maxerror <> zero then 
   326      990       w := ln(abs(maxerror))/albeta 
   327      993    else 
   328      997       w := -999.0; 
   329     1000    writeln('  THE MAXIMUM RELATIVE ERROR OF',maxerror,'=', 
   330     1012          ibeta:4,' ** ',w:7:2); 
   331     1025    writeln('   OCCURRED FOR X =',xmaxerror); 
   332     1036    if w + ait < zero then 
   333     1042       w := zero 
   334     1042    else 
   335     1045       w := w + ait; 
   336     1049    writeln('   ESTIMATED LOSS OF BASE', ibeta:4, 
   337     1058       ' SIGNIFICANT DIGITS IS', w:7:2); 
   338     1068    if w > loss then 
   339     1072       failed := true; 
   340     1075    if rmserror <> zero then 
   341     1079       w := ln(abs(rmserror))/albeta 
   342     1082    else 
   343     1086       w := -999.0; 
   344     1089    writeln('  ROOT-MEAN-SQUARE RELATIVE ERROR =',rmserror, 
   345     1098          '=',ibeta:4,' ** ',w:7:2); 
   346     1114    if w + ait < zero then 
   347     1120       w := zero 
   348     1120    else 
   349     1123       w := w + ait; 
   350     1127    writeln('   ESTIMATED LOSS OF BASE', ibeta:4, 
   351     1136       ' SIGNIFICANT DIGITS IS', w:7:2); 
   352     1146    if w > 0.5 * loss then 
   353     1152       failed := true; 
   354     1155    writeln 
   355     1155 end; 
radix      unreferenced
rdigits    unreferenced
n          unreferenced
  { printtestrun } 
   356     1159  
   357     1159 begin  {Main program} 
   358     1159  
   359     1159    machar ( ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, 
   360     1170       maxexp, eps, epsneg, xmin, xmax ); 
   361     1176    failed := false; 
   362     1179    beta := ibeta; 
   363     1182    sqbeta := sqrt(beta); 
   364     1185    albeta := ln(beta); 
   365     1188    ait := it; 
   366     1191    one := 1.0; 
   367     1193    zero := 0.0; 
   368     1195    a := one / sqbeta; 
   369     1199    b := one; 
   370     1201    n := 2000; 
   371     1203    xn := n; 
   372     1206    iz := 1; 
   373     1209    iy := 10001; 
   374     1212    ix := 4987; 
   375     1215  
   376     1215    {   random argument accuracy tests   } 
   377     1215  
   378     1215    for j := 1 to 2 do 
   379     1225       begin 
   380     1225       c := ln(b / a); 
   381     1230       k1 := 0; 
   382     1232       k3 := 0; 
   383     1234       x1 := zero; 
   384     1236       r6 := zero; 
   385     1238       r7 := zero; 
   386     1240  
   387     1240       for i := 1 to n do 
   388     1250          begin 
   389     1250          x := a * randl(c); 
   390     1256          y := forcestore( x * x); 
   391     1262          z := sqrt(y); 
   392     1265          w := (z - x) / x; 
   393     1271          if w > zero then 
   394     1275             k1 := k1 + 1; 
   395     1279          if w < zero then 
   396     1283             k3 := k3 + 1; 
   397     1287          w := abs(w); 
   398     1290          if w > r6 then 
   399     1294             begin 
   400     1294             r6 := w; 
   401     1296             x1 := x 
   402     1296             end; 
   403     1298          r7 := r7 + w * w 
   404     1300          end; 
   405     1314  
   406     1314       k2 := n - k1 - k3; 
   407     1320       r7 := sqrt(r7 / xn); 
   408     1325       writeln(' TEST OF SQRT(X*X) - X'); 
   409     1333       writeln; 
   410     1336       printtestrun(n, a, b, k1, k2, k3, it, ibeta, r6, x1, r7); 
   411     1349       a := one; 
   412     1351       b := sqbeta 
   413     1351       end; 
   414     1363  
   415     1363   {   special tests   } 
   416     1363  
   417     1363    writeln(' TEST OF SPECIAL ARGUMENTS'); 
   418     1371    writeln('   VALUE    X=', ' ':15, 'SQRT(X)=' ); 
   419     1386    writeln('   XMIN   ', xmin, sqrt(xmin)); 
   420     1401    writeln('  1-EPSNEG', one-epsneg, sqrt(one-epsneg)); 
   421     1420    writeln('   1.0    ', one, sqrt(one)); 
   422     1435    writeln('  1+EPS   ', one + eps, sqrt(one + eps)); 
   423     1454    writeln('   XMAX   ', xmax, sqrt(xmax)); 
   424     1469    writeln('   0.0    ', zero, sqrt(zero)); 
   425     1484    writeln; 
   426     1487  
   427     1487    {   No tests for error conditions are made here. 
   428     1487       Test 6.6.6.2-5 calls sqrt with a negative argument.  } 
   429     1487  
   430     1487    if failed then 
   431     1489       writeln(' FAIL...6.6.6.2-6') 
   432     1495    else 
   433     1498       writeln(' QUALITY...6.6.6.2-6') 
   434     1504 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 TEST OF SQRT(X*X) - X

      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL
   ( 7.071067811865475e-01, 1.000000000000000e+00)

  THE RESULT WAS TOO LARGE    0 TIMES, AND
   EQUAL 2000 TIMES
   TOO SMALL    0 TIMES

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 0.000000000000000e+00=   2 ** -999.00
   OCCURRED FOR X = 0.000000000000000e+00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00
  ROOT-MEAN-SQUARE RELATIVE ERROR = 0.000000000000000e+00=   2 ** -999.00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 TEST OF SQRT(X*X) - X

      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL
   ( 1.000000000000000e+00, 1.414213562373095e+00)

  THE RESULT WAS TOO LARGE    0 TIMES, AND
   EQUAL 2000 TIMES
   TOO SMALL    0 TIMES

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 0.000000000000000e+00=   2 ** -999.00
   OCCURRED FOR X = 0.000000000000000e+00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00
  ROOT-MEAN-SQUARE RELATIVE ERROR = 0.000000000000000e+00=   2 ** -999.00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 TEST OF SPECIAL ARGUMENTS
   VALUE    X=               SQRT(X)=
   XMIN    5.56268464626800e-309 7.45834073120021e-155
  1-EPSNEG 9.999999999999999e-01 1.000000000000000e+00
   1.0     1.000000000000000e+00 1.000000000000000e+00
  1+EPS    1.000000000000000e+00 1.000000000000000e+00
   XMAX    8.98846567431158e+307 9.48075190810918e+153
   0.0     0.000000000000000e+00 0.000000000000000e+00

 QUALITY...6.6.6.2-6

program complete

Compiling and running t6p6p6p2d7

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.6.6.2-7, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks the implementation of the arctan function. } 
     4      -32 {  For FORTRAN version, see 'Software Manual for the Elementary 
     5      -32    Functions', Prentice-Hall 1980, W.J.Cody and W.Waite pp211-216. 
     6      -32    Failure indicates the implementation is worse than that given 
     7      -32    by Cody and Waite, but exceptional argument values could 
     8      -32    produce a large maximum relative error without indicating a 
     9      -32    numerically poor routine. } 
    10      -32 {V3.1: Machar changed and forcestore calls added. } 
    11      -32  
    12      -32 program t6p6p6p2d7(output); 
    13      -32  
    14      -32 var 
    15      -32  
    16      -32 {     data required 
    17      -32  
    18      -32          none 
    19      -32  
    20      -32        other subprograms in this package 
    21      -32  
    22      -32          machar - as for 6.6.6.2-6 
    23      -32  
    24      -32        randl(x) - as for 6.6.6.2-6 
    25      -32  
    26      -32          random - as for 6.6.6.2-6 
    27      -32  
    28      -32       standard subprograms required 
    29      -32  
    30      -32           abs, ln, arctan,  sqrt                          } 
    31      -32  
    32      -32    i, ibeta, iexp, irnd, ii, it, i1, j, k1, k2, k3, machep, 
    33      -32    maxexp, minexp, n, negep, ngrd: integer; 
    34      -32    ix: 1 .. 30268;   iy: 1 .. 30306;   iz: 1 .. 30322; 
    35      -32    a, ait, albeta, b, beta, betap, del, em, eps, epsneg, expon, 
    36      -32    half, ob32, one, ran, r6, r7, sum, two, w, x, xl, xmax, xmin, 
    37      -32    xn, xsq, x1, y, z, zero, zz: real; 
    38      -32    failed: boolean; 
    39      -32  
    40      -32  
    41      -32 function forcestore(x: real): real; 
    42      -40    { see 'st' in 6.6.6.2-11 for details} 
    43      -40    var 
    44      -40       y: array[1..3] of real; 
    45      -64    begin 
    46        3    y[1] := x; y[2] := 0.0; y[3] := y[1] + y[2]; 
    47       38    y[1] := y[3]; forcestore := y[1] + y[2] 
    48       61    end; 
    49       65  
    50       65 procedure machar (var ibeta, it, irnd, ngrd, machep, negep, iexp, 
    51       65       minexp, maxexp: integer; var eps, epsneg, xmin, xmax: real); 
    52       65    { see 6.6.6.2-11 for details } 
    53       65    var 
    54      -84       i, iz, j, k, mx: integer; 
    55     -104       a, b, beta, betain, betam1, one, y, z, zero: real; 
    56     -176       underflo: boolean; 
    57     -177    function st(x: real): real; 
    58      -40       begin 
    59       65       st := forcestore(x); 
    60       71       end; 
    61       72  
    62       72    begin 
    63       72    one := 1.0; zero := 0.0; a := one + one; 
    64       82    while st(st(st(a + one) - a) - one) = zero do 
    65       98       a := a + a; 
    66      103    b := one + one; 
    67      107    while st(st(a + b) - a) = zero do 
    68      119       b := b + b; 
    69      124    ibeta := trunc (st(a + b) - a); beta := ibeta; 
    70      138    it := 0; b := one; 
    71      143    repeat 
    72      143       begin it := it + 1; b := b * beta end 
    73      153    until st(st(st(b + one) - b) - one) <> zero; 
    74      169    irnd := 0; 
    75      172    betam1 := beta - one; 
    76      176    if st(st((a + beta) + betam1) - (a + beta)) <> zero then 
    77      192       irnd := 1; 
    78      195    negep := it + 3; betain := one / beta; a := one; 
    79      207    for i := 1 to negep do 
    80      218       a := a * betain; 
    81      232    b := a; 
    82      234    while st(st(one - a) - one) = zero do 
    83      246       begin a := a * beta; negep := negep - 1 end; 
    84      257    negep := - negep; epsneg := a; 
    85      265    if (ibeta <> 2) and (irnd <> 0) then 
    86      275       begin 
    87      275       a := a * st(one + a) / (one + one); 
    88      287       if st(st(one - a) - one) <> zero then 
    89      299          epsneg := a; 
    90      302       end; 
    91      302    machep := - it - 3; a := b; 
    92      311    while st(st(one + a) - one) = zero do 
    93      323       begin a := a * beta; machep := machep + 1 end; 
    94      334    eps := a; 
    95      337    if (ibeta <> 2) and (irnd <> 0) then 
    96      347       begin 
    97      347       a := a * st(one + a) / (one + one); 
    98      359       if st(st(one + a) - one) <> zero then 
    99      371          eps := a; 
   100      374       end; 
   101      374    ngrd := 0; 
   102      377    if (irnd = 0) and (st(st(one + eps) * one - one) <> zero) then 
   103      397       ngrd := 1; 
   104      400    i := 0; k := 1; z := betain; underflo := false; 
   105      409    repeat 
   106      409       begin 
   107      409       y := z; z := y * y; a := z * one; 
   108      419       if (st(a + a) = zero) or (abs (z) >= y) then 
   109      432          underflo := true 
   110      432       else 
   111      436          begin i := i + 1; k := k + k end; 
   112      444       end 
   113      444    until underflo; 
   114      446    if ibeta <> 10 then 
   115      451       begin iexp := i + 1; mx := k + k end 
   116      460    else 
   117      461       begin iexp := 2; iz := ibeta; 
   118      467       while k >= iz do 
   119      471          begin iz := iz * ibeta; iexp := iexp + 1 end; 
   120      483       mx := iz + iz - 1; 
   121      489       end; 
   122      489    underflo := false; 
   123      492    repeat 
   124      492       begin 
   125      492       xmin := y; y := y * betain; a := y * one; 
   126      503       if (st(a + a) = zero) or (abs (y) >= xmin) 
   127      515             or (st(y * st(one + eps)) <= y) then 
   128      530          underflo := true 
   129      530       else 
   130      534          k := k + 1; 
   131      538       end 
   132      538    until underflo; 
   133      540    minexp := - k; 
   134      544    if (mx <= k + k - 3) and (ibeta <> 10) then 
   135      557       begin mx := mx + mx; iexp := iexp + 1 end; 
   136      567    maxexp := mx + minexp; i := maxexp + minexp; 
   137      579    if ibeta = 2 then 
   138      584       if (iexp = 8) and (it = 24) and (i = 4) then 
   139      598          maxexp := maxexp - 2 
   140      601       else if (iexp = 11) and (it = 53) and (i = 4) then 
   141      619          maxexp := maxexp - 2 
   142      622       else if i = 0 then 
   143      630          maxexp := maxexp - 1; 
   144      636    if i > 20 then 
   145      640       maxexp := maxexp - 1; 
   146      646    if a <> y then 
   147      650       maxexp := maxexp - 2; 
   148      656    xmax := one - epsneg; 
   149      662    if st(xmax * one) <> xmax then 
   150      672       xmax := one - st(beta * epsneg); 
   151      682    xmax := xmax / (beta * beta * beta * xmin); 
   152      695    i := maxexp + minexp + 3; 
   153      703    for j := 1 to i do 
   154      713       if ibeta = 2 then 
   155      718          xmax := xmax + xmax 
   156      721       else 
   157      726          xmax := xmax * beta; 
   158      742    end; 
   159      743  
   160      743  
   161      743  
   162      743  
   163      743  
   164      743  
   165      743 function random: real; 
   166      743  
   167      743  
   168      743    { For details, see test 6.6.6.2-6   } 
   169      743  
   170      743    var 
   171      -32       ni, k, r: integer; 
   172      -44       x: real; 
   173      -52    begin 
   174      743    k := ix div 177; 
   175      749    r := ix - k * 177; 
   176      755    ni := - k - k + 171 * r; 
   177      764    if ni < 0 then 
   178      768       ix := ni + 30269 
   179      769    else 
   180      774       ix := ni; 
   181      777    k := iy div 176; 
   182      781    r := iy - k * 176; 
   183      787    ni := - 35 * k + r * 172; 
   184      796    if ni < 0 then 
   185      800       iy := ni + 30307 
   186      801    else 
   187      806       iy := ni; 
   188      809    k := iz div 178; 
   189      813    r := iz - k * 178; 
   190      819    ni := - 63 * k + r * 170; 
   191      828    if ni < 0 then 
   192      832       iz := ni + 30323 
   193      833    else 
   194      838       iz := ni; 
   195      841    x := ix/30269.0 + iy/30307.0 + iz/30323.0; 
   196      856    random := x - trunc(x) 
   197      859    end  {random} ; 
   198      863  
   199      863  
   200      863 function randl (x: real ): real; 
   201      863  
   202      863 {     For details, see test 6.6.6.2-6 } 
   203      863  
   204      863  
   205      863 begin 
   206      863    randl := exp ( x * random ) 
   207      869 end; 
   208      872  
   209      872  
   210      872 procedure printtestrun (n: integer; lb, ub: real; 
   211      872                         big, equal, small: integer; 
   212      872                         rdigits, radix: integer; 
   213      872                         maxerror, xmaxerror, rmserror: real); 
   214      872 var 
   215      -96    loss: real;  { Limit for loss in accuracy, see test 6.6.6.2-6 } 
   216     -104 begin 
   217      872    loss := 4.0 * (1.0 + ln(4.0)/albeta) / 3.0; 
   218      885    writeln('      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL') 
   219      891       ; 
   220      893    writeln('   (',lb,',',ub,')'); 
   221      913    writeln; 
   222      916    writeln('  THE RESULT WAS TOO LARGE',big:5,' TIMES, AND'); 
   223      931    writeln('   EQUAL', equal:5, ' TIMES' ); 
   224      946    writeln('   TOO SMALL',small:5,' TIMES'); 
   225      961    writeln; 
   226      964    writeln('  THERE ARE', it:4, ' BASE', ibeta:4, 
   227      980       ' SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER' ); 
   228      986    if maxerror <> zero then 
   229      990       w := ln(abs(maxerror))/albeta 
   230      993    else 
   231      997       w := -999.0; 
   232     1000    writeln('  THE MAXIMUM RELATIVE ERROR OF',maxerror,'=', 
   233     1012          ibeta:4,' ** ',w:7:2); 
   234     1025    writeln('   OCCURRED FOR X =',xmaxerror); 
   235     1036    if w + ait < zero then 
   236     1042       w := zero 
   237     1042    else 
   238     1045       w := w + ait; 
   239     1049    writeln('   ESTIMATED LOSS OF BASE', ibeta:4, 
   240     1058       ' SIGNIFICANT DIGITS IS', w:7:2); 
   241     1068    if w > loss then 
   242     1072       failed := true; 
   243     1075    if rmserror <> zero then 
   244     1079       w := ln(abs(rmserror))/albeta 
   245     1082    else 
   246     1086       w := -999.0; 
   247     1089    writeln('  ROOT-MEAN-SQUARE RELATIVE ERROR =',rmserror, 
   248     1098          '=',ibeta:4,' ** ',w:7:2); 
   249     1114    if w + ait < zero then 
   250     1120       w := zero 
   251     1120    else 
   252     1123       w := w + ait; 
   253     1127    writeln('   ESTIMATED LOSS OF BASE', ibeta:4, 
   254     1136       ' SIGNIFICANT DIGITS IS', w:7:2); 
   255     1146    if w > 0.5 * loss then 
   256     1152       failed := true; 
   257     1155    writeln 
   258     1155 end; 
radix      unreferenced
rdigits    unreferenced
n          unreferenced
  { printtestrun } 
   259     1159  
   260     1159 begin  {Main program} 
   261     1159    iz := 1; 
   262     1164    iy := 10001; 
   263     1167    ix := 4987; 
   264     1170    machar(ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, 
   265     1179       maxexp, eps, epsneg, xmin, xmax ); 
   266     1185    failed := false; 
   267     1188    beta := ibeta; 
   268     1191    albeta := ln(beta); 
   269     1194    ait := it; 
   270     1197    one := 1.0; 
   271     1199    half := 0.5; 
   272     1201    two := 2.0; 
   273     1203    zero := 0.0; 
   274     1205    a := - 0.0625; 
   275     1208    b := - a; 
   276     1211    ob32 := b * half; 
   277     1215    n := 2000; 
   278     1217    xn := n; 
   279     1220    i1 := 0; 
   280     1222  
   281     1222   {    random argument accuracy tests   } 
   282     1222  
   283     1222    for j := 1 to 4 do 
   284     1232       begin 
   285     1232       k1 := 0; 
   286     1234       k3 := 0; 
   287     1236       x1 := zero; 
   288     1238       r6 := zero; 
   289     1240       r7 := zero; 
   290     1242       del := (b - a) / xn; 
   291     1248       xl := a; 
   292     1250  
   293     1250       for i := 1 to n do 
   294     1260          begin 
   295     1260          x := del * random + xl; 
   296     1267          if j = 2 then 
   297     1271             x := ( forcestore(1.0 + x * a) - one) * 16.0; 
   298     1283          z := arctan(x); 
   299     1286          case j of 
   300     1288          1: 
   301     1288             begin 
   302     1288                xsq := x * x; 
   303     1292                em := 17.0; 
   304     1294                sum := xsq / em; 
   305     1298  
   306     1298                for ii := 1 to 7 do 
   307     1308                   begin 
   308     1308                   em := em - two; 
   309     1312                   sum := (one / em - sum) * xsq 
   310     1317                   end; 
   311     1330  
   312     1330                sum := - x * sum; 
   313     1335                zz := x + sum; 
   314     1339                sum := (x - zz) + sum; 
   315     1345                if irnd = 0 then 
   316     1349                   zz := zz + (sum + sum) 
   317     1353             end; 
   318     1356          2: 
   319     1356             begin 
   320     1356                y := x - 0.0625; 
   321     1360                y := y / (one + x * a); 
   322     1368                zz := ( arctan(y) - 8.1190004042651526021E-5 ) + 
   323     1372                   ob32; 
   324     1375                zz := zz + ob32 
   325     1376             end; 
   326     1380          3,4: 
   327     1380             begin 
   328     1380                z := z + z; 
   329     1384                y := x / ((half+x*half) * (forcestore(half-x)+half)); 
   330     1400                zz := arctan(y) 
   331     1401             end 
   332     1403          end; 
   333     1412          w := one; 
   334     1414          if z <> zero then 
   335     1418             w := (z - zz) / z; 
   336     1424          if w > zero then 
   337     1428             k1 := k1 + 1; 
   338     1432          if w < zero then 
   339     1436             k3 := k3 + 1; 
   340     1440          w := abs(w); 
   341     1443          if w > r6 then 
   342     1447             begin 
   343     1447             r6 := w; 
   344     1449             x1 := x 
   345     1449             end; 
   346     1451          r7 := r7 + w * w; 
   347     1457          xl := xl + del 
   348     1458          end; 
   349     1471  
   350     1471       k2 := n - k3 - k1; 
   351     1477       r7 := sqrt(r7 / xn); 
   352     1482       if j = 1 then 
   353     1486          begin 
   354     1486          writeln(' TEST OF ARCTAN(X) VS TRUNCATED TAYLOR SERIES'); 
   355     1494          writeln 
   356     1494          end; 
   357     1497       if j = 2 then 
   358     1501          begin 
   359     1501          write(' TEST OF ARCTAN(X) VS ARCTAN(1/16) + '); 
   360     1508          writeln(' ARCTAN((X-1/16)/(1+X/16))'); 
   361     1516          writeln 
   362     1516          end; 
   363     1519       if j > 2 then 
   364     1523          begin 
   365     1523          writeln(' TEST OF 2*ARCTAN(X) VS ARCTAN(2X/(1-X*X))'); 
   366     1531          writeln 
   367     1531          end; 
   368     1534       printtestrun(n, a, b, k1, k2, k3, it, ibeta, r6, x1, r7); 
   369     1547       a := b; 
   370     1549       if j = 1 then 
   371     1553          b := two - sqrt( 3.0 ); 
   372     1558       if j = 2 then 
   373     1562          b := sqrt(two) - one; 
   374     1567       if j = 3 then 
   375     1571          b := one 
   376     1571       end; 
   377     1583  
   378     1583    {   special tests   } 
   379     1583  
   380     1583    writeln(' THE IDENTITY ARCTAN(-X) = -ARCTAN(X) WILL BE TESTED'); 
   381     1591    writeln; 
   382     1594    writeln('        X         F(X) + F(-X)'); 
   383     1602    writeln; 
   384     1605    a := 5.0; 
   385     1607  
   386     1607    for i := 1 to 5 do 
   387     1617       begin 
   388     1617       x := random * a; 
   389     1622       z := arctan(x) + arctan( - x); 
   390     1629       writeln(' ',x, z) 
   391     1640       end; 
   392     1652    writeln; 
   393     1655  
   394     1655    writeln(' THE IDENTITY ARCTAN(X) = X, X SMALL, WILL BE TESTED'); 
   395     1663    writeln; 
   396     1666    writeln('        X           X - F(X)'); 
   397     1674    writeln; 
   398     1677    betap := exp(it * ln(beta) ); 
   399     1684    x := random / betap; 
   400     1689  
   401     1689    for i := 1 to 5 do 
   402     1699       begin 
   403     1699       z := x - arctan(x); 
   404     1704       writeln(' ',x, z); 
   405     1717       x := x / beta 
   406     1718       end; 
   407     1731    writeln; 
   408     1734    writeln; 
   409     1737  
   410     1737    { Tests of ATAN against ATAN2 cannot be done in (Standard) Pascal } 
   411     1737  
   412     1737    writeln(' TEST OF UNDERFLOW FOR A VERY SMALL ARGUMENT'); 
   413     1745    writeln; 
   414     1748    expon := minexp * 0.75; 
   415     1753    x := exp(expon * ln(beta) ); 
   416     1759    y := arctan(x); 
   417     1762    writeln('      ARCTAN(', x, ') = ', y); 
   418     1780    writeln; 
   419     1783    writeln(' TEST OF OVERFLOW FOR A VERY LARGE ARGUMENT'); 
   420     1791    writeln; 
   421     1794    expon := maxexp * 0.75; 
   422     1799    x := exp(expon * ln(beta) ); 
   423     1805    writeln; 
   424     1808    z := arctan(x); 
   425     1811    writeln('      ARCTAN(', x, ') = ', z); 
   426     1829    writeln; 
   427     1832  
   428     1832    { Error returns of ATAN2 not applicable to Pascal. } 
   429     1832  
   430     1832    if failed then 
   431     1834       writeln(' FAIL...6.6.6.2-7') 
   432     1840    else 
   433     1843       writeln(' QUALITY...6.6.6.2-7') 
   434     1849 end. 
ran        unreferenced


Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 TEST OF ARCTAN(X) VS TRUNCATED TAYLOR SERIES

      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL
   (-6.250000000000000e-02, 6.250000000000000e-02)

  THE RESULT WAS TOO LARGE    0 TIMES, AND
   EQUAL 2000 TIMES
   TOO SMALL    0 TIMES

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 0.000000000000000e+00=   2 ** -999.00
   OCCURRED FOR X = 0.000000000000000e+00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00
  ROOT-MEAN-SQUARE RELATIVE ERROR = 0.000000000000000e+00=   2 ** -999.00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 TEST OF ARCTAN(X) VS ARCTAN(1/16) +  ARCTAN((X-1/16)/(1+X/16))

      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL
   ( 6.250000000000000e-02, 2.679491924311228e-01)

  THE RESULT WAS TOO LARGE  416 TIMES, AND
   EQUAL 1393 TIMES
   TOO SMALL  191 TIMES

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 2.219126087540324e-16=   2 **  -52.00
   OCCURRED FOR X = 2.555003254636183e-01
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   1.00
  ROOT-MEAN-SQUARE RELATIVE ERROR = 8.587392666342872e-17=   2 **  -53.37
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 TEST OF 2*ARCTAN(X) VS ARCTAN(2X/(1-X*X))

      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL
   ( 2.679491924311228e-01, 4.142135623730951e-01)

  THE RESULT WAS TOO LARGE  259 TIMES, AND
   EQUAL 1475 TIMES
   TOO SMALL  266 TIMES

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 2.116042957555475e-16=   2 **  -52.07
   OCCURRED FOR X = 2.685230297279085e-01
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.93
  ROOT-MEAN-SQUARE RELATIVE ERROR = 8.808390917816448e-17=   2 **  -53.33
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 TEST OF 2*ARCTAN(X) VS ARCTAN(2X/(1-X*X))

      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL
   ( 4.142135623730951e-01, 1.000000000000000e+00)

  THE RESULT WAS TOO LARGE  137 TIMES, AND
   EQUAL 1744 TIMES
   TOO SMALL  119 TIMES

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 2.207038006988966e-16=   2 **  -52.01
   OCCURRED FOR X = 5.502531730838744e-01
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.99
  ROOT-MEAN-SQUARE RELATIVE ERROR = 5.609951392846455e-17=   2 **  -53.98
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 THE IDENTITY ARCTAN(-X) = -ARCTAN(X) WILL BE TESTED

        X         F(X) + F(-X)

  1.297582562812132e+00 0.000000000000000e+00
  1.158826150975052e+00 0.000000000000000e+00
  8.296737813335775e-01 0.000000000000000e+00
  7.923971601129753e-01 0.000000000000000e+00
  2.964218288514680e+00 0.000000000000000e+00

 THE IDENTITY ARCTAN(X) = X, X SMALL, WILL BE TESTED

        X           X - F(X)

  4.605031284071332e-17 0.000000000000000e+00
  2.302515642035666e-17 0.000000000000000e+00
  1.151257821017833e-17 0.000000000000000e+00
  5.756289105089165e-18 0.000000000000000e+00
  2.878144552544582e-18 0.000000000000000e+00


 TEST OF UNDERFLOW FOR A VERY SMALL ARGUMENT

      ARCTAN( 6.44114876959743e-232) =  6.44114876959743e-232

 TEST OF OVERFLOW FOR A VERY LARGE ARGUMENT


      ARCTAN( 9.23132780767170e+230) =  1.570796326794897e+00

 QUALITY...6.6.6.2-7

program complete

Compiling and running t6p6p6p2d8

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.6.6.2-8, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks the implementation of the exp function. } 
     4      -32 {  For FORTRAN version, see 'Software Manual for the Elementary 
     5      -32    Functions', Prentice-Hall 1980, W.J.Cody and W.Waite pp79-83. 
     6      -32    Failure indicates the implementation is worse than that given 
     7      -32    by Cody and Waite, but exceptional argument values could 
     8      -32    produce a large maximum relative error without indicating a 
     9      -32    numerically poor routine. } 
    10      -32 {V3.1: Machar changed and forcestore calls added. } 
    11      -32  
    12      -32 program t6p6p6p2d8(output); 
    13      -32  
    14      -32 var 
    15      -32  
    16      -32  
    17      -32 {     data required 
    18      -32  
    19      -32          none 
    20      -32  
    21      -32       other subprograms in this package 
    22      -32  
    23      -32          machar -  as for 6.6.6.2-6 
    24      -32          random -  as for 6.6.6.2-6 
    25      -32  
    26      -32  
    27      -32       standard subprograms required 
    28      -32  
    29      -32          abs, ln, exp, sqrt 
    30      -32                                                                       } 
    31      -32  
    32      -32    i, ibeta, iexp, irnd, it, i1, j, k1, k2, k3, machep, 
    33      -32    maxexp, minexp, n, negep, ngrd: integer; 
    34      -32    ix: 1 .. 30268;   iy: 1 .. 30306;   iz: 1 .. 30322; 
    35      -32    a, ait, albeta, b, beta, d, del, 
    36      -32    eps, epsneg, one, ran, r6, r7, two, ten, 
    37      -32    v, w, x, xl, xmax, xmin, xn, x1, y, z, zero, zz: real; 
    38      -32    failed: boolean; 
    39      -32  
    40      -32 function forcestore(x: real): real; 
    41      -40    { see 'st' in 6.6.6.2-11 for details} 
    42      -40    var 
    43      -40       y: array[1..3] of real; 
    44      -64    begin 
    45        3    y[1] := x; y[2] := 0.0; y[3] := y[1] + y[2]; 
    46       38    y[1] := y[3]; forcestore := y[1] + y[2] 
    47       61    end; 
    48       65  
    49       65 procedure machar (var ibeta, it, irnd, ngrd, machep, negep, iexp, 
    50       65       minexp, maxexp: integer; var eps, epsneg, xmin, xmax: real); 
    51       65    { see 6.6.6.2-11 for details } 
    52       65    var 
    53      -84       i, iz, j, k, mx: integer; 
    54     -104       a, b, beta, betain, betam1, one, y, z, zero: real; 
    55     -176       underflo: boolean; 
    56     -177    function st(x: real): real; 
    57      -40       begin 
    58       65       st := forcestore(x); 
    59       71       end; 
    60       72  
    61       72    begin 
    62       72    one := 1.0; zero := 0.0; a := one + one; 
    63       82    while st(st(st(a + one) - a) - one) = zero do 
    64       98       a := a + a; 
    65      103    b := one + one; 
    66      107    while st(st(a + b) - a) = zero do 
    67      119       b := b + b; 
    68      124    ibeta := trunc (st(a + b) - a); beta := ibeta; 
    69      138    it := 0; b := one; 
    70      143    repeat 
    71      143       begin it := it + 1; b := b * beta end 
    72      153    until st(st(st(b + one) - b) - one) <> zero; 
    73      169    irnd := 0; 
    74      172    betam1 := beta - one; 
    75      176    if st(st((a + beta) + betam1) - (a + beta)) <> zero then 
    76      192       irnd := 1; 
    77      195    negep := it + 3; betain := one / beta; a := one; 
    78      207    for i := 1 to negep do 
    79      218       a := a * betain; 
    80      232    b := a; 
    81      234    while st(st(one - a) - one) = zero do 
    82      246       begin a := a * beta; negep := negep - 1 end; 
    83      257    negep := - negep; epsneg := a; 
    84      265    if (ibeta <> 2) and (irnd <> 0) then 
    85      275       begin 
    86      275       a := a * st(one + a) / (one + one); 
    87      287       if st(st(one - a) - one) <> zero then 
    88      299          epsneg := a; 
    89      302       end; 
    90      302    machep := - it - 3; a := b; 
    91      311    while st(st(one + a) - one) = zero do 
    92      323       begin a := a * beta; machep := machep + 1 end; 
    93      334    eps := a; 
    94      337    if (ibeta <> 2) and (irnd <> 0) then 
    95      347       begin 
    96      347       a := a * st(one + a) / (one + one); 
    97      359       if st(st(one + a) - one) <> zero then 
    98      371          eps := a; 
    99      374       end; 
   100      374    ngrd := 0; 
   101      377    if (irnd = 0) and (st(st(one + eps) * one - one) <> zero) then 
   102      397       ngrd := 1; 
   103      400    i := 0; k := 1; z := betain; underflo := false; 
   104      409    repeat 
   105      409       begin 
   106      409       y := z; z := y * y; a := z * one; 
   107      419       if (st(a + a) = zero) or (abs (z) >= y) then 
   108      432          underflo := true 
   109      432       else 
   110      436          begin i := i + 1; k := k + k end; 
   111      444       end 
   112      444    until underflo; 
   113      446    if ibeta <> 10 then 
   114      451       begin iexp := i + 1; mx := k + k end 
   115      460    else 
   116      461       begin iexp := 2; iz := ibeta; 
   117      467       while k >= iz do 
   118      471          begin iz := iz * ibeta; iexp := iexp + 1 end; 
   119      483       mx := iz + iz - 1; 
   120      489       end; 
   121      489    underflo := false; 
   122      492    repeat 
   123      492       begin 
   124      492       xmin := y; y := y * betain; a := y * one; 
   125      503       if (st(a + a) = zero) or (abs (y) >= xmin) 
   126      515             or (st(y * st(one + eps)) <= y) then 
   127      530          underflo := true 
   128      530       else 
   129      534          k := k + 1; 
   130      538       end 
   131      538    until underflo; 
   132      540    minexp := - k; 
   133      544    if (mx <= k + k - 3) and (ibeta <> 10) then 
   134      557       begin mx := mx + mx; iexp := iexp + 1 end; 
   135      567    maxexp := mx + minexp; i := maxexp + minexp; 
   136      579    if ibeta = 2 then 
   137      584       if (iexp = 8) and (it = 24) and (i = 4) then 
   138      598          maxexp := maxexp - 2 
   139      601       else if (iexp = 11) and (it = 53) and (i = 4) then 
   140      619          maxexp := maxexp - 2 
   141      622       else if i = 0 then 
   142      630          maxexp := maxexp - 1; 
   143      636    if i > 20 then 
   144      640       maxexp := maxexp - 1; 
   145      646    if a <> y then 
   146      650       maxexp := maxexp - 2; 
   147      656    xmax := one - epsneg; 
   148      662    if st(xmax * one) <> xmax then 
   149      672       xmax := one - st(beta * epsneg); 
   150      682    xmax := xmax / (beta * beta * beta * xmin); 
   151      695    i := maxexp + minexp + 3; 
   152      703    for j := 1 to i do 
   153      713       if ibeta = 2 then 
   154      718          xmax := xmax + xmax 
   155      721       else 
   156      726          xmax := xmax * beta; 
   157      742    end; 
   158      743  
   159      743  
   160      743  
   161      743  
   162      743  
   163      743  
   164      743  
   165      743  
   166      743  
   167      743 function random: real; 
   168      743  
   169      743  
   170      743    { For details, see test 6.6.6.2-6   } 
   171      743  
   172      743    var 
   173      -32       ni, k, r: integer; 
   174      -44       x: real; 
   175      -52    begin 
   176      743    k := ix div 177; 
   177      749    r := ix - k * 177; 
   178      755    ni := - k - k + 171 * r; 
   179      764    if ni < 0 then 
   180      768       ix := ni + 30269 
   181      769    else 
   182      774       ix := ni; 
   183      777    k := iy div 176; 
   184      781    r := iy - k * 176; 
   185      787    ni := - 35 * k + r * 172; 
   186      796    if ni < 0 then 
   187      800       iy := ni + 30307 
   188      801    else 
   189      806       iy := ni; 
   190      809    k := iz div 178; 
   191      813    r := iz - k * 178; 
   192      819    ni := - 63 * k + r * 170; 
   193      828    if ni < 0 then 
   194      832       iz := ni + 30323 
   195      833    else 
   196      838       iz := ni; 
   197      841    x := ix/30269.0 + iy/30307.0 + iz/30323.0; 
   198      856    random := x - trunc(x) 
   199      859    end  {random} ; 
   200      863  
   201      863  
   202      863 procedure printtestrun (n: integer; lb, ub: real; 
   203      863                         big, equal, small: integer; 
   204      863                         rdigits, radix: integer; 
   205      863                         maxerror, xmaxerror, rmserror: real); 
   206      863 var 
   207      -96    loss: real;  { Limit for loss in accuracy, see test 6.6.6.2-6 } 
   208     -104 begin 
   209      863    loss := 4.0 * (1.0 + ln(4.0)/albeta) / 3.0; 
   210      876    writeln('      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL') 
   211      882       ; 
   212      884    writeln('   (',lb,',',ub,')'); 
   213      904    writeln; 
   214      907    writeln('  THE RESULT WAS TOO LARGE',big:5,' TIMES, AND'); 
   215      922    writeln('   EQUAL', equal:5, ' TIMES' ); 
   216      937    writeln('   TOO SMALL',small:5,' TIMES'); 
   217      952    writeln; 
   218      955    writeln('  THERE ARE', it:4, ' BASE', ibeta:4, 
   219      971       ' SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER' ); 
   220      977    if maxerror <> zero then 
   221      981       w := ln(abs(maxerror))/albeta 
   222      984    else 
   223      988       w := -999.0; 
   224      991    writeln('  THE MAXIMUM RELATIVE ERROR OF',maxerror,'=', 
   225     1003          ibeta:4,' ** ',w:7:2); 
   226     1016    writeln('   OCCURRED FOR X =',xmaxerror); 
   227     1027    if w + ait < zero then 
   228     1033       w := zero 
   229     1033    else 
   230     1036       w := w + ait; 
   231     1040    writeln('   ESTIMATED LOSS OF BASE', ibeta:4, 
   232     1049       ' SIGNIFICANT DIGITS IS', w:7:2); 
   233     1059    if w > loss then 
   234     1063       failed := true; 
   235     1066    if rmserror <> zero then 
   236     1070       w := ln(abs(rmserror))/albeta 
   237     1073    else 
   238     1077       w := -999.0; 
   239     1080    writeln('  ROOT-MEAN-SQUARE RELATIVE ERROR =',rmserror, 
   240     1089          '=',ibeta:4,' ** ',w:7:2); 
   241     1105    if w + ait < zero then 
   242     1111       w := zero 
   243     1111    else 
   244     1114       w := w + ait; 
   245     1118    writeln('   ESTIMATED LOSS OF BASE', ibeta:4, 
   246     1127       ' SIGNIFICANT DIGITS IS', w:7:2); 
   247     1137    if w > 0.5 * loss then 
   248     1143       failed := true; 
   249     1146    writeln 
   250     1146 end; 
radix      unreferenced
rdigits    unreferenced
n          unreferenced
  { printtestrun } 
   251     1150  
   252     1150 begin  {Main program} 
   253     1150    iz := 1; 
   254     1155    iy := 10001; 
   255     1158    ix := 4987; 
   256     1161    machar ( ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, 
   257     1170       maxexp, eps, epsneg, xmin, xmax ); 
   258     1176    failed := false; 
   259     1179    beta := ibeta; 
   260     1182    albeta := ln(beta); 
   261     1185    ait := it; 
   262     1188    one := 1.0; 
   263     1190    two := 2.0; 
   264     1192    ten := 10.0; 
   265     1194    zero := 0.0; 
   266     1196    v := 0.0625; 
   267     1198    a := two; 
   268     1200    b := ln(a) * 0.5; 
   269     1205    a := - b + v; 
   270     1210    d := ln(0.9 * xmax); 
   271     1215    n := 2000; 
   272     1217    xn := n; 
   273     1220    i1 := 0; 
   274     1222  
   275     1222    {   random argument accuracy tests  } 
   276     1222  
   277     1222    for j := 1 to 3 do 
   278     1232       begin 
   279     1232       k1 := 0; 
   280     1234       k3 := 0; 
   281     1236       x1 := zero; 
   282     1238       r6 := zero; 
   283     1240       r7 := zero; 
   284     1242       del := (b - a) / xn; 
   285     1248       xl := a; 
   286     1250  
   287     1250       for i := 1 to n do 
   288     1260          begin 
   289     1260          x := del * random + xl; 
   290     1267  
   291     1267          {   purify agruments   } 
   292     1267  
   293     1267          y :=  forcestore(x - v); 
   294     1273          if y < zero then 
   295     1277             x :=  forcestore(y + v); 
   296     1283          z := exp(x); 
   297     1286          zz := exp(y); 
   298     1289          if j = 1 then 
   299     1293             z := z - z * 6.058693718652421388E-2 
   300     1295          else 
   301     1300             begin 
   302     1300             if ibeta = 10 then 
   303     1304                z := z * 6.0E-2 + z * 5.466789530794296106E-5 
   304     1308             else 
   305     1313                z := z * 0.0625 - z * 2.4453321046920570389E-3 
   306     1317             end; 
   307     1321          w := one; 
   308     1323          if zz <> zero then 
   309     1327             w := (z - zz) / zz; 
   310     1333          if w < zero then 
   311     1337             k1 := k1 + 1; 
   312     1341          if w > zero then 
   313     1345             k3 := k3 + 1; 
   314     1349          w := abs(w); 
   315     1352          if w > r6 then 
   316     1356             begin 
   317     1356             r6 := w; 
   318     1358             x1 := x 
   319     1358             end; 
   320     1360          r7 := r7 + w * w; 
   321     1366          xl := xl + del 
   322     1367          end; 
   323     1380  
   324     1380       k2 := n - k3 - k1; 
   325     1386       r7 := sqrt(r7 / xn); 
   326     1391       writeln(' TEST OF EXP(X-', v:7:4, ') VS EXP(X)/EXP(', v:7:4, ')'); 
   327     1414       writeln; 
   328     1417       printtestrun(n, a, b, k1, k2, k3, it, ibeta, r6, x1, r7); 
   329     1430       if j = 2 then 
   330     1434          begin 
   331     1434          a := - two * a; 
   332     1439          b := ten * a; 
   333     1443          if b < d then 
   334     1447             b := d 
   335     1447          end 
   336     1449       else 
   337     1450          begin 
   338     1450          v := 45.0 / 16.0; 
   339     1454          a := - ten * b; 
   340     1459          b := 4.0 * xmin * exp(it * ln(beta) ); 
   341     1470          b := ln(b) 
   342     1471          end 
   343     1473       end; 
   344     1483  
   345     1483    {   special tests   } 
   346     1483  
   347     1483    writeln(' THE IDENTITY EXP(X) * EXP(-X) - 1.0 WILL BE TESTED.'); 
   348     1491    writeln; 
   349     1494    writeln('        X        F(X)*F(-X) - 1'); 
   350     1502    writeln; 
   351     1505  
   352     1505    for i := 1 to 5 do 
   353     1515       begin 
   354     1515       x := random * beta; 
   355     1520       y := - x; 
   356     1523       z := exp(x) * exp(y) - one; 
   357     1531       writeln(' ',x, z) 
   358     1542       end; 
   359     1554    writeln; 
   360     1557    writeln(' TEST OF SPECIAL ARGUMENTS'); 
   361     1565    writeln; 
   362     1568    x := zero; 
   363     1570    y := exp(x) - one; 
   364     1575    writeln(' EXP(0.0) - 1.0 = ', y); 
   365     1586    writeln; 
   366     1589    x := trunc( ln(xmin) ); 
   367     1594    y := exp(x); 
   368     1597    writeln(' EXP(', x, ') = ', y); 
   369     1615    writeln; 
   370     1618    x := trunc( ln(xmax) - 0.5 ); 
   371     1625    y := exp(x); 
   372     1628    writeln(' EXP(', x, ') = ', y); 
   373     1646    writeln; 
   374     1649    x := x / two; 
   375     1653    v := x / two; 
   376     1657    y := exp(x); 
   377     1660    z := exp(v); 
   378     1663    z := z * z; 
   379     1667    writeln(' IF EXP(', x, ') = ', y, ' IS NOT ABOUT'); 
   380     1689    write(' EXP(', v, ')**2 = ', z, ' THERE IS AN ARGUMENT'); 
   381     1710    writeln(' REDUCTION ERROR'); 
   382     1718    writeln; 
   383     1721  
   384     1721 { Test of error returns deleted since action not clear from Standard. 
   385     1721   Error test also deleted. } 
   386     1721  
   387     1721    if failed then 
   388     1723       writeln(' FAIL...6.6.6.2-8') 
   389     1729    else 
   390     1732       writeln(' QUALITY...6.6.6.2-8') 
   391     1738 end. 
ran        unreferenced


Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 TEST OF EXP(X- 0.0625) VS EXP(X)/EXP( 0.0625)

      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL
   (-2.840735902799726e-01, 3.465735902799726e-01)

  THE RESULT WAS TOO LARGE  271 TIMES, AND
   EQUAL 1487 TIMES
   TOO SMALL  242 TIMES

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 2.218605804978282e-16=   2 **  -52.00
   OCCURRED FOR X = 6.332911596344533e-02
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   1.00
  ROOT-MEAN-SQUARE RELATIVE ERROR = 8.164569298296603e-17=   2 **  -53.44
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 TEST OF EXP(X- 2.8125) VS EXP(X)/EXP( 2.8125)

      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL
   (-3.465735902799727e+00,-6.716596179625870e+02)

  THE RESULT WAS TOO LARGE  277 TIMES, AND
   EQUAL 1480 TIMES
   TOO SMALL  243 TIMES

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 2.217595121170967e-16=   2 **  -52.00
   OCCURRED FOR X =-6.092351756656060e+02
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   1.00
  ROOT-MEAN-SQUARE RELATIVE ERROR = 8.099270606154656e-17=   2 **  -53.45
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 TEST OF EXP(X- 2.8125) VS EXP(X)/EXP( 2.8125)

      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL
   ( 6.931471805599453e+00, 7.089842051971663e+02)

  THE RESULT WAS TOO LARGE  296 TIMES, AND
   EQUAL 1481 TIMES
   TOO SMALL  223 TIMES

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 2.220234757521701e-16=   2 **  -52.00
   OCCURRED FOR X = 1.338174122876924e+02
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   1.00
  ROOT-MEAN-SQUARE RELATIVE ERROR = 8.117122930883603e-17=   2 **  -53.45
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 THE IDENTITY EXP(X) * EXP(-X) - 1.0 WILL BE TESTED.

        X        F(X)*F(-X) - 1

  9.879924279396093e-01-1.110223024625157e-16
  1.823914622699025e+00 0.000000000000000e+00
  9.677563256470467e-01 0.000000000000000e+00
  6.798578177107357e-01 0.000000000000000e+00
  1.316742108432787e+00 0.000000000000000e+00

 TEST OF SPECIAL ARGUMENTS

 EXP(0.0) - 1.0 =  0.000000000000000e+00

 EXP(-7.090000000000000e+02) =  1.21678075062342e-308

 EXP( 7.080000000000000e+02) =  3.02338314427606e+307

 IF EXP( 3.540000000000000e+02) =  5.49852993469714e+153 IS NOT ABOUT
 EXP( 1.770000000000000e+02)**2 =  5.49852993469714e+153 THERE IS AN ARGUMENT REDUCTION ERROR

 QUALITY...6.6.6.2-8

program complete

Compiling and running t6p6p6p2d9

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.6.6.2-9, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks the implementation of the sin and cos 
     4      -32    functions. } 
     5      -32 {  For FORTRAN version, see 'Software Manual for the Elementary 
     6      -32    Functions', Prentice-Hall 1980, W.J.Cody and W.Waite pp144-149. 
     7      -32    Failure indicates the implementation is worse than that given 
     8      -32    by Cody and Waite, but exceptional argument values could 
     9      -32    produce a large maximum relative error without indicating a 
    10      -32    numerically poor routine. } 
    11      -32 {V3.1: Machar changed and forcestore calls added. } 
    12      -32  
    13      -32 program t6p6p6p2d9(output); 
    14      -32  
    15      -32 var 
    16      -32  
    17      -32  
    18      -32 {     data required 
    19      -32  
    20      -32          none 
    21      -32  
    22      -32       other subprograms in this package 
    23      -32  
    24      -32          machar -  as for 6.6.6.2-6 
    25      -32          random -  as for 6.6.6.2-6 
    26      -32  
    27      -32  
    28      -32       standard subprograms required 
    29      -32  
    30      -32          abs, ln, exp, cos, sin, sqrt 
    31      -32                                                                       } 
    32      -32  
    33      -32    i, ibeta, iexp, irnd, it, i1, j, k1, k2, k3, machep, 
    34      -32    maxexp, minexp, n, negep, ngrd: integer; 
    35      -32    ix: 1 .. 30268;   iy: 1 .. 30306;   iz: 1 .. 30322; 
    36      -32    a, ait, albeta, b, beta, betap, 
    37      -32    c, del, eps, epsneg, expon, one, ran, 
    38      -32    r6, r7, three, w, x, xl, xmax, xmin, xn, x1, y, z, zero, zz: real; 
    39      -32    failed: boolean; 
    40      -32  
    41      -32  
    42      -32 function forcestore(x: real): real; 
    43      -40    { see 'st' in 6.6.6.2-11 for details} 
    44      -40    var 
    45      -40       y: array[1..3] of real; 
    46      -64    begin 
    47        3    y[1] := x; y[2] := 0.0; y[3] := y[1] + y[2]; 
    48       38    y[1] := y[3]; forcestore := y[1] + y[2] 
    49       61    end; 
    50       65  
    51       65 procedure machar (var ibeta, it, irnd, ngrd, machep, negep, iexp, 
    52       65       minexp, maxexp: integer; var eps, epsneg, xmin, xmax: real); 
    53       65    { see 6.6.6.2-11 for details } 
    54       65    var 
    55      -84       i, iz, j, k, mx: integer; 
    56     -104       a, b, beta, betain, betam1, one, y, z, zero: real; 
    57     -176       underflo: boolean; 
    58     -177    function st(x: real): real; 
    59      -40       begin 
    60       65       st := forcestore(x); 
    61       71       end; 
    62       72  
    63       72    begin 
    64       72    one := 1.0; zero := 0.0; a := one + one; 
    65       82    while st(st(st(a + one) - a) - one) = zero do 
    66       98       a := a + a; 
    67      103    b := one + one; 
    68      107    while st(st(a + b) - a) = zero do 
    69      119       b := b + b; 
    70      124    ibeta := trunc (st(a + b) - a); beta := ibeta; 
    71      138    it := 0; b := one; 
    72      143    repeat 
    73      143       begin it := it + 1; b := b * beta end 
    74      153    until st(st(st(b + one) - b) - one) <> zero; 
    75      169    irnd := 0; 
    76      172    betam1 := beta - one; 
    77      176    if st(st((a + beta) + betam1) - (a + beta)) <> zero then 
    78      192       irnd := 1; 
    79      195    negep := it + 3; betain := one / beta; a := one; 
    80      207    for i := 1 to negep do 
    81      218       a := a * betain; 
    82      232    b := a; 
    83      234    while st(st(one - a) - one) = zero do 
    84      246       begin a := a * beta; negep := negep - 1 end; 
    85      257    negep := - negep; epsneg := a; 
    86      265    if (ibeta <> 2) and (irnd <> 0) then 
    87      275       begin 
    88      275       a := a * st(one + a) / (one + one); 
    89      287       if st(st(one - a) - one) <> zero then 
    90      299          epsneg := a; 
    91      302       end; 
    92      302    machep := - it - 3; a := b; 
    93      311    while st(st(one + a) - one) = zero do 
    94      323       begin a := a * beta; machep := machep + 1 end; 
    95      334    eps := a; 
    96      337    if (ibeta <> 2) and (irnd <> 0) then 
    97      347       begin 
    98      347       a := a * st(one + a) / (one + one); 
    99      359       if st(st(one + a) - one) <> zero then 
   100      371          eps := a; 
   101      374       end; 
   102      374    ngrd := 0; 
   103      377    if (irnd = 0) and (st(st(one + eps) * one - one) <> zero) then 
   104      397       ngrd := 1; 
   105      400    i := 0; k := 1; z := betain; underflo := false; 
   106      409    repeat 
   107      409       begin 
   108      409       y := z; z := y * y; a := z * one; 
   109      419       if (st(a + a) = zero) or (abs (z) >= y) then 
   110      432          underflo := true 
   111      432       else 
   112      436          begin i := i + 1; k := k + k end; 
   113      444       end 
   114      444    until underflo; 
   115      446    if ibeta <> 10 then 
   116      451       begin iexp := i + 1; mx := k + k end 
   117      460    else 
   118      461       begin iexp := 2; iz := ibeta; 
   119      467       while k >= iz do 
   120      471          begin iz := iz * ibeta; iexp := iexp + 1 end; 
   121      483       mx := iz + iz - 1; 
   122      489       end; 
   123      489    underflo := false; 
   124      492    repeat 
   125      492       begin 
   126      492       xmin := y; y := y * betain; a := y * one; 
   127      503       if (st(a + a) = zero) or (abs (y) >= xmin) 
   128      515             or (st(y * st(one + eps)) <= y) then 
   129      530          underflo := true 
   130      530       else 
   131      534          k := k + 1; 
   132      538       end 
   133      538    until underflo; 
   134      540    minexp := - k; 
   135      544    if (mx <= k + k - 3) and (ibeta <> 10) then 
   136      557       begin mx := mx + mx; iexp := iexp + 1 end; 
   137      567    maxexp := mx + minexp; i := maxexp + minexp; 
   138      579    if ibeta = 2 then 
   139      584       if (iexp = 8) and (it = 24) and (i = 4) then 
   140      598          maxexp := maxexp - 2 
   141      601       else if (iexp = 11) and (it = 53) and (i = 4) then 
   142      619          maxexp := maxexp - 2 
   143      622       else if i = 0 then 
   144      630          maxexp := maxexp - 1; 
   145      636    if i > 20 then 
   146      640       maxexp := maxexp - 1; 
   147      646    if a <> y then 
   148      650       maxexp := maxexp - 2; 
   149      656    xmax := one - epsneg; 
   150      662    if st(xmax * one) <> xmax then 
   151      672       xmax := one - st(beta * epsneg); 
   152      682    xmax := xmax / (beta * beta * beta * xmin); 
   153      695    i := maxexp + minexp + 3; 
   154      703    for j := 1 to i do 
   155      713       if ibeta = 2 then 
   156      718          xmax := xmax + xmax 
   157      721       else 
   158      726          xmax := xmax * beta; 
   159      742    end; 
   160      743  
   161      743  
   162      743  
   163      743  
   164      743  
   165      743  
   166      743  
   167      743  
   168      743  
   169      743 function random: real; 
   170      743  
   171      743  
   172      743    { For details, see test 6.6.6.2-6   } 
   173      743  
   174      743    var 
   175      -32       ni, k, r: integer; 
   176      -44       x: real; 
   177      -52    begin 
   178      743    k := ix div 177; 
   179      749    r := ix - k * 177; 
   180      755    ni := - k - k + 171 * r; 
   181      764    if ni < 0 then 
   182      768       ix := ni + 30269 
   183      769    else 
   184      774       ix := ni; 
   185      777    k := iy div 176; 
   186      781    r := iy - k * 176; 
   187      787    ni := - 35 * k + r * 172; 
   188      796    if ni < 0 then 
   189      800       iy := ni + 30307 
   190      801    else 
   191      806       iy := ni; 
   192      809    k := iz div 178; 
   193      813    r := iz - k * 178; 
   194      819    ni := - 63 * k + r * 170; 
   195      828    if ni < 0 then 
   196      832       iz := ni + 30323 
   197      833    else 
   198      838       iz := ni; 
   199      841    x := ix/30269.0 + iy/30307.0 + iz/30323.0; 
   200      856    random := x - trunc(x) 
   201      859    end  {random} ; 
   202      863  
   203      863  
   204      863 procedure printtestrun (n: integer; lb, ub: real; 
   205      863                         big, equal, small: integer; 
   206      863                         rdigits, radix: integer; 
   207      863                         maxerror, xmaxerror, rmserror: real); 
   208      863 var 
   209      -96    loss: real;  { Limit for loss in accuracy, see test 6.6.6.2-6 } 
   210     -104 begin 
   211      863    loss := 4.0 * (1.0 + ln(4.0)/albeta) / 3.0; 
   212      876    writeln('      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL') 
   213      882       ; 
   214      884    writeln('   (',lb,',',ub,')'); 
   215      904    writeln; 
   216      907    writeln('  THE RESULT WAS TOO LARGE',big:5,' TIMES, AND'); 
   217      922    writeln('   EQUAL', equal:5, ' TIMES' ); 
   218      937    writeln('   TOO SMALL',small:5,' TIMES'); 
   219      952    writeln; 
   220      955    writeln('  THERE ARE', it:4, ' BASE', ibeta:4, 
   221      971       ' SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER' ); 
   222      977    if maxerror <> zero then 
   223      981       w := ln(abs(maxerror))/albeta 
   224      984    else 
   225      988       w := -999.0; 
   226      991    writeln('  THE MAXIMUM RELATIVE ERROR OF',maxerror,'=', 
   227     1003          ibeta:4,' ** ',w:7:2); 
   228     1016    writeln('   OCCURRED FOR X =',xmaxerror); 
   229     1027    if w + ait < zero then 
   230     1033       w := zero 
   231     1033    else 
   232     1036       w := w + ait; 
   233     1040    writeln('   ESTIMATED LOSS OF BASE', ibeta:4, 
   234     1049       ' SIGNIFICANT DIGITS IS', w:7:2); 
   235     1059    if w > loss then 
   236     1063       failed := true; 
   237     1066    if rmserror <> zero then 
   238     1070       w := ln(abs(rmserror))/albeta 
   239     1073    else 
   240     1077       w := -999.0; 
   241     1080    writeln('  ROOT-MEAN-SQUARE RELATIVE ERROR =',rmserror, 
   242     1089          '=',ibeta:4,' ** ',w:7:2); 
   243     1105    if w + ait < zero then 
   244     1111       w := zero 
   245     1111    else 
   246     1114       w := w + ait; 
   247     1118    writeln('   ESTIMATED LOSS OF BASE', ibeta:4, 
   248     1127       ' SIGNIFICANT DIGITS IS', w:7:2); 
   249     1137    if w > 0.5 * loss then 
   250     1143       failed := true; 
   251     1146    writeln 
   252     1146    end; 
radix      unreferenced
rdigits    unreferenced
n          unreferenced
 { printtestrun } 
   253     1150  
   254     1150 begin  {Main program} 
   255     1150    iz := 1; 
   256     1155    iy := 10001; 
   257     1158    ix := 4987; 
   258     1161    machar ( ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, 
   259     1170       maxexp, eps, epsneg, xmin, xmax ); 
   260     1176    failed := false; 
   261     1179    beta := ibeta; 
   262     1182    albeta := ln(beta); 
   263     1185    ait := it; 
   264     1188    one := 1.0; 
   265     1190    zero := 0.0; 
   266     1192    three := 3.0; 
   267     1194    a := zero; 
   268     1196    b := 1.570796327; 
   269     1198    c := b; 
   270     1200    n := 2000; 
   271     1202    xn := n; 
   272     1205    i1 := 0; 
   273     1207  
   274     1207    {   random argument accuracy tests  } 
   275     1207  
   276     1207    for j := 1 to 3 do 
   277     1217       begin 
   278     1217       k1 := 0; 
   279     1219       k3 := 0; 
   280     1221       x1 := zero; 
   281     1223       r6 := zero; 
   282     1225       r7 := zero; 
   283     1227       del := (b - a) / xn; 
   284     1233       xl := a; 
   285     1235  
   286     1235       for i := 1 to n do 
   287     1245          begin 
   288     1245          x := del * random + xl; 
   289     1252          y := x / three; 
   290     1256          y := forcestore(x + y) - x; 
   291     1264          x := three * y; 
   292     1268          if j = 3 then 
   293     1272             begin 
   294     1272             z := cos(x); 
   295     1275             zz := cos(y); 
   296     1278             w := one; 
   297     1280             if z <> zero then 
   298     1284                w := (z + zz * (three - 4.0 * zz * zz) ) / z 
   299     1295             end 
   300     1298          else 
   301     1299             begin 
   302     1299             z := sin(x); 
   303     1302             zz := sin(y); 
   304     1305             w := one; 
   305     1307             if z <> zero then 
   306     1311                w := (z - zz * (three - 4.0 * zz * zz) ) / z 
   307     1322             end; 
   308     1325          if w > zero then 
   309     1329             k1 := k1 + 1; 
   310     1333          if w < zero then 
   311     1337             k3 := k3 + 1; 
   312     1341          w := abs(w); 
   313     1344          if w > r6 then 
   314     1348             begin 
   315     1348             r6 := w; 
   316     1350             x1 := x 
   317     1350             end; 
   318     1352          r7 := r7 + w * w; 
   319     1358          xl := xl + del 
   320     1359          end; 
   321     1372  
   322     1372       k2 := n - k1 - k3; 
   323     1378       r7 := sqrt(r7 / xn); 
   324     1383       if j = 3 then 
   325     1387          begin 
   326     1387          writeln(' TEST OF COS(X) VS 4*COS(X/3)**3-3*COS(X/3)'); 
   327     1395          writeln 
   328     1395          end 
   329     1398       else 
   330     1399          begin 
   331     1399          writeln(' TEST OF SIN(X) VS 3*SIN(X/3)-4*SIN(X/3)**3'); 
   332     1407          writeln 
   333     1407          end; 
   334     1410       printtestrun(n, a, b, k1, k2, k3, it, ibeta, r6, x1, r7); 
   335     1423       a := 18.84955592; 
   336     1425       if j = 2 then 
   337     1429          a := b + c; 
   338     1433       b := a + c 
   339     1434       end; 
   340     1447  
   341     1447    {   special tests   } 
   342     1447  
   343     1447    c := one / exp( ( it div 2 ) * ln(beta) ); 
   344     1458    z := ( sin(a + c) - sin(a - c) ) / (c + c); 
   345     1472    write(' IF ', z,' IS NOT ALMOST 1.0 THEN SIN HAS THE WRONG '); 
   346     1486    writeln('PERIOD'); 
   347     1494    writeln; 
   348     1497  
   349     1497    writeln(' THE IDENTITY SIN(-X) = -SIN(X) WILL BE TESTED.'); 
   350     1505    writeln; 
   351     1508    writeln('        X         F(X) + F(-X)'); 
   352     1516    writeln; 
   353     1519  
   354     1519    for i := 1 to 5 do 
   355     1529       begin 
   356     1529       x := random * a; 
   357     1534       z := sin(x) + sin( - x); 
   358     1541       writeln(' ',x,z) 
   359     1552       end; 
   360     1564  
   361     1564    writeln; 
   362     1567    writeln(' THE IDENTITY SIN(X) = X, X SMALL, WILL BE TESTED.'); 
   363     1575    writeln; 
   364     1578    writeln('        X           X - F(X)'); 
   365     1586    writeln; 
   366     1589    betap := exp( it * ln(beta) ); 
   367     1596    x := random / betap; 
   368     1601  
   369     1601    for i := 1 to 5 do 
   370     1611       begin 
   371     1611       z := x - sin(x); 
   372     1616       writeln(' ',x, z); 
   373     1629       x := x / beta 
   374     1630       end; 
   375     1643    writeln; 
   376     1646  
   377     1646    writeln(' THE IDENTITY COS(-X) = COS(X) WILL BE TESTED.'); 
   378     1654    writeln; 
   379     1657    writeln('        X         F(X) - F(-X)'); 
   380     1665    writeln; 
   381     1668  
   382     1668    for i := 1 to 5 do 
   383     1678       begin 
   384     1678       x := random * a; 
   385     1683       z := cos(x) - cos( - x); 
   386     1690       writeln(' ',x, z) 
   387     1701       end; 
   388     1713    writeln; 
   389     1716  
   390     1716    writeln(' TEST OF UNDERFLOW FOR VERY SMALL ARGUMENTS'); 
   391     1724    writeln; 
   392     1727    expon := minexp * 0.75; 
   393     1732    x := exp( expon * ln(beta) ); 
   394     1738    y := sin(x); 
   395     1741    writeln('     SIN(', x, ') = ', y); 
   396     1759    writeln; 
   397     1762    writeln(' THE FOLLOWING THREE LINES ILLUSTRATE THE LOSS IN'); 
   398     1770    writeln(' SIGNIFICANCE FOR LARGE ARGUMENTS. THE ARGUMENTS'); 
   399     1778    writeln(' USED ARE CONSECUTIVE.'); 
   400     1786    writeln; 
   401     1789    z := sqrt(betap); 
   402     1792    x := z * (one - epsneg ); 
   403     1798    y := sin(x); 
   404     1801    writeln('     SIN(', x, ') = ', y); 
   405     1819    writeln; 
   406     1822    y := sin(z); 
   407     1825    writeln('     SIN(', z, ') = ', y); 
   408     1843    writeln; 
   409     1846    x := z * (one + eps ); 
   410     1852    y := sin(x); 
   411     1855    writeln('     SIN(', x, ') = ', y); 
   412     1873    writeln; 
   413     1876  
   414     1876 { Test of error returns deleted since action not clear from Standard} 
   415     1876  
   416     1876    if failed then 
   417     1878       writeln(' FAIL...6.6.6.2-9') 
   418     1884    else 
   419     1887       writeln(' QUALITY...6.6.6.2-9') 
   420     1893 end. 
ran        unreferenced


Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 TEST OF SIN(X) VS 3*SIN(X/3)-4*SIN(X/3)**3

      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL
   ( 0.000000000000000e+00, 1.570796327000000e+00)

  THE RESULT WAS TOO LARGE  350 TIMES, AND
   EQUAL 1256 TIMES
   TOO SMALL  394 TIMES

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 2.875415552204510e-16=   2 **  -51.63
   OCCURRED FOR X = 4.828234726832192e-02
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   1.37
  ROOT-MEAN-SQUARE RELATIVE ERROR = 8.648281038032016e-17=   2 **  -53.36
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 TEST OF SIN(X) VS 3*SIN(X/3)-4*SIN(X/3)**3

      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL
   ( 1.884955592000000e+01, 2.042035224700000e+01)

  THE RESULT WAS TOO LARGE  369 TIMES, AND
   EQUAL 1224 TIMES
   TOO SMALL  407 TIMES

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 2.419205288238537e-16=   2 **  -51.88
   OCCURRED FOR X = 1.908107904809216e+01
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   1.12
  ROOT-MEAN-SQUARE RELATIVE ERROR = 8.805666176079995e-17=   2 **  -53.33
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 TEST OF COS(X) VS 4*COS(X/3)**3-3*COS(X/3)

      RANDOM ARGUMENTS WERE TESTED FROM THE INTERVAL
   ( 2.199114857400000e+01, 2.356194490100000e+01)

  THE RESULT WAS TOO LARGE  373 TIMES, AND
   EQUAL 1239 TIMES
   TOO SMALL  388 TIMES

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 2.853896652860600e-16=   2 **  -51.64
   OCCURRED FOR X = 2.316237728784232e+01
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   1.36
  ROOT-MEAN-SQUARE RELATIVE ERROR = 8.782715753864683e-17=   2 **  -53.34
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 IF  9.999999999999987e-01 IS NOT ALMOST 1.0 THEN SIN HAS THE WRONG PERIOD

 THE IDENTITY SIN(-X) = -SIN(X) WILL BE TESTED.

        X         F(X) + F(-X)

  9.311609259492117e+00 0.000000000000000e+00
  1.718999033693548e+01 0.000000000000000e+00
  9.120888488608870e+00 0.000000000000000e+00
  6.407508976293840e+00 0.000000000000000e+00
  1.241000200256126e+01 0.000000000000000e+00

 THE IDENTITY SIN(X) = X, X SMALL, WILL BE TESTED.

        X           X - F(X)

  7.436854822221825e-17 0.000000000000000e+00
  3.718427411110912e-17 0.000000000000000e+00
  1.859213705555456e-17 0.000000000000000e+00
  9.296068527777281e-18 0.000000000000000e+00
  4.648034263888640e-18 0.000000000000000e+00

 THE IDENTITY COS(-X) = COS(X) WILL BE TESTED.

        X         F(X) - F(-X)

  2.828594547455780e+00 0.000000000000000e+00
  1.510315281881727e+01 0.000000000000000e+00
  1.490423256047358e+01 0.000000000000000e+00
  1.194703458616061e+01 0.000000000000000e+00
  1.205581442819330e+01 0.000000000000000e+00

 TEST OF UNDERFLOW FOR VERY SMALL ARGUMENTS

     SIN( 6.44114876959743e-232) =  6.44114876959743e-232

 THE FOLLOWING THREE LINES ILLUSTRATE THE LOSS IN
 SIGNIFICANCE FOR LARGE ARGUMENTS. THE ARGUMENTS
 USED ARE CONSECUTIVE.

     SIN( 9.490626562425150e+07) =  9.419570721872659e-01

     SIN( 9.490626562425151e+07) =  9.419570671844492e-01

     SIN( 9.490626562425153e+07) =  9.419570621816323e-01

 QUALITY...6.6.6.2-9

program complete

Compiling and running t6p7p1d15

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.7.1-15, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test constructs a null set by using a member-designator 
     4      -32    of the form maxint..-maxint. } 
     5      -32 {V3.1: New test. maxint used in this quality version of 6.7.1-2. } 
     6      -32  
     7      -32 program t6p7p1d15(output); 
     8      -32 begin 
     9        3    if ([maxint..-maxint]=[]) then 
    10       12       writeln(' QUALITY...6.7.1-15') 
    11       18    else 
    12       21       writeln(' FAIL...6.7.1-15') 
    13       27 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program


*** Runtime error [9]: Set element out of range 

program complete

Compiling and running t6p7p1d3

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.7.1-3, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that deeply nested expressions are 
     4      -32    permitted. } 
     5      -32 {V3.0: New test. } 
     6      -32  
     7      -32 program t6p7p1d3(output); 
     8      -32 const 
     9      -32    c0 = 1; c1 = 1; c2 = 1; c3 = 1; c4 = 1; c5 = 1; c6 = 1; c7 = 1; 
    10      -32    c8 = 1; c9 = 1; c10 = 1; c11 = 1; c12 = 1; c13 = 1; c14 = 1; 
    11      -32 var 
    12      -32    v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, 
    13      -32    sum: integer; 
    14      -32 begin 
    15        3    sum := c0 + (c1 + (c2 + (c3 + (c4 + (c5 + (c6 + (c7 + 
    16       13          (c8 + (c9 + (c10 + (c11 + (c12 + (c13 + (c14)))))))))))))); 
    17       35    v0 := 1; v1 := 1; v2 := 1; v3 := 1; v4 := 1; v5 := 1; v6 := 1; 
    18       49    v7 := 1; v8 := 1; v9 := 1; v10 := 1; v11 := 1; v12 := 1; v13 := 1; 
    19       63    v14 := 1; 
    20       65    sum := sum + v0 + (v1 + (v2 + (v3 + (v4 + (v5 + (v6 + (v7 + 
    21       75          (v8 + (v9 + (v10 + (v11 + (v12 + (v13 + (v14)))))))))))))); 
    22       97    if sum <> 30 then 
    23      101       writeln(' FAIL...6.7.1-3') 
    24      107    else 
    25      110       writeln(' QUALITY...6.7.1-3') 
    26      116 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.7.1-3

program complete

Compiling and running t6p7p1d4

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.7.1-4, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that deeply nested expressions are 
     4      -32    permitted. } 
     5      -32 {  Note that the '+' is a real, not integer '+' which cannot be 
     6      -32    determined until the final part of the expression is read. } 
     7      -32 {V3.0: New test. } 
     8      -32  
     9      -32 program t6p7p1d4(output); 
    10      -32 var 
    11      -32    x : real; 
    12      -32 begin 
    13        3 x := 1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+(1+2.0)))))))))))); 
    14       46 if abs(x - 15.0) <=  0.001 then 
    15       53    writeln(' QUALITY...6.7.1-4') 
    16       59 else 
    17       62    writeln(' FAIL...6.7.1-4') 
    18       68 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.7.1-4

program complete

Compiling and running t6p7p1d5

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.7.1-5, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test contains a deeply nested expression requiring 
     4      -32    temporary working store. } 
     5      -32 {V3.0: New test. } 
     6      -32  
     7      -32 program t6p7p1d5(output); 
     8      -32 var i, j, k : integer; 
     9      -32 begin 
    10        3 i := 2; 
    11        7 j := 3; 
    12        9 k := 5; 
    13       11 i := (((i + j) - (k + 3)) * ((k - j) + (i - 10))) + 
    14       26    (((i + j) mod(2 * k)) div((k + i) + (-3 * j))); 
    15       44 if i = 16 then 
    16       48    writeln(' QUALITY...6.7.1-5') 
    17       54 else 
    18       57    writeln(' FAIL...6.7.1-5') 
    19       63 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.7.1-5

program complete

Compiling and running t6p7p2p2d14

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.7.2.2-14, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks real division by using small integers. } 
     4      -32 {  Division of two integer-valued real quantities where the 
     5      -32    the true result is integer-valued is ideally exact. This 
     6      -32    is tested here using large integers divided by the primes 
     7      -32    2, 3, 5, 7, 11 and 13. For approximate division, a failure 
     8      -32    is indicated if the difference is more than 2 bits in the 
     9      -32    last place. } 
    10      -32 {V3.1: Machar changed. } 
    11      -32  
    12      -32 program t6p7p2p2d14(output); 
    13      -32  
    14      -32 const 
    15      -32    ntests = 50; 
    16      -32 var 
    17      -32    ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, 
    18      -32    maxexp: integer;  { integer parameters to machar } 
    19      -32    eps, epsneg, xmin, xmax: real;  { real parameters to machar } 
    20      -32    small, equal, big, maxr, i, j: integer; 
    21      -32    maxerror, xmaxerror, rmserror, rmaxr: real; 
    22      -32    failed, support: boolean; 
    23      -32  
    24      -32  
    25      -32 function forcestore(x: real): real; 
    26      -40    { see 'st' in 6.6.6.2-11 for details} 
    27      -40    var 
    28      -40       y: array[1..3] of real; 
    29      -64    begin 
    30        3    y[1] := x; y[2] := 0.0; y[3] := y[1] + y[2]; 
    31       38    y[1] := y[3]; forcestore := y[1] + y[2] 
    32       61    end; 
    33       65  
    34       65 procedure machar (var ibeta, it, irnd, ngrd, machep, negep, iexp, 
    35       65       minexp, maxexp: integer; var eps, epsneg, xmin, xmax: real); 
    36       65    { see 6.6.6.2-11 for details } 
    37       65    var 
    38      -84       i, iz, j, k, mx: integer; 
    39     -104       a, b, beta, betain, betam1, one, y, z, zero: real; 
    40     -176       underflo: boolean; 
    41     -177    function st(x: real): real; 
    42      -40       begin 
    43       65       st := forcestore(x); 
    44       71       end; 
    45       72  
    46       72    begin 
    47       72    one := 1.0; zero := 0.0; a := one + one; 
    48       82    while st(st(st(a + one) - a) - one) = zero do 
    49       98       a := a + a; 
    50      103    b := one + one; 
    51      107    while st(st(a + b) - a) = zero do 
    52      119       b := b + b; 
    53      124    ibeta := trunc (st(a + b) - a); beta := ibeta; 
    54      138    it := 0; b := one; 
    55      143    repeat 
    56      143       begin it := it + 1; b := b * beta end 
    57      153    until st(st(st(b + one) - b) - one) <> zero; 
    58      169    irnd := 0; 
    59      172    betam1 := beta - one; 
    60      176    if st(st((a + beta) + betam1) - (a + beta)) <> zero then 
    61      192       irnd := 1; 
    62      195    negep := it + 3; betain := one / beta; a := one; 
    63      207    for i := 1 to negep do 
    64      218       a := a * betain; 
    65      232    b := a; 
    66      234    while st(st(one - a) - one) = zero do 
    67      246       begin a := a * beta; negep := negep - 1 end; 
    68      257    negep := - negep; epsneg := a; 
    69      265    if (ibeta <> 2) and (irnd <> 0) then 
    70      275       begin 
    71      275       a := a * st(one + a) / (one + one); 
    72      287       if st(st(one - a) - one) <> zero then 
    73      299          epsneg := a; 
    74      302       end; 
    75      302    machep := - it - 3; a := b; 
    76      311    while st(st(one + a) - one) = zero do 
    77      323       begin a := a * beta; machep := machep + 1 end; 
    78      334    eps := a; 
    79      337    if (ibeta <> 2) and (irnd <> 0) then 
    80      347       begin 
    81      347       a := a * st(one + a) / (one + one); 
    82      359       if st(st(one + a) - one) <> zero then 
    83      371          eps := a; 
    84      374       end; 
    85      374    ngrd := 0; 
    86      377    if (irnd = 0) and (st(st(one + eps) * one - one) <> zero) then 
    87      397       ngrd := 1; 
    88      400    i := 0; k := 1; z := betain; underflo := false; 
    89      409    repeat 
    90      409       begin 
    91      409       y := z; z := y * y; a := z * one; 
    92      419       if (st(a + a) = zero) or (abs (z) >= y) then 
    93      432          underflo := true 
    94      432       else 
    95      436          begin i := i + 1; k := k + k end; 
    96      444       end 
    97      444    until underflo; 
    98      446    if ibeta <> 10 then 
    99      451       begin iexp := i + 1; mx := k + k end 
   100      460    else 
   101      461       begin iexp := 2; iz := ibeta; 
   102      467       while k >= iz do 
   103      471          begin iz := iz * ibeta; iexp := iexp + 1 end; 
   104      483       mx := iz + iz - 1; 
   105      489       end; 
   106      489    underflo := false; 
   107      492    repeat 
   108      492       begin 
   109      492       xmin := y; y := y * betain; a := y * one; 
   110      503       if (st(a + a) = zero) or (abs (y) >= xmin) 
   111      515             or (st(y * st(one + eps)) <= y) then 
   112      530          underflo := true 
   113      530       else 
   114      534          k := k + 1; 
   115      538       end 
   116      538    until underflo; 
   117      540    minexp := - k; 
   118      544    if (mx <= k + k - 3) and (ibeta <> 10) then 
   119      557       begin mx := mx + mx; iexp := iexp + 1 end; 
   120      567    maxexp := mx + minexp; i := maxexp + minexp; 
   121      579    if ibeta = 2 then 
   122      584       if (iexp = 8) and (it = 24) and (i = 4) then 
   123      598          maxexp := maxexp - 2 
   124      601       else if (iexp = 11) and (it = 53) and (i = 4) then 
   125      619          maxexp := maxexp - 2 
   126      622       else if i = 0 then 
   127      630          maxexp := maxexp - 1; 
   128      636    if i > 20 then 
   129      640       maxexp := maxexp - 1; 
   130      646    if a <> y then 
   131      650       maxexp := maxexp - 2; 
   132      656    xmax := one - epsneg; 
   133      662    if st(xmax * one) <> xmax then 
   134      672       xmax := one - st(beta * epsneg); 
   135      682    xmax := xmax / (beta * beta * beta * xmin); 
   136      695    i := maxexp + minexp + 3; 
   137      703    for j := 1 to i do 
   138      713       if ibeta = 2 then 
   139      718          xmax := xmax + xmax 
   140      721       else 
   141      726          xmax := xmax * beta; 
   142      742    end; 
   143      743  
   144      743  
   145      743  
   146      743  
   147      743  
   148      743  
   149      743 procedure testequal(x: real; ix: integer); 
   150      743 var 
   151      -44    relerror, y: real; 
   152      -60 begin 
   153      743    y := ix; 
   154      748    if x < y then 
   155      752       small := small + 1 
   156      753    else if x = y then 
   157      761       equal := equal + 1 
   158      762    else 
   159      766       big := big + 1; 
   160      770    relerror := abs( (x - y) / y ); 
   161      777    if relerror > maxerror then 
   162      781       begin 
   163      781       maxerror := relerror; 
   164      783       xmaxerror := x 
   165      783       end; 
   166      785    rmserror := rmserror + sqr(relerror) 
   167      788 end;  { testequal } 
   168      791  
   169      791 procedure printresults; 
   170      791 var 
   171      -32    loss, albeta, w: real;  { Limit for loss in accuracy } 
   172      -56 begin 
   173      791    { The limit for loss in accuracy corresponds to 
   174      791      2 bits for the Maximum Relative Error and to 
   175      791      half this for the Root Mean Square error. Such limits are 
   176      791      only exceeded by poor division hardware.  } 
   177      791    albeta := ln(ibeta); 
   178      797    loss := ln(4.0)/albeta; 
   179      802    rmserror := sqrt(rmserror/ntests); 
   180      808    writeln('  THE RESULT WAS TOO LARGE',big:5,' TIMES,'); 
   181      823    writeln('                 EQUAL', equal:9, ' TIMES, AND' ); 
   182      838    writeln('                 TOO SMALL',small:5,' TIMES.'); 
   183      853    writeln; 
   184      856    writeln('  THERE ARE', it:4, ' BASE', ibeta:4, 
   185      872       ' SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER' ); 
   186      878    if maxerror <> 0.0 then 
   187      882       begin 
   188      882       support := false; 
   189      885       w := ln(abs(maxerror))/albeta 
   190      888       end 
   191      891    else 
   192      892       w := -999.0; 
   193      895    writeln('  THE MAXIMUM RELATIVE ERROR OF',maxerror,'=', 
   194      907          ibeta:4,' ** ',w:7:2); 
   195      920    writeln('   OCCURRED FOR X =',xmaxerror); 
   196      931    if w + it < 0.0 then 
   197      938       w := 0.0 
   198      938    else 
   199      941       w := w + it; 
   200      946    writeln('   ESTIMATED LOSS OF BASE', ibeta:4, 
   201      955       ' SIGNIFICANT DIGITS IS', w:7:2); 
   202      965    if w > loss then 
   203      969       failed := true; 
   204      972    if rmserror <> 0.0 then 
   205      976       w := ln(abs(rmserror))/albeta 
   206      979    else 
   207      983       w := -999.0; 
   208      986    writeln('  ROOT-MEAN-SQUARE RELATIVE ERROR =',rmserror, 
   209      995          '=',ibeta:4,' ** ',w:7:2); 
   210     1011    if w + it < 0.0 then 
   211     1018       w := 0.0 
   212     1018    else 
   213     1021       w := w + it; 
   214     1026    writeln('   ESTIMATED LOSS OF BASE', ibeta:4, 
   215     1035       ' SIGNIFICANT DIGITS IS', w:7:2); 
   216     1045    if w > 0.5 * loss then 
   217     1051       failed := true; 
   218     1054    writeln 
   219     1054 end;   { printtestrun } 
   220     1058  
   221     1058 procedure divideby(d: integer); 
   222     1058 var 
   223      -36    upper, lower, i: integer; 
   224      -48 begin 
   225     1058    writeln(' TEST OF REAL DIVISION BY ', d); 
   226     1071    xmaxerror := 0.0; 
   227     1073    maxerror := 0.0; 
   228     1075    rmserror := 0.0; 
   229     1077    small := 0; 
   230     1079    equal := 0; 
   231     1081    big := 0; 
   232     1083    upper := maxr div d; 
   233     1087    lower := upper - ntests + 1; 
   234     1093    writeln('  IN RANGE ', lower*d, '..', upper*d); 
   235     1115    for i := lower to upper do 
   236     1125       begin 
   237     1125       testequal( (i*d) / d, i ); 
   238     1135       testequal( - (i*d) / d,  - i ) 
   239     1146       end; 
   240     1157    printresults 
   241     1157 end;  { divideby } 
   242     1160  
   243     1160 begin 
   244     1160    machar( ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, 
   245     1171       maxexp, eps, epsneg, xmin, xmax); 
   246     1177    failed := false; 
   247     1180    support := true; 
   248     1183    { Calculate maximum integer value with exact real value } 
   249     1183    if machep < negep then 
   250     1187       j := - machep 
   251     1187    else 
   252     1191       j := - negep; 
   253     1194    { Calculate ibeta ** j - 1 } 
   254     1194    rmaxr := ibeta - 1; 
   255     1199    for i := 2 to j do 
   256     1209      rmaxr := ibeta * rmaxr + (ibeta - 1); 
   257     1229    if rmaxr >= maxint then 
   258     1234       maxr := maxint 
   259     1234    else 
   260     1237       maxr := trunc(rmaxr); 
   261     1240    rmaxr := maxr; 
   262     1243    { Check trunc works with this value, if not reduce rmaxr } 
   263     1243    while trunc(rmaxr) <> rmaxr do 
   264     1249       rmaxr := trunc(rmaxr - 1.0); 
   265     1256    maxr := trunc(rmaxr); 
   266     1259    divideby(2); 
   267     1262    divideby(3); 
   268     1265    divideby(5); 
   269     1268    divideby(7); 
   270     1271    divideby(11); 
   271     1274    divideby(13); 
   272     1277    writeln(' OUTPUT FROM TEST...6.7.2.2-14'); 
   273     1285    if support then 
   274     1287       writeln(' REAL DIVISION IS SUPPORTED IN SENSE OF W S BROWN') 
   275     1293    else 
   276     1296       writeln(' REAL DIVISION IS APPROXIMATE'); 
   277     1304    if failed then 
   278     1306       writeln(' FAIL...6.7.2.2-14') 
   279     1312    else 
   280     1315       writeln(' QUALITY...6.7.2.2-14') 
   281     1321 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 TEST OF REAL DIVISION BY           2
  IN RANGE  2147483548.. 2147483646
  THE RESULT WAS TOO LARGE    0 TIMES,
                 EQUAL      100 TIMES, AND
                 TOO SMALL    0 TIMES.

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 0.000000000000000e+00=   2 ** -999.00
   OCCURRED FOR X = 0.000000000000000e+00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00
  ROOT-MEAN-SQUARE RELATIVE ERROR = 0.000000000000000e+00=   2 ** -999.00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 TEST OF REAL DIVISION BY           3
  IN RANGE  2147483499.. 2147483646
  THE RESULT WAS TOO LARGE    0 TIMES,
                 EQUAL      100 TIMES, AND
                 TOO SMALL    0 TIMES.

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 0.000000000000000e+00=   2 ** -999.00
   OCCURRED FOR X = 0.000000000000000e+00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00
  ROOT-MEAN-SQUARE RELATIVE ERROR = 0.000000000000000e+00=   2 ** -999.00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 TEST OF REAL DIVISION BY           5
  IN RANGE  2147483400.. 2147483645
  THE RESULT WAS TOO LARGE    0 TIMES,
                 EQUAL      100 TIMES, AND
                 TOO SMALL    0 TIMES.

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 0.000000000000000e+00=   2 ** -999.00
   OCCURRED FOR X = 0.000000000000000e+00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00
  ROOT-MEAN-SQUARE RELATIVE ERROR = 0.000000000000000e+00=   2 ** -999.00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 TEST OF REAL DIVISION BY           7
  IN RANGE  2147483303.. 2147483646
  THE RESULT WAS TOO LARGE    0 TIMES,
                 EQUAL      100 TIMES, AND
                 TOO SMALL    0 TIMES.

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 0.000000000000000e+00=   2 ** -999.00
   OCCURRED FOR X = 0.000000000000000e+00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00
  ROOT-MEAN-SQUARE RELATIVE ERROR = 0.000000000000000e+00=   2 ** -999.00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 TEST OF REAL DIVISION BY          11
  IN RANGE  2147483107.. 2147483646
  THE RESULT WAS TOO LARGE    0 TIMES,
                 EQUAL      100 TIMES, AND
                 TOO SMALL    0 TIMES.

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 0.000000000000000e+00=   2 ** -999.00
   OCCURRED FOR X = 0.000000000000000e+00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00
  ROOT-MEAN-SQUARE RELATIVE ERROR = 0.000000000000000e+00=   2 ** -999.00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 TEST OF REAL DIVISION BY          13
  IN RANGE  2147483000.. 2147483637
  THE RESULT WAS TOO LARGE    0 TIMES,
                 EQUAL      100 TIMES, AND
                 TOO SMALL    0 TIMES.

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 0.000000000000000e+00=   2 ** -999.00
   OCCURRED FOR X = 0.000000000000000e+00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00
  ROOT-MEAN-SQUARE RELATIVE ERROR = 0.000000000000000e+00=   2 ** -999.00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 OUTPUT FROM TEST...6.7.2.2-14
 REAL DIVISION IS SUPPORTED IN SENSE OF W S BROWN
 QUALITY...6.7.2.2-14

program complete

Compiling and running t6p7p2p2d15

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.7.2.2-15, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks real +, -, *, abs and sqr by requiring 
     4      -32    equality for small integer-valued operands. } 
     5      -32 {  The test checks that the operations +, -, *, abs and sqr 
     6      -32    applied to real operands whose values are small integers 
     7      -32    give exact results. To perform these checks, the minimum 
     8      -32    of maxint and the exact integer range of the reals must be 
     9      -32    found (maxr). Then computations with integers and reals 
    10      -32    in the range -maxr .. maxr are checked for equality. 
    11      -32    The correct functioning of trunc is assumed. } 
    12      -32 {V3.1: Machar changed. } 
    13      -32  
    14      -32 program t6p7p2p2d15(output); 
    15      -32  
    16      -32 type 
    17      -32    op = (add, sub, mul, absr, sqrr, neg, plus); 
    18      -32  
    19      -32 var 
    20      -32    ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, 
    21      -32    maxexp: integer;  { integer parameters to machar } 
    22      -32    eps, epsneg, xmin, xmax: real; { real parameters to machar } 
    23      -32    i, j, errorcount, maxr: integer; 
    24      -32    rmaxr: real; 
    25      -32  
    26      -32  
    27      -32  
    28      -32 function forcestore(x: real): real; 
    29      -40    { see 'st' in 6.6.6.2-11 for details} 
    30      -40    var 
    31      -40       y: array[1..3] of real; 
    32      -64    begin 
    33        3    y[1] := x; y[2] := 0.0; y[3] := y[1] + y[2]; 
    34       38    y[1] := y[3]; forcestore := y[1] + y[2] 
    35       61    end; 
    36       65  
    37       65 procedure machar (var ibeta, it, irnd, ngrd, machep, negep, iexp, 
    38       65       minexp, maxexp: integer; var eps, epsneg, xmin, xmax: real); 
    39       65    { see 6.6.6.2-11 for details } 
    40       65    var 
    41      -84       i, iz, j, k, mx: integer; 
    42     -104       a, b, beta, betain, betam1, one, y, z, zero: real; 
    43     -176       underflo: boolean; 
    44     -177    function st(x: real): real; 
    45      -40       begin 
    46       65       st := forcestore(x); 
    47       71       end; 
    48       72  
    49       72    begin 
    50       72    one := 1.0; zero := 0.0; a := one + one; 
    51       82    while st(st(st(a + one) - a) - one) = zero do 
    52       98       a := a + a; 
    53      103    b := one + one; 
    54      107    while st(st(a + b) - a) = zero do 
    55      119       b := b + b; 
    56      124    ibeta := trunc (st(a + b) - a); beta := ibeta; 
    57      138    it := 0; b := one; 
    58      143    repeat 
    59      143       begin it := it + 1; b := b * beta end 
    60      153    until st(st(st(b + one) - b) - one) <> zero; 
    61      169    irnd := 0; 
    62      172    betam1 := beta - one; 
    63      176    if st(st((a + beta) + betam1) - (a + beta)) <> zero then 
    64      192       irnd := 1; 
    65      195    negep := it + 3; betain := one / beta; a := one; 
    66      207    for i := 1 to negep do 
    67      218       a := a * betain; 
    68      232    b := a; 
    69      234    while st(st(one - a) - one) = zero do 
    70      246       begin a := a * beta; negep := negep - 1 end; 
    71      257    negep := - negep; epsneg := a; 
    72      265    if (ibeta <> 2) and (irnd <> 0) then 
    73      275       begin 
    74      275       a := a * st(one + a) / (one + one); 
    75      287       if st(st(one - a) - one) <> zero then 
    76      299          epsneg := a; 
    77      302       end; 
    78      302    machep := - it - 3; a := b; 
    79      311    while st(st(one + a) - one) = zero do 
    80      323       begin a := a * beta; machep := machep + 1 end; 
    81      334    eps := a; 
    82      337    if (ibeta <> 2) and (irnd <> 0) then 
    83      347       begin 
    84      347       a := a * st(one + a) / (one + one); 
    85      359       if st(st(one + a) - one) <> zero then 
    86      371          eps := a; 
    87      374       end; 
    88      374    ngrd := 0; 
    89      377    if (irnd = 0) and (st(st(one + eps) * one - one) <> zero) then 
    90      397       ngrd := 1; 
    91      400    i := 0; k := 1; z := betain; underflo := false; 
    92      409    repeat 
    93      409       begin 
    94      409       y := z; z := y * y; a := z * one; 
    95      419       if (st(a + a) = zero) or (abs (z) >= y) then 
    96      432          underflo := true 
    97      432       else 
    98      436          begin i := i + 1; k := k + k end; 
    99      444       end 
   100      444    until underflo; 
   101      446    if ibeta <> 10 then 
   102      451       begin iexp := i + 1; mx := k + k end 
   103      460    else 
   104      461       begin iexp := 2; iz := ibeta; 
   105      467       while k >= iz do 
   106      471          begin iz := iz * ibeta; iexp := iexp + 1 end; 
   107      483       mx := iz + iz - 1; 
   108      489       end; 
   109      489    underflo := false; 
   110      492    repeat 
   111      492       begin 
   112      492       xmin := y; y := y * betain; a := y * one; 
   113      503       if (st(a + a) = zero) or (abs (y) >= xmin) 
   114      515             or (st(y * st(one + eps)) <= y) then 
   115      530          underflo := true 
   116      530       else 
   117      534          k := k + 1; 
   118      538       end 
   119      538    until underflo; 
   120      540    minexp := - k; 
   121      544    if (mx <= k + k - 3) and (ibeta <> 10) then 
   122      557       begin mx := mx + mx; iexp := iexp + 1 end; 
   123      567    maxexp := mx + minexp; i := maxexp + minexp; 
   124      579    if ibeta = 2 then 
   125      584       if (iexp = 8) and (it = 24) and (i = 4) then 
   126      598          maxexp := maxexp - 2 
   127      601       else if (iexp = 11) and (it = 53) and (i = 4) then 
   128      619          maxexp := maxexp - 2 
   129      622       else if i = 0 then 
   130      630          maxexp := maxexp - 1; 
   131      636    if i > 20 then 
   132      640       maxexp := maxexp - 1; 
   133      646    if a <> y then 
   134      650       maxexp := maxexp - 2; 
   135      656    xmax := one - epsneg; 
   136      662    if st(xmax * one) <> xmax then 
   137      672       xmax := one - st(beta * epsneg); 
   138      682    xmax := xmax / (beta * beta * beta * xmin); 
   139      695    i := maxexp + minexp + 3; 
   140      703    for j := 1 to i do 
   141      713       if ibeta = 2 then 
   142      718          xmax := xmax + xmax 
   143      721       else 
   144      726          xmax := xmax * beta; 
   145      742    end; 
   146      743  
   147      743  
   148      743  
   149      743  
   150      743  
   151      743 procedure test(testop: op; op1, op2, result: integer); 
   152      743    var 
   153      -48       x, y, z: real; 
   154      -72    procedure equal(u, v: real); 
   155      -48       begin 
   156      743       if u <> v then 
   157      749          begin 
   158      749          errorcount := errorcount + 1; 
   159      753          if errorcount < 10 then 
   160      757             writeln(' ',ord(testop), x, y) 
   161      772          end 
   162      774    end; {equal} 
   163      775    begin 
   164      775    x := op1; 
   165      780    y := op2; 
   166      783    z := result; 
   167      786    equal(result, z); 
   168      791    case testop of 
   169      794       add: equal(x + y, z); 
   170      801       sub: equal(x - y, z); 
   171      808       mul: equal(x * y, z); 
   172      815       absr: equal( abs(x), z); 
   173      821       sqrr: equal( sqr(x), z); 
   174      827       neg: equal( - x, z); 
   175      833       plus: equal( + x, z) 
   176      836    end 
   177      849 end; {test} 
   178      850  
   179      850 begin 
   180      850    machar( ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, 
   181      861       maxexp, eps, epsneg, xmin, xmax); 
   182      867    if machep < negep then 
   183      871       j := - machep 
   184      871    else 
   185      875       j := - negep; 
   186      878    { Calculate ibeta ** j - 1 } 
   187      878    rmaxr := ibeta - 1; 
   188      883    for i := 2 to j do 
   189      893       rmaxr := ibeta * rmaxr + (ibeta - 1); 
   190      913    if rmaxr >= maxint then 
   191      918       maxr := maxint 
   192      918    else 
   193      921       maxr := trunc(rmaxr); 
   194      924    rmaxr := maxr; 
   195      927    { Check trunc works with this value, if not reduce rmaxr } 
   196      927    while trunc(rmaxr) <> rmaxr do 
   197      933       rmaxr := trunc(rmaxr - 1.0); 
   198      940    maxr := trunc(rmaxr); 
   199      943    errorcount := 0; 
   200      945    writeln(' TEST REALS AGAINST INTEGERS IN RANGE:'); 
   201      953    writeln(' ', - maxr, '..', maxr); 
   202      971    i := maxr div 2; 
   203      975    for j := 1 to 10 do 
   204      985       begin 
   205      985       test(add, i + j, - j, i); 
   206      995       test(add, - i, 2 * j, -(i - 2 * j) ); 
   207     1010       test(sub, i, j, i - j); 
   208     1019       test(sub, - i, j, -(i + j) ); 
   209     1030       test(mul, 1, -(i + j), -i - j); 
   210     1043       test(mul, -1, -(i - j), i - j); 
   211     1056       test(absr, - i, 0, i); 
   212     1064       test(absr, - j, 0, j); 
   213     1072       test(sqrr, j, 0, j * j); 
   214     1081       test(sqrr, - j, 0, j * j); 
   215     1091       test(neg, i, 0, - i); 
   216     1099       test(neg, - i - j, 0, i + j); 
   217     1111       test(plus, i + j, 0, i + j); 
   218     1122       test(plus, - i + j, 0, - i + j) 
   219     1134       end; 
   220     1145    for j := 0 to 10 do 
   221     1155       begin 
   222     1155       test(add, maxr - j, j, maxr); 
   223     1164       test(sub, maxr - j, - j, maxr); 
   224     1174       test(neg, maxr - j, 0, j - maxr); 
   225     1185       test(absr, - maxr + j, 0, maxr - j) 
   226     1196       end; 
   227     1207    i := trunc( sqrt(rmaxr) ); 
   228     1211    for j := 0 to 10 do 
   229     1221       begin 
   230     1221       test(mul, i - j, i, i * i - i * j); 
   231     1236       test(sqrr, i - j, 0, (i * i - 2 * i * j) + j * j) 
   232     1256       end; 
   233     1267  
   234     1267    if errorcount > 0 then 
   235     1271       writeln(' FAIL...6.7.2.2-15, (',errorcount,' TIMES)') 
   236     1284    else 
   237     1287       writeln(' QUALITY...6.7.2.2-15') 
   238     1293 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 TEST REALS AGAINST INTEGERS IN RANGE:
 -2147483647.. 2147483647
 QUALITY...6.7.2.2-15

program complete

Compiling and running t6p7p3d1

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.7.3-1, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks if deeply nested function calls are possible. } 
     4      -32 {V3.0: New test. } 
     5      -32  
     6      -32 program t6p7p3d1(output); 
     7      -32 var x: real; 
     8      -32 begin 
     9        3    x := sqrt(sqrt(sqrt(sqr(sqr(sqrt(16.0)))))); 
    10       13    if (x > 2.001) or (x < 1.999) then 
    11       21       writeln(' FAIL...6.7.3-1, NESTED FUNCTION CALLS (X = ',x,')') 
    12       33    else 
    13       36       writeln(' QUALITY...6.7.3-1') 
    14       42 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.7.3-1

program complete

Compiling and running t6p8p3p10d7

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.8.3.10-7, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that with-statements may be nested to 15 
     4      -32    levels. } 
     5      -32 {  The test may break a limit in some processors, particularly if a 
     6      -32    register is allocated for every selected variable. } 
     7      -32 {V3.0: Value check added. Write standardised. } 
     8      -32  
     9      -32 program t6p8p3p10d7(output); 
    10      -32 type 
    11      -32    rec1 = record 
    12      -32              i1:integer 
    13      -32            end; 
    14      -32    rec2 = record 
    15      -32              i2:integer 
    16      -32            end; 
    17      -32    rec3 = record 
    18      -32              i3:integer 
    19      -32            end; 
    20      -32    rec4 = record 
    21      -32              i4:integer 
    22      -32            end; 
    23      -32    rec5 = record 
    24      -32              i5:integer 
    25      -32            end; 
    26      -32    rec6 = record 
    27      -32              i6:integer 
    28      -32            end; 
    29      -32    rec7 = record 
    30      -32              i7:integer 
    31      -32            end; 
    32      -32    rec8 = record 
    33      -32              i8:integer 
    34      -32            end; 
    35      -32    rec9 = record 
    36      -32              i9:integer 
    37      -32            end; 
    38      -32    rec10 = record 
    39      -32              i10:integer 
    40      -32            end; 
    41      -32    rec11 = record 
    42      -32              i11:integer 
    43      -32            end; 
    44      -32    rec12 = record 
    45      -32              i12:integer 
    46      -32            end; 
    47      -32    rec13 = record 
    48      -32              i13:integer 
    49      -32            end; 
    50      -32    rec14 = record 
    51      -32              i14:integer 
    52      -32            end; 
    53      -32    rec15 = record 
    54      -32              i15:integer 
    55      -32            end; 
    56      -32    p1 = ^rec1; 
    57      -32    p2 = ^rec2; 
    58      -32    p3 = ^rec3; 
    59      -32    p4 = ^rec4; 
    60      -32    p5 = ^rec5; 
    61      -32    p6 = ^rec6; 
    62      -32    p7 = ^rec7; 
    63      -32    p8 = ^rec8; 
    64      -32    p9 = ^rec9; 
    65      -32    p10 = ^rec10; 
    66      -32    p11 = ^rec11; 
    67      -32    p12 = ^rec12; 
    68      -32    p13 = ^rec13; 
    69      -32    p14 = ^rec14; 
    70      -32    p15 = ^rec15; 
    71      -32 var 
    72      -32    ptr1 : p1; 
    73      -32    ptr2 : p2; 
    74      -32    ptr3 : p3; 
    75      -32    ptr4 : p4; 
    76      -32    ptr5 : p5; 
    77      -32    ptr6 : p6; 
    78      -32    ptr7 : p7; 
    79      -32    ptr8 : p8; 
    80      -32    ptr9 : p9; 
    81      -32    ptr10 : p10; 
    82      -32    ptr11 : p11; 
    83      -32    ptr12 : p12; 
    84      -32    ptr13 : p13; 
    85      -32    ptr14 : p14; 
    86      -32    ptr15 : p15; 
    87      -32 begin 
    88        3    new(ptr1); 
    89        8    new(ptr2); 
    90       11    new(ptr3); 
    91       14    new(ptr4); 
    92       17    new(ptr5); 
    93       20    new(ptr6); 
    94       23    new(ptr7); 
    95       26    new(ptr8); 
    96       29    new(ptr9); 
    97       32    new(ptr10); 
    98       35    new(ptr11); 
    99       38    new(ptr12); 
   100       41    new(ptr13); 
   101       44    new(ptr14); 
   102       47    new(ptr15); 
   103       50    with ptr1^ do 
   104       54       with ptr2^ do 
   105       58          with ptr3^ do 
   106       62             with ptr4^ do 
   107       66                with ptr5^ do 
   108       70                   with ptr6^ do 
   109       74                      with ptr7^ do 
   110       78                         with ptr8^ do 
   111       82                            with ptr9^ do 
   112       86                               with ptr10^ do 
   113       90                                  with ptr11^ do 
   114       94                                     with ptr12^ do 
   115       98                                        with ptr13^ do 
   116      102                                           with ptr14^ do 
   117      106                                              with ptr15^ do 
   118      110                                                   begin 
   119      110                                                   i1:=1; 
   120      113                                                   i2:=2; 
   121      116                                                   i3:=3; 
   122      119                                                   i4:=4; 
   123      122                                                   i5:=5; 
   124      125                                                   i6:=6; 
   125      128                                                   i7:=7; 
   126      131                                                   i8:=8; 
   127      134                                                   i9:=9; 
   128      137                                                   i10:=10; 
   129      140                                                   i11:=11; 
   130      143                                                   i12:=12; 
   131      146                                                   i13:=13; 
   132      149                                                   i14:=14; 
   133      152                                                   i15:=15 
   134      153                                                   end; 
   135      170    if (ptr1^.i1=1)and(ptr2^.i2=2)and(ptr3^.i3=3)and(ptr4^.i4=4)and 
   136      193       (ptr5^.i5=5)and(ptr6^.i6=6)and(ptr7^.i7=7)and(ptr8^.i8=8)and 
   137      217       (ptr9^.i9=9)and(ptr10^.i10=10)and(ptr11^.i11=11)and 
   138      235       (ptr12^.i12=12)and(ptr13^.i13=13)and(ptr14^.i14=14)and 
   139      253       (ptr15^.i15=15) then 
   140      260       writeln(' QUALITY...6.8.3.10-7') 
   141      266    else 
   142      269       writeln(' FAIL...6.8.3.10-7') 
   143      275 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.8.3.10-7

program complete

Compiling and running t6p8p3p2d1

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.8.3.2-1, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that deeply nested compound statements 
     4      -32    are permitted. } 
     5      -32 {V3.0: New test. } 
     6      -32  
     7      -32 program t6p8p3p2d1(output); 
     8      -32 var sum: integer; 
     9      -32 begin 
    10        3    sum := 0; 
    11        7      begin 
    12        7      sum := sum + 1; 
    13       11        begin 
    14       11        sum := sum + 1; 
    15       15          begin 
    16       15          sum := sum + 1; 
    17       19            begin 
    18       19            sum := sum + 1; 
    19       23              begin 
    20       23              sum := sum + 1; 
    21       27                begin 
    22       27                sum := sum + 1; 
    23       31                  begin 
    24       31                  sum := sum + 1; 
    25       35                    begin 
    26       35                    sum := sum + 1; 
    27       39                      begin 
    28       39                      sum := sum + 1; 
    29       43                        begin 
    30       43                        sum := sum + 1; 
    31       47                          begin 
    32       47                          sum := sum + 1; 
    33       51                            begin 
    34       51                            sum := sum + 1; 
    35       55                              begin 
    36       55                              sum := sum + 1; 
    37       59                                begin 
    38       59                                sum := sum + 1; 
    39       63                                  begin 
    40       63                                  sum := sum + 1; 
    41       67                                    begin 
    42       67                                    sum := sum + 1; 
    43       71                                      begin 
    44       71                                      sum := sum + 1; 
    45       75                                        begin 
    46       75                                        sum := sum + 1; 
    47       79                                          begin 
    48       79                                          sum := sum + 1; 
    49       83                                            begin 
    50       83                                            sum := sum + 1; 
    51       87                                              begin 
    52       87                                              sum := sum + 1; 
    53       91                                                begin 
    54       91                                                sum := sum + 1; 
    55       95                                                  begin 
    56       95                                                  sum := sum + 1; 
    57       99                                                    begin 
    58       99                                                    sum := sum + 1 
    59      100                                                    end 
    60      103                                                  end 
    61      103                                                end 
    62      103                                              end 
    63      103                                            end 
    64      103                                          end 
    65      103                                        end 
    66      103                                      end 
    67      103                                    end 
    68      103                                  end 
    69      103                                end 
    70      103                              end 
    71      103                            end 
    72      103                          end 
    73      103                        end 
    74      103                      end 
    75      103                    end 
    76      103                  end 
    77      103                end 
    78      103              end 
    79      103            end 
    80      103          end 
    81      103        end 
    82      103      end; 
    83      103    if sum <> 24 then 
    84      107      writeln(' FAIL...6.8.3.2-1') 
    85      113    else 
    86      116      writeln(' QUALITY...6.8.3.2-1') 
    87      122 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.8.3.2-1

program complete

Compiling and running t6p8p3p2d2

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.8.3.2-2, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that a procedure may have 300 statements. } 
     4      -32 {V3.0: New test. } 
     5      -32  
     6      -32 program t6p8p3p2d2(output); 
     7      -32 var 
     8      -32    a0, a1, a2, a3, a4, a5, a6, a7, a8, a9: integer; 
     9      -32 procedure permute; 
    10      -32    begin 
    11        3    a0:=a1; a1:=a2; a2:=a3; a3:=a4; a4:=a5; a5:=a6; a6:=a7; 
    12       19    a7:=a8; a8:=a9; a9:=a0; a0:=a8; a8:=a4; a4:=a6; a6:=a5; 
    13       33    a5:=a1; a1:=a2; a2:=a3; a3:=a9; a9:=a7; a7:=a0; a0:=a7; 
    14       47    a7:=a3; a3:=a2; a2:=a9; a9:=a8; a8:=a4; a4:=a5; a5:=a1; 
    15       61    a1:=a6; a6:=a0; a0:=a5; a5:=a7; a7:=a3; a3:=a4; a4:=a1; 
    16       75    a1:=a9; a9:=a2; a2:=a6; a6:=a8; a8:=a0; a0:=a8; a8:=a2; 
    17       89    a2:=a4; a4:=a1; a1:=a7; a7:=a5; a5:=a3; a3:=a9; a9:=a6; 
    18      103    a6:=a0; a0:=a6; a6:=a3; a3:=a2; a2:=a1; a1:=a8; a8:=a7; 
    19      117    a7:=a9; a9:=a5; a5:=a4; a4:=a0; a0:=a5; a5:=a4; a4:=a6; 
    20      131    a6:=a3; a3:=a8; a8:=a9; a9:=a1; a1:=a2; a2:=a7; a7:=a0; 
    21      145    a0:=a7; a7:=a5; a5:=a3; a3:=a4; a4:=a9; a9:=a1; a1:=a2; 
    22      159    a2:=a6; a6:=a8; a8:=a0; a0:=a9; a9:=a6; a6:=a8; a8:=a2; 
    23      173    a2:=a1; a1:=a3; a3:=a5; a5:=a4; a4:=a7; a7:=a0; a0:=a8; 
    24      187    a8:=a7; a7:=a6; a6:=a1; a1:=a4; a4:=a2; a2:=a5; a5:=a3; 
    25      201    a3:=a9; a9:=a0; a0:=a3; a3:=a9; a9:=a8; a8:=a6; a6:=a7; 
    26      215    a7:=a4; a4:=a1; a1:=a5; a5:=a2; a2:=a0; a0:=a7; a7:=a3; 
    27      229    a3:=a4; a4:=a2; a2:=a1; a1:=a9; a9:=a8; a8:=a6; a6:=a5; 
    28      243    a5:=a0; a0:=a4; a4:=a2; a2:=a1; a1:=a8; a8:=a9; a9:=a5; 
    29      257    a5:=a6; a6:=a3; a3:=a7; a7:=a0; a0:=a6; a6:=a5; a5:=a4; 
    30      271    a4:=a3; a3:=a9; a9:=a8; a8:=a1; a1:=a2; a2:=a7; a7:=a0; 
    31      285    a0:=a7; a7:=a9; a9:=a1; a1:=a3; a3:=a5; a5:=a2; a2:=a4; 
    32      299    a4:=a6; a6:=a8; a8:=a0; a0:=a5; a5:=a2; a2:=a3; a3:=a4; 
    33      313    a4:=a9; a9:=a6; a6:=a7; a7:=a8; a8:=a1; a1:=a0; a0:=a8; 
    34      327    a8:=a4; a4:=a6; a6:=a9; a9:=a5; a5:=a2; a2:=a3; a3:=a1; 
    35      341    a1:=a7; a7:=a0; a0:=a7; a7:=a3; a3:=a2; a2:=a1; a1:=a8; 
    36      355    a8:=a4; a4:=a9; a9:=a5; a5:=a6; a6:=a0; a0:=a9; a9:=a7; 
    37      369    a7:=a3; a3:=a4; a4:=a5; a5:=a1; a1:=a2; a2:=a6; a6:=a8; 
    38      383    a8:=a0; a0:=a8; a8:=a2; a2:=a4; a4:=a5; a5:=a7; a7:=a9; 
    39      397    a9:=a3; a3:=a1; a1:=a6; a6:=a0; a0:=a6; a6:=a3; a3:=a2; 
    40      411    a2:=a5; a5:=a8; a8:=a7; a7:=a1; a1:=a9; a9:=a4; a4:=a0; 
    41      425    a0:=a9; a9:=a4; a4:=a6; a6:=a3; a3:=a8; a8:=a1; a1:=a5; 
    42      439    a5:=a2; a2:=a7; a7:=a0; a0:=a7; a7:=a9; a9:=a3; a3:=a4; 
    43      453    a4:=a1; a1:=a5; a5:=a2; a2:=a6; a6:=a8; a8:=a0; a0:=a1; 
    44      467    a1:=a6; a6:=a8; a8:=a2; a2:=a5; a5:=a3; a3:=a9; a9:=a4; 
    45      481    a4:=a7; a7:=a0; a0:=a8; a8:=a7; a7:=a6; a6:=a5; a5:=a4; 
    46      495    a4:=a2; a2:=a9; a9:=a3; a3:=a1; a1:=a0; a0:=a3; a3:=a1; 
    47      509    a1:=a8; a8:=a6; a6:=a7; a7:=a4; a4:=a5; a5:=a9; a9:=a2; 
    48      523    a2:=a0; a0:=a7; a7:=a3; a3:=a4; a4:=a2; a2:=a5; a5:=a1; 
    49      537    a1:=a8; a8:=a6; a6:=a9; a9:=a0; a0:=a4; a4:=a2; a2:=a5; 
    50      551    a5:=a8; a8:=a1; a1:=a9; a9:=a6; a6:=a3; a3:=a7; a7:=a0; 
    51      565    a0:=a6; a6:=a9; a9:=a4; a4:=a3; a3:=a1; a1:=a8; a8:=a5; 
    52      579    a5:=a2; a2:=a7; a7:=a0; a0:=a7; a7:=a1; a1:=a5; a5:=a3; 
    53      593    a3:=a9; a9:=a2; a2:=a4; a4:=a6; a6:=a8; a8:=a0 
    54      603    end; 
    55      606 begin 
    56      606    a0 :=10; a1 := 1; a2 := 2; a3 := 3; a4 := 4; 
    57      618    a5 := 5; a6 := 6; a7 := 7; a8 := 8; a9 := 9; 
    58      628    permute; 
    59      630    if (a0 <> 1) or (a1 <> 9) or (a2 <> 5) or (a3 <> 2) or (a4 <> 7) or 
    60      649       (a5 <> 8) or (a6 <> 4) or (a7 <> 3) or (a8 <> 1) or (a9 <> 6) 
    61      668       then 
    62      670       writeln(' FAIL...6.8.3.2-2') 
    63      676    else 
    64      679       writeln(' QUALITY...6.8.3.2-2') 
    65      685 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.8.3.2-2

program complete

Compiling and running t6p8p3p4d2

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.8.3.4-2, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that deeply nested if-statements are 
     4      -32    permitted. } 
     5      -32 {V3.0: New test. } 
     6      -32  
     7      -32 program t6p8p3p4d2(output); 
     8      -32 var 
     9      -32    i, j, sum: integer; 
    10      -32 begin 
    11        3    i := 1; 
    12        7    j := 2; 
    13        9    sum := 0; 
    14       11    if i > j then 
    15       15      begin 
    16       15      end 
    17       15    else 
    18       16      begin 
    19       16      sum := sum + 1; 
    20       20      if i > j then 
    21       24        begin 
    22       24        end 
    23       24      else 
    24       25        begin 
    25       25        sum := sum + 1; 
    26       29        if i > j then 
    27       33          begin 
    28       33          end 
    29       33        else 
    30       34          begin 
    31       34          sum := sum + 1; 
    32       38          if i > j then 
    33       42            begin 
    34       42            end 
    35       42          else 
    36       43            begin 
    37       43            sum := sum + 1; 
    38       47            if i > j then 
    39       51              begin 
    40       51              end 
    41       51            else 
    42       52              begin 
    43       52              sum := sum + 1; 
    44       56              if i > j then 
    45       60                begin 
    46       60                end 
    47       60              else 
    48       61                begin 
    49       61                sum := sum + 1; 
    50       65                if i > j then 
    51       69                  begin 
    52       69                  end 
    53       69                else 
    54       70                  begin 
    55       70                  sum := sum + 1; 
    56       74                  if i > j then 
    57       78                    begin 
    58       78                    end 
    59       78                  else 
    60       79                    begin 
    61       79                    sum := sum + 1; 
    62       83                    if i > j then 
    63       87                      begin 
    64       87                      end 
    65       87                    else 
    66       88                      begin 
    67       88                      sum := sum + 1; 
    68       92                      if i > j then 
    69       96                        begin 
    70       96                        end 
    71       96                      else 
    72       97                        begin 
    73       97                        sum := sum + 1; 
    74      101                        if i > j then 
    75      105                          begin 
    76      105                          end 
    77      105                        else 
    78      106                          begin 
    79      106                          sum := sum + 1; 
    80      110                          if i > j then 
    81      114                            begin 
    82      114                            end 
    83      114                          else 
    84      115                            begin 
    85      115                            sum := sum + 1; 
    86      119                            if i > j then 
    87      123                              begin 
    88      123                              end 
    89      123                            else 
    90      124                              begin 
    91      124                              sum := sum + 1; 
    92      128                              if i > j then 
    93      132                                begin 
    94      132                                end 
    95      132                              else 
    96      133                                begin 
    97      133                                sum := sum + 1; 
    98      137                                if i > j then 
    99      141                                  begin 
   100      141                                  end 
   101      141                                else 
   102      142                                  begin 
   103      142                                  sum := sum + 1; 
   104      146                                  if i > j then 
   105      150                                    begin 
   106      150                                    end 
   107      150                                  else 
   108      151                                    begin 
   109      151                                    sum := sum + 1; 
   110      155                                    if i > j then 
   111      159                                      begin 
   112      159                                      end 
   113      159                                    else 
   114      160                                      begin 
   115      160                                      sum := sum + 1; 
   116      164                                      if i > j then 
   117      168                                        begin 
   118      168                                        end 
   119      168                                      else 
   120      169                                        begin 
   121      169                                        sum := sum + 1; 
   122      173                                        if i > j then 
   123      177                                          begin 
   124      177                                          end 
   125      177                                        else 
   126      178                                          begin 
   127      178                                          sum := sum + 1; 
   128      182                                          if i > j then 
   129      186                                            begin 
   130      186                                            end 
   131      186                                          else 
   132      187                                            begin 
   133      187                                            sum := sum + 1; 
   134      191                                            if i > j then 
   135      195                                              begin 
   136      195                                              end 
   137      195                                            else 
   138      196                                              begin 
   139      196                                              sum := sum + 1; 
   140      200                                              if i > j then 
   141      204                                                begin 
   142      204                                                end 
   143      204                                              else 
   144      205                                                begin 
   145      205                                                sum := sum + 1; 
   146      209                                                if i > j then 
   147      213                                                  begin 
   148      213                                                  end 
   149      213                                                else 
   150      214                                                  begin 
   151      214                                                  sum := sum + 1; 
   152      218                                                  if i > j then 
   153      222                                                    begin 
   154      222                                                    end 
   155      222                                                  else 
   156      223                                                    begin 
   157      223                                                    sum := sum + 1 
   158      224                                                    end 
   159      227                                                  end 
   160      227                                                end 
   161      227                                              end 
   162      227                                            end 
   163      227                                          end 
   164      227                                        end 
   165      227                                      end 
   166      227                                    end 
   167      227                                  end 
   168      227                                end 
   169      227                              end 
   170      227                            end 
   171      227                          end 
   172      227                        end 
   173      227                      end 
   174      227                    end 
   175      227                  end 
   176      227                end 
   177      227              end 
   178      227            end 
   179      227          end 
   180      227        end 
   181      227      end; 
   182      227    if sum <> 24 then 
   183      231      writeln(' FAIL...6.8.3.4-2') 
   184      237    else 
   185      240      writeln(' QUALITY...6.8.3.4-2') 
   186      246 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.8.3.4-2

program complete

Compiling and running t6p8p3p5d12

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.8.3.5-12, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks that the case-constants are of the same type 
     4      -32    as the case index. } 
     5      -32 {  A processor of good quality will detect that one path of the 
     6      -32    case statement cannot be taken. 
     7      -32    The case-index in this test is a subrange and the case-constants 
     8      -32    are of the base type. } 
     9      -32 {V3.1: Writes revised and comment changed. } 
    10      -32  
    11      -32 program t6p8p3p5d12(output); 
    12      -32 type 
    13      -32    day=(mon,tue,wed); 
    14      -32 var 
    15      -32    a:integer; 
    16      -32    d:mon..tue; 
    17      -32 begin 
    18        3    for d:=mon to tue do 
    19       18       case d of 
    20       21       mon: a:=1; 
    21       24       tue: a:=2; 
    22       27       wed: a:=3 
    23       27       end; 
    24       49    writeln(' WARNING COULD BE ISSUED HERE.'); 
    25       57    writeln(' QUALITY...6.8.3.5-12'); 
    26       65 end. 
day        unreferenced


Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 WARNING COULD BE ISSUED HERE.
 QUALITY...6.8.3.5-12

program complete

Compiling and running t6p8p3p5d13

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.8.3.5-13, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test contains a large case-statement to check that the 
     4      -32    limit on the size of code is not a serious one. } 
     5      -32 {  The processor has a small limit on the size of the 
     6      -32    case-statement if the program does not get to print 
     7      -32    QUALITY. } 
     8      -32 {V3.0: Comment and writes slightly altered. Was previously 
     9      -32    6.8.3.5-8. } 
    10      -32  
    11      -32 program t6p8p3p5d13(output); 
    12      -32 var 
    13      -32    sum:integer; 
    14      -32    i:0..255; 
    15      -32 begin 
    16        3    sum :=0; 
    17        7    for i:=0 to 255 do 
    18       18       case i of 
    19       20        0 : sum := sum + i; 
    20       25        1 : sum := sum + i; 
    21       30        2 : sum := sum + i; 
    22       35        3 : sum := sum + i; 
    23       40        4 : sum := sum + i; 
    24       45        5 : sum := sum + i; 
    25       50        6 : sum := sum + i; 
    26       55        7 : sum := sum + i; 
    27       60        8 : sum := sum + i; 
    28       65        9 : sum := sum + i; 
    29       70       10 : sum := sum + i; 
    30       75       11 : sum := sum + i; 
    31       80       12 : sum := sum + i; 
    32       85       13 : sum := sum + i; 
    33       90       14 : sum := sum + i; 
    34       95       15 : sum := sum + i; 
    35      100       16 : sum := sum + i; 
    36      105       17 : sum := sum + i; 
    37      110       18 : sum := sum + i; 
    38      115       19 : sum := sum + i; 
    39      120       20 : sum := sum + i; 
    40      125       21 : sum := sum + i; 
    41      130       22 : sum := sum + i; 
    42      135       23 : sum := sum + i; 
    43      140       24 : sum := sum + i; 
    44      145       25 : sum := sum + i; 
    45      150       26 : sum := sum + i; 
    46      155       27 : sum := sum + i; 
    47      160       28 : sum := sum + i; 
    48      165       29 : sum := sum + i; 
    49      170       30 : sum := sum + i; 
    50      175       31 : sum := sum + i; 
    51      180       32 : sum := sum + i; 
    52      185       33 : sum := sum + i; 
    53      190       34 : sum := sum + i; 
    54      195       35 : sum := sum + i; 
    55      200       36 : sum := sum + i; 
    56      205       37 : sum := sum + i; 
    57      210       38 : sum := sum + i; 
    58      215       39 : sum := sum + i; 
    59      220       40 : sum := sum + i; 
    60      225       41 : sum := sum + i; 
    61      230       42 : sum := sum + i; 
    62      235       43 : sum := sum + i; 
    63      240       44 : sum := sum + i; 
    64      245       45 : sum := sum + i; 
    65      250       46 : sum := sum + i; 
    66      255       47 : sum := sum + i; 
    67      260       48 : sum := sum + i; 
    68      265       49 : sum := sum + i; 
    69      270       50 : sum := sum + i; 
    70      275       51 : sum := sum + i; 
    71      280       52 : sum := sum + i; 
    72      285       53 : sum := sum + i; 
    73      290       54 : sum := sum + i; 
    74      295       55 : sum := sum + i; 
    75      300       56 : sum := sum + i; 
    76      305       57 : sum := sum + i; 
    77      310       58 : sum := sum + i; 
    78      315       59 : sum := sum + i; 
    79      320       60 : sum := sum + i; 
    80      325       61 : sum := sum + i; 
    81      330       62 : sum := sum + i; 
    82      335       63 : sum := sum + i; 
    83      340       64 : sum := sum + i; 
    84      345       65 : sum := sum + i; 
    85      350       66 : sum := sum + i; 
    86      355       67 : sum := sum + i; 
    87      360       68 : sum := sum + i; 
    88      365       69 : sum := sum + i; 
    89      370       70 : sum := sum + i; 
    90      375       71 : sum := sum + i; 
    91      380       72 : sum := sum + i; 
    92      385       73 : sum := sum + i; 
    93      390       74 : sum := sum + i; 
    94      395       75 : sum := sum + i; 
    95      400       76 : sum := sum + i; 
    96      405       77 : sum := sum + i; 
    97      410       78 : sum := sum + i; 
    98      415       79 : sum := sum + i; 
    99      420       80 : sum := sum + i; 
   100      425       81 : sum := sum + i; 
   101      430       82 : sum := sum + i; 
   102      435       83 : sum := sum + i; 
   103      440       84 : sum := sum + i; 
   104      445       85 : sum := sum + i; 
   105      450       86 : sum := sum + i; 
   106      455       87 : sum := sum + i; 
   107      460       88 : sum := sum + i; 
   108      465       89 : sum := sum + i; 
   109      470       90 : sum := sum + i; 
   110      475       91 : sum := sum + i; 
   111      480       92 : sum := sum + i; 
   112      485       93 : sum := sum + i; 
   113      490       94 : sum := sum + i; 
   114      495       95 : sum := sum + i; 
   115      500       96 : sum := sum + i; 
   116      505       97 : sum := sum + i; 
   117      510       98 : sum := sum + i; 
   118      515       99 : sum := sum + i; 
   119      520       100 : sum := sum + i; 
   120      525       101 : sum := sum + i; 
   121      530       102 : sum := sum + i; 
   122      535       103 : sum := sum + i; 
   123      540       104 : sum := sum + i; 
   124      545       105 : sum := sum + i; 
   125      550       106 : sum := sum + i; 
   126      555       107 : sum := sum + i; 
   127      560       108 : sum := sum + i; 
   128      565       109 : sum := sum + i; 
   129      570       110 : sum := sum + i; 
   130      575       111 : sum := sum + i; 
   131      580       112 : sum := sum + i; 
   132      585       113 : sum := sum + i; 
   133      590       114 : sum := sum + i; 
   134      595       115 : sum := sum + i; 
   135      600       116 : sum := sum + i; 
   136      605       117 : sum := sum + i; 
   137      610       118 : sum := sum + i; 
   138      615       119 : sum := sum + i; 
   139      620       120 : sum := sum + i; 
   140      625       121 : sum := sum + i; 
   141      630       122 : sum := sum + i; 
   142      635       123 : sum := sum + i; 
   143      640       124 : sum := sum + i; 
   144      645       125 : sum := sum + i; 
   145      650       126 : sum := sum + i; 
   146      655       127 : sum := sum + i; 
   147      660       128 : sum := sum + i; 
   148      665       129 : sum := sum + i; 
   149      670       130 : sum := sum + i; 
   150      675       131 : sum := sum + i; 
   151      680       132 : sum := sum + i; 
   152      685       133 : sum := sum + i; 
   153      690       134 : sum := sum + i; 
   154      695       135 : sum := sum + i; 
   155      700       136 : sum := sum + i; 
   156      705       137 : sum := sum + i; 
   157      710       138 : sum := sum + i; 
   158      715       139 : sum := sum + i; 
   159      720       140 : sum := sum + i; 
   160      725       141 : sum := sum + i; 
   161      730       142 : sum := sum + i; 
   162      735       143 : sum := sum + i; 
   163      740       144 : sum := sum + i; 
   164      745       145 : sum := sum + i; 
   165      750       146 : sum := sum + i; 
   166      755       147 : sum := sum + i; 
   167      760       148 : sum := sum + i; 
   168      765       149 : sum := sum + i; 
   169      770       150 : sum := sum + i; 
   170      775       151 : sum := sum + i; 
   171      780       152 : sum := sum + i; 
   172      785       153 : sum := sum + i; 
   173      790       154 : sum := sum + i; 
   174      795       155 : sum := sum + i; 
   175      800       156 : sum := sum + i; 
   176      805       157 : sum := sum + i; 
   177      810       158 : sum := sum + i; 
   178      815       159 : sum := sum + i; 
   179      820       160 : sum := sum + i; 
   180      825       161 : sum := sum + i; 
   181      830       162 : sum := sum + i; 
   182      835       163 : sum := sum + i; 
   183      840       164 : sum := sum + i; 
   184      845       165 : sum := sum + i; 
   185      850       166 : sum := sum + i; 
   186      855       167 : sum := sum + i; 
   187      860       168 : sum := sum + i; 
   188      865       169 : sum := sum + i; 
   189      870       170 : sum := sum + i; 
   190      875       171 : sum := sum + i; 
   191      880       172 : sum := sum + i; 
   192      885       173 : sum := sum + i; 
   193      890       174 : sum := sum + i; 
   194      895       175 : sum := sum + i; 
   195      900       176 : sum := sum + i; 
   196      905       177 : sum := sum + i; 
   197      910       178 : sum := sum + i; 
   198      915       179 : sum := sum + i; 
   199      920       180 : sum := sum + i; 
   200      925       181 : sum := sum + i; 
   201      930       182 : sum := sum + i; 
   202      935       183 : sum := sum + i; 
   203      940       184 : sum := sum + i; 
   204      945       185 : sum := sum + i; 
   205      950       186 : sum := sum + i; 
   206      955       187 : sum := sum + i; 
   207      960       188 : sum := sum + i; 
   208      965       189 : sum := sum + i; 
   209      970       190 : sum := sum + i; 
   210      975       191 : sum := sum + i; 
   211      980       192 : sum := sum + i; 
   212      985       193 : sum := sum + i; 
   213      990       194 : sum := sum + i; 
   214      995       195 : sum := sum + i; 
   215     1000       196 : sum := sum + i; 
   216     1005       197 : sum := sum + i; 
   217     1010       198 : sum := sum + i; 
   218     1015       199 : sum := sum + i; 
   219     1020       200 : sum := sum + i; 
   220     1025       201 : sum := sum + i; 
   221     1030       202 : sum := sum + i; 
   222     1035       203 : sum := sum + i; 
   223     1040       204 : sum := sum + i; 
   224     1045       205 : sum := sum + i; 
   225     1050       206 : sum := sum + i; 
   226     1055       207 : sum := sum + i; 
   227     1060       208 : sum := sum + i; 
   228     1065       209 : sum := sum + i; 
   229     1070       210 : sum := sum + i; 
   230     1075       211 : sum := sum + i; 
   231     1080       212 : sum := sum + i; 
   232     1085       213 : sum := sum + i; 
   233     1090       214 : sum := sum + i; 
   234     1095       215 : sum := sum + i; 
   235     1100       216 : sum := sum + i; 
   236     1105       217 : sum := sum + i; 
   237     1110       218 : sum := sum + i; 
   238     1115       219 : sum := sum + i; 
   239     1120       220 : sum := sum + i; 
   240     1125       221 : sum := sum + i; 
   241     1130       222 : sum := sum + i; 
   242     1135       223 : sum := sum + i; 
   243     1140       224 : sum := sum + i; 
   244     1145       225 : sum := sum + i; 
   245     1150       226 : sum := sum + i; 
   246     1155       227 : sum := sum + i; 
   247     1160       228 : sum := sum + i; 
   248     1165       229 : sum := sum + i; 
   249     1170       230 : sum := sum + i; 
   250     1175       231 : sum := sum + i; 
   251     1180       232 : sum := sum + i; 
   252     1185       233 : sum := sum + i; 
   253     1190       234 : sum := sum + i; 
   254     1195       235 : sum := sum + i; 
   255     1200       236 : sum := sum + i; 
   256     1205       237 : sum := sum + i; 
   257     1210       238 : sum := sum + i; 
   258     1215       239 : sum := sum + i; 
   259     1220       240 : sum := sum + i; 
   260     1225       241 : sum := sum + i; 
   261     1230       242 : sum := sum + i; 
   262     1235       243 : sum := sum + i; 
   263     1240       244 : sum := sum + i; 
   264     1245       245 : sum := sum + i; 
   265     1250       246 : sum := sum + i; 
   266     1255       247 : sum := sum + i; 
   267     1260       248 : sum := sum + i; 
   268     1265       249 : sum := sum + i; 
   269     1270       250 : sum := sum + i; 
   270     1275       251 : sum := sum + i; 
   271     1280       252 : sum := sum + i; 
   272     1285       253 : sum := sum + i; 
   273     1290       254 : sum := sum + i; 
   274     1295       255 : sum := sum + i 
   275     1296       end; 
   276     1571    if sum = 32640 then 
   277     1575       writeln(' QUALITY...6.8.3.5-13') 
   278     1581    else 
   279     1584       writeln(' FAIL...6.8.3.5-13') 
   280     1590 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.8.3.5-13

program complete

Compiling and running t6p8p3p5d14

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.8.3.5-14, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that 300 constants are allowed in a 
     4      -32    case-constant list. } 
     5      -32 {V3.0: New test. } 
     6      -32  
     7      -32 program t6p8p3p5d14(output); 
     8      -32 const 
     9      -32    limit = 300; 
    10      -32 var 
    11      -32    i, sum: integer; 
    12      -32 begin 
    13        3    sum := 0; 
    14        7    for i := -1 to limit + 4 do 
    15       20       case i of 
    16       22          -1, 0, 301, 302, 303, 304: ; 
    17       23          1, 2, 3, 4, 5, 6, 7, 8, 9, 
    18       23          10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 
    19       23          20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 
    20       23          30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 
    21       23          40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 
    22       23          50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 
    23       23          60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 
    24       23          70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 
    25       23          80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 
    26       23          90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 
    27       23          100,101,102,103,104,105,106,107,108,109, 
    28       23          110,111,112,113,114,115,116,117,118,119, 
    29       23          120,121,122,123,124,125,126,127,128,129, 
    30       23          130,131,132,133,134,135,136,137,138,139, 
    31       23          140,141,142,143,144,145,146,147,148,149, 
    32       23          150,151,152,153,154,155,156,157,158,159, 
    33       23          160,161,162,163,164,165,166,167,168,169, 
    34       23          170,171,172,173,174,175,176,177,178,179, 
    35       23          180,181,182,183,184,185,186,187,188,189, 
    36       23          190,191,192,193,194,195,196,197,198,199, 
    37       23          200,201,202,203,204,205,206,207,208,209, 
    38       23          210,211,212,213,214,215,216,217,218,219, 
    39       23          220,221,222,223,224,225,226,227,228,229, 
    40       23          230,231,232,233,234,235,236,237,238,239, 
    41       23          240,241,242,243,244,245,246,247,248,249, 
    42       23          250,251,252,253,254,255,256,257,258,259, 
    43       23          260,261,262,263,264,265,266,267,268,269, 
    44       23          270,271,272,273,274,275,276,277,278,279, 
    45       23          280,281,282,283,284,285,286,287,288,289, 
    46       23          290,291,292,293,294,295,296,297,298,299, 
    47       23             300:  sum := sum + 1 
    48       24       end; 
    49      348    if sum <> limit then 
    50      352       writeln(' FAIL...6.8.3.5-14') 
    51      358    else 
    52      361       writeln(' QUALITY...6.8.3.5-14') 
    53      367 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.8.3.5-14

program complete

Compiling and running t6p8p3p5d15

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.8.3.5-15, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that case-statements can be nested 
     4      -32    15 deep. } 
     5      -32 {V3.0: New test. } 
     6      -32  
     7      -32 program t6p8p3p5d15(output); 
     8      -32 var 
     9      -32    a, d: integer; 
    10      -32 begin 
    11        3    d := 31675; 
    12        7    a := 0; 
    13        9    case odd(d) of 
    14       13     true: 
    15       13       begin 
    16       13       d := d div 2;   {15837} 
    17       17       a := a + 1; 
    18       21       case odd(d) of 
    19       25        true: 
    20       25          begin 
    21       25          d := d div 2;   {7918} 
    22       29          a := a + 2; 
    23       33          case odd(d) of 
    24       37           true: ; 
    25       38           false: 
    26       38             begin 
    27       38             d := d div 2;   {3959} 
    28       42             case odd(d) of 
    29       46              true: 
    30       46                begin 
    31       46                d := d div 2;   {1979} 
    32       50                a := a + 8; 
    33       54                case odd(d) of 
    34       58                 true: 
    35       58                   begin 
    36       58                   d := d div 2;   {989} 
    37       62                   a := a + 16; 
    38       66                   case odd(d) of 
    39       70                    true: 
    40       70                      begin 
    41       70                      d := d div 2;  {494} 
    42       74                      a := a + 32; 
    43       78                      case odd(d) of 
    44       82                       true: ; 
    45       83                       false: 
    46       83                         begin 
    47       83                         d := d div 2;   {247} 
    48       87                         case odd(d) of 
    49       91                          true: 
    50       91                            begin 
    51       91                            d := d div 2;   {123} 
    52       95                            a := a + 128; 
    53       99                            case odd(d) of 
    54      103                             true: 
    55      103                               begin 
    56      103                               d := d div 2;  {61} 
    57      107                               a := a + 256; 
    58      111                               case odd(d) of 
    59      115                                true: 
    60      115                                  begin 
    61      115                                  d := d div 2;  {30} 
    62      119                                  a := a + 512; 
    63      123                                  case odd(d) of 
    64      127                                   true: ; 
    65      128                                   false: 
    66      128                                     begin 
    67      128                                     d := d div 2;  {15} 
    68      132                                     case odd(d) of 
    69      136                                      true: 
    70      136                                        begin 
    71      136                                        d := d div 2;  {7} 
    72      140                                        a := a + 2048; 
    73      144                                        case odd(d) of 
    74      148                                         true: 
    75      148                                           begin 
    76      148                                           d := d div 2; {3} 
    77      152                                           a := a + 4096; 
    78      156                                           case odd(d) of 
    79      160                                            true: 
    80      160                                              begin 
    81      160                                              d := d div 2; {1} 
    82      164                                              a := a + 8192; 
    83      168                                              case odd(d) of 
    84      172                                               true: a := a + 16384; 
    85      177                                               false: 
    86      177                                              end 
    87      184                                              end; 
    88      185                                            false: 
    89      185                                           end 
    90      192                                           end; 
    91      193                                         false: 
    92      193                                        end 
    93      200                                        end; 
    94      201                                      false: 
    95      201                                     end 
    96      208                                     end 
    97      208                                  end 
    98      215                                  end; 
    99      216                                false: 
   100      216                               end 
   101      223                               end; 
   102      224                             false: 
   103      224                            end 
   104      231                            end; 
   105      232                          false: 
   106      232                         end 
   107      239                         end 
   108      239                      end 
   109      246                      end; 
   110      247                    false: 
   111      247                   end 
   112      254                   end; 
   113      255                 false: 
   114      255                end 
   115      262                end; 
   116      263              false: 
   117      263             end 
   118      270             end 
   119      270          end 
   120      277          end; 
   121      278        false: 
   122      278       end 
   123      285       end; 
   124      286     false: 
   125      286    end; 
   126      293    if a = 31675 then 
   127      297       writeln(' QUALITY...6.8.3.5-15') 
   128      303    else 
   129      306       writeln(' FAIL...6.8.3.5-15') 
   130      312 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.8.3.5-15

program complete

Compiling and running t6p8p3p7d4

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.8.3.7-4, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that repeat-statements can be nested 
     4      -32    15 deep. } 
     5      -32 {V3.0: New test. } 
     6      -32  
     7      -32 program t6p8p3p7d4(output); 
     8      -32 var a0, a1, a2, a3, a4, a5, a6, 
     9      -32    a7, a8, a9, a10, a11, a12, a13, a14: integer; 
    10      -32    sum: integer; 
    11      -32 begin 
    12        3    sum := 0; 
    13        7    a0 := 1; 
    14        9       repeat 
    15        9       sum := sum + 1; 
    16       13       a1 := 1; 
    17       15          repeat 
    18       15          sum := sum + 1; 
    19       19          a2 := 1; 
    20       21             repeat 
    21       21             sum := sum + 1; 
    22       25             a3 := 1; 
    23       27                repeat 
    24       27                sum := sum + 1; 
    25       31                a4 := 1; 
    26       33                   repeat 
    27       33                   sum := sum + 1; 
    28       37                   a5 := 1; 
    29       39                      repeat 
    30       39                      sum := sum + 1; 
    31       43                      a6 := 1; 
    32       45                         repeat 
    33       45                         sum := sum + 1; 
    34       49                         a7 := 1; 
    35       51                            repeat 
    36       51                            sum := sum + 1; 
    37       55                            a8 := 1; 
    38       57                               repeat 
    39       57                               sum := sum + 1; 
    40       61                               a9 := 1; 
    41       63                                  repeat 
    42       63                                  sum := sum + 1; 
    43       67                                  a10 := 1; 
    44       69                                     repeat 
    45       69                                     sum := sum + 1; 
    46       73                                     a11 := 1; 
    47       75                                        repeat 
    48       75                                        sum := sum + 1; 
    49       79                                        a12 := 1; 
    50       81                                           repeat 
    51       81                                           sum := sum + 1; 
    52       85                                           a13 := 1; 
    53       87                                              repeat 
    54       87                                              sum := sum + 1; 
    55       91                                              a14 := 1; 
    56       93                                                 repeat 
    57       93                                                 sum := sum - 1; 
    58       97                                                 a14 := a14 + 1 
    59       98                                                 until a14 = 3; 
    60      105                                              a13 := a13 + 1 
    61      106                                              until a13 = 3; 
    62      113                                           a12 := a12 + 1 
    63      114                                           until a12 = 3; 
    64      121                                        a11 := a11 + 1 
    65      122                                        until a11 = 3; 
    66      129                                     a10 := a10 + 1 
    67      130                                     until a10 = 3; 
    68      137                                  a9 := a9 + 1 
    69      138                                  until a9 = 3; 
    70      145                               a8 := a8 + 1 
    71      146                               until a8 = 3; 
    72      153                            a7 := a7 + 1 
    73      154                            until a7 = 3; 
    74      161                         a6 := a6 + 1 
    75      162                         until a6 = 3; 
    76      169                      a5 := a5 + 1 
    77      170                      until a5 = 3; 
    78      177                   a4 := a4 + 1 
    79      178                   until a4 = 3; 
    80      185                a3 := a3 + 1 
    81      186                until a3 = 3; 
    82      193             a2 := a2 + 1 
    83      194             until a2 = 3; 
    84      201          a1 := a1 + 1 
    85      202          until a1 = 3; 
    86      209       a0 := a0 + 1 
    87      210       until a0 = 3; 
    88      217    if sum <> -2 then 
    89      222       writeln(' FAIL...6.8.3.7-4') 
    90      228    else 
    91      231       writeln(' QUALITY...6.8.3.7-4') 
    92      237 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.8.3.7-4

program complete

Compiling and running t6p8p3p8d3

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.8.3.8-3, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that while-statements can be nested 
     4      -32    15 deep. } 
     5      -32 {V3.0: New test. } 
     6      -32  
     7      -32 program t6p8p3p8d3(output); 
     8      -32 var 
     9      -32    a0, a1, a2, a3,  a4,  a5,  a6, 
    10      -32    a7, a8, a9, a10, a11, a12, a13, a14: integer; 
    11      -32    sum: integer; 
    12      -32 begin 
    13        3    sum := 0; 
    14        7    a0 := 1; 
    15        9    while a0 < 3 do 
    16       13      begin 
    17       13       sum := sum + 1; 
    18       17       a1 := 1; 
    19       19       while a1 < 3 do 
    20       23         begin 
    21       23          sum := sum + 1; 
    22       27          a2 := 1; 
    23       29          while a2 < 3 do 
    24       33            begin 
    25       33             sum := sum + 1; 
    26       37             a3 := 1; 
    27       39             while a3 < 3 do 
    28       43               begin 
    29       43                sum := sum + 1; 
    30       47                a4 := 1; 
    31       49                while a4 < 3 do 
    32       53                  begin 
    33       53                   sum := sum + 1; 
    34       57                   a5 := 1; 
    35       59                   while a5 < 3 do 
    36       63                     begin 
    37       63                      sum := sum + 1; 
    38       67                      a6 := 1; 
    39       69                      while a6 < 3 do 
    40       73                        begin 
    41       73                         sum := sum + 1; 
    42       77                         a7 := 1; 
    43       79                         while a7 < 3 do 
    44       83                           begin 
    45       83                            sum := sum + 1; 
    46       87                            a8 := 1; 
    47       89                            while a8 < 3 do 
    48       93                              begin 
    49       93                               sum := sum + 1; 
    50       97                               a9 := 1; 
    51       99                               while a9 < 3 do 
    52      103                                 begin 
    53      103                                  sum := sum + 1; 
    54      107                                  a10 := 1; 
    55      109                                  while a10 < 3 do 
    56      113                                     begin 
    57      113                                     sum := sum + 1; 
    58      117                                     a11 := 1; 
    59      119                                     while a11 < 3 do 
    60      123                                        begin 
    61      123                                        sum := sum + 1; 
    62      127                                        a12 := 1; 
    63      129                                        while a12 < 3 do 
    64      133                                           begin 
    65      133                                           sum := sum + 1; 
    66      137                                           a13 := 1; 
    67      139                                           while a13 < 3 do 
    68      143                                              begin 
    69      143                                              sum := sum + 1; 
    70      147                                              a14 := 1; 
    71      149                                              while a14 < 3 do 
    72      153                                                 begin 
    73      153                                                 sum := sum - 1; 
    74      157                                                 a14 := a14 + 1 
    75      158                                                 end; 
    76      162                                              a13 := a13 + 1 
    77      163                                              end; 
    78      167                                           a12 := a12 + 1 
    79      168                                           end; 
    80      172                                        a11 := a11 + 1 
    81      173                                        end; 
    82      177                                     a10 := a10 + 1 
    83      178                                     end; 
    84      182                                  a9 := a9 + 1 
    85      183                                  end; 
    86      187                               a8 := a8 + 1 
    87      188                               end; 
    88      192                            a7 := a7 + 1 
    89      193                            end; 
    90      197                         a6 := a6 + 1 
    91      198                         end; 
    92      202                      a5 := a5 + 1 
    93      203                      end; 
    94      207                   a4 := a4 + 1 
    95      208                   end; 
    96      212                a3 := a3 + 1 
    97      213                end; 
    98      217             a2 := a2 + 1 
    99      218             end; 
   100      222          a1 := a1 + 1 
   101      223          end; 
   102      227       a0 := a0 + 1 
   103      228       end; 
   104      232    if sum <> -2 then 
   105      237       writeln(' FAIL...6.8.3.8-3') 
   106      243    else 
   107      246       writeln(' QUALITY...6.8.3.8-3') 
   108      252 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.8.3.8-3

program complete

Compiling and running t6p8p3p9d20

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.8.3.9-20, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that for-statements can be nested 
     4      -32    15 deep. } 
     5      -32 {V3.0: Value check added. 
     6      -32    Extended nesting depth from 12 to 15. } 
     7      -32  
     8      -32 program t6p8p3p9d20(output); 
     9      -32 var a0, a1, a2, a3, a4, a5, a6, 
    10      -32    a7, a8, a9, a10, a11, a12, a13, a14: integer; 
    11      -32    sum: integer; 
    12      -32 begin 
    13        3    sum := 0; 
    14        7    for a0 := 1 to 2 do 
    15       17       begin 
    16       17       sum := sum + 1; 
    17       21       for a1 := 1 to 2 do 
    18       31          begin 
    19       31          sum := sum + 1; 
    20       35          for a2 := 1 to 2 do 
    21       45             begin 
    22       45             sum := sum + 1; 
    23       49             for a3 := 1 to 2 do 
    24       59                begin 
    25       59                sum := sum + 1; 
    26       63                for a4 := 1 to 2 do 
    27       73                   begin 
    28       73                   sum := sum + 1; 
    29       77                   for a5 := 1 to 2 do 
    30       87                      begin 
    31       87                      sum := sum + 1; 
    32       91                      for a6 := 1 to 2 do 
    33      101                         begin 
    34      101                         sum := sum + 1; 
    35      105                         for a7 := 1 to 2 do 
    36      115                            begin 
    37      115                            sum := sum + 1; 
    38      119                            for a8 := 1 to 2 do 
    39      129                               begin 
    40      129                               sum := sum + 1; 
    41      133                               for a9 := 1 to 2 do 
    42      143                                  begin 
    43      143                                  sum := sum + 1; 
    44      147                                  for a10 := 1 to 2 do 
    45      157                                     begin 
    46      157                                     sum := sum + 1; 
    47      161                                     for a11 := 1 to 2 do 
    48      171                                        begin 
    49      171                                        sum := sum + 1; 
    50      175                                        for a12 := 1 to 2 do 
    51      185                                           begin 
    52      185                                           sum := sum + 1; 
    53      189                                           for a13 := 1 to 2 do 
    54      199                                              begin 
    55      199                                              sum := sum + 1; 
    56      203                                              for a14 := 1 to 2 do 
    57      213                                                 begin 
    58      213                                                 sum := sum - 1 
    59      214                                                 end 
    60      217                                              end 
    61      227                                           end 
    62      237                                        end 
    63      247                                     end 
    64      257                                  end 
    65      267                               end 
    66      277                            end 
    67      287                         end 
    68      297                      end 
    69      307                   end 
    70      317                end 
    71      327             end 
    72      337          end 
    73      347       end; 
    74      367    if sum <> -2 then 
    75      372       writeln(' FAIL...6.8.3.9-20') 
    76      378    else 
    77      381       writeln(' QUALITY...6.8.3.9-20') 
    78      387 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.8.3.9-20

program complete

Compiling and running t6p9p1d6

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.9.1-6, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks the accuracy of read for reals. } 
     4      -32 {  Real values which can be exactly represented in the machine 
     5      -32    should be read into the machine exactly, i.e. without rounding 
     6      -32    error. This presents difficulty on a binary machine since 
     7      -32    the negative powers of two are exactly represented but have 
     8      -32    long decimal representations. This test writes I * (2**(-30)) 
     9      -32    for I = 1 .. 100 to a temporary file in decimal as 
    10      -32    characters strings and then reads them back, checking for 
    11      -32    the accuracy of the resulting value. The exponent and position 
    12      -32    of the decimal point are varied in the values written. 
    13      -32    A failure is indicated if the difference from the correct 
    14      -32    result is more than 3 bits in the last place. } 
    15      -32 {V3.1: Program parameter removed and number of items 
    16      -32    reduced from 1000 to 100. Machar changed. } 
    17      -32  
    18      -32 program t6p9p1d6(output); 
    19      -32 const 
    20      -32    items = 100; 
    21      -32 var 
    22      -32    tempfile: text; 
    23      -32    support, failed: boolean; 
    24      -32  
    25      -32 procedure writefile; 
    26      -32  
    27      -32 const 
    28      -32    length = 30; 
    29      -32    fract = '000000000931322574615478515625'; 
    30      -32  
    31      -32 type 
    32      -32    reg = packed array [1..length] of char; 
    33      -32  
    34      -32 var 
    35      -32    rfract, rreg: reg; 
    36      -92    i: 1..items; 
    37      -96  
    38      -96    procedure add; 
    39      -32    { Performs rreg := rreg + rfract } 
    40      -32    var 
    41      -32       carry: 0..1; 
    42      -36       d: 0..19; 
    43      -40       i: 1..length; 
    44      -44  
    45      -44    begin 
    46        3       carry := 0; 
    47        8       for i := length downto 1 do 
    48       19          begin 
    49       19             d := ord (rreg[i]) + ord (rfract[i]) + carry - 2 * 
    50       37                ord ('0'); 
    51       43             if d >= 10 
    52       44             then 
    53       47                begin 
    54       47                   carry := 1; 
    55       50                   rreg [i] := chr (d - 10 + ord ('0')) 
    56       62                end 
    57       64             else 
    58       65                begin 
    59       65                   carry := 0; 
    60       68                   rreg [i] := chr (d + ord ('0')) 
    61       78                end 
    62       80          end 
    63       80       end { add }; 
    64       92  
    65       92    procedure writerfract (exp: integer); 
    66       92    { writes one line with rfract using given exponent } 
    67       92    var 
    68      -36       i: integer; 
    69      -40    begin 
    70       92       for i := 1 to exp do 
    71      104          write(tempfile, rreg [i]); 
    72      124       write(tempfile, '.'); 
    73      129       for i := exp + 1 to length do 
    74      141          write(tempfile, rreg [i]); 
    75      161       i := exp; 
    76      163       writeln(tempfile, 'E-', chr ((i div 10) + ord ('0')), chr ( 
    77      177          (i mod 10) + ord ('0'))) 
    78      186    end { writerfract }; 
    79      189  
    80      189 begin { writefile } 
    81      189    rreg := fract; 
    82      194    rfract := fract; 
    83      197    for i := 1 to items do 
    84      208       begin 
    85      208          writerfract (i mod (length - 18) + 1); 
    86      217          add 
    87      217       end 
    88      219 end { writefile }; 
    89      231  
    90      231 procedure readfile; 
    91      231 var 
    92      -32    number, i: integer; 
    93      -40    small, equal, big: integer; 
    94      -52    rmserror, xmaxerror, maxerror: real; 
    95      -76    x, y: real; 
    96      -92    ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, maxexp: 
    97      -92       integer; 
    98     -128    eps, epsneg, xmin, xmax: real; 
    99     -160  
   100     -160  
   101     -160 function forcestore(x: real): real; 
   102      -40    { see 'st' in 6.6.6.2-11 for details} 
   103      -40    var 
   104      -40       y: array[1..3] of real; 
   105      -64    begin 
   106      231    y[1] := x; y[2] := 0.0; y[3] := y[1] + y[2]; 
   107      266    y[1] := y[3]; forcestore := y[1] + y[2] 
   108      289    end; 
   109      293  
   110      293 procedure machar (var ibeta, it, irnd, ngrd, machep, negep, iexp, 
   111      293       minexp, maxexp: integer; var eps, epsneg, xmin, xmax: real); 
   112      293    { see 6.6.6.2-11 for details } 
   113      293    var 
   114      -84       i, iz, j, k, mx: integer; 
   115     -104       a, b, beta, betain, betam1, one, y, z, zero: real; 
   116     -176       underflo: boolean; 
   117     -177    function st(x: real): real; 
   118      -40       begin 
   119      293       st := forcestore(x); 
   120      299       end; 
   121      300  
   122      300    begin 
   123      300    one := 1.0; zero := 0.0; a := one + one; 
   124      310    while st(st(st(a + one) - a) - one) = zero do 
   125      326       a := a + a; 
   126      331    b := one + one; 
   127      335    while st(st(a + b) - a) = zero do 
   128      347       b := b + b; 
   129      352    ibeta := trunc (st(a + b) - a); beta := ibeta; 
   130      366    it := 0; b := one; 
   131      371    repeat 
   132      371       begin it := it + 1; b := b * beta end 
   133      381    until st(st(st(b + one) - b) - one) <> zero; 
   134      397    irnd := 0; 
   135      400    betam1 := beta - one; 
   136      404    if st(st((a + beta) + betam1) - (a + beta)) <> zero then 
   137      420       irnd := 1; 
   138      423    negep := it + 3; betain := one / beta; a := one; 
   139      435    for i := 1 to negep do 
   140      446       a := a * betain; 
   141      460    b := a; 
   142      462    while st(st(one - a) - one) = zero do 
   143      474       begin a := a * beta; negep := negep - 1 end; 
   144      485    negep := - negep; epsneg := a; 
   145      493    if (ibeta <> 2) and (irnd <> 0) then 
   146      503       begin 
   147      503       a := a * st(one + a) / (one + one); 
   148      515       if st(st(one - a) - one) <> zero then 
   149      527          epsneg := a; 
   150      530       end; 
   151      530    machep := - it - 3; a := b; 
   152      539    while st(st(one + a) - one) = zero do 
   153      551       begin a := a * beta; machep := machep + 1 end; 
   154      562    eps := a; 
   155      565    if (ibeta <> 2) and (irnd <> 0) then 
   156      575       begin 
   157      575       a := a * st(one + a) / (one + one); 
   158      587       if st(st(one + a) - one) <> zero then 
   159      599          eps := a; 
   160      602       end; 
   161      602    ngrd := 0; 
   162      605    if (irnd = 0) and (st(st(one + eps) * one - one) <> zero) then 
   163      625       ngrd := 1; 
   164      628    i := 0; k := 1; z := betain; underflo := false; 
   165      637    repeat 
   166      637       begin 
   167      637       y := z; z := y * y; a := z * one; 
   168      647       if (st(a + a) = zero) or (abs (z) >= y) then 
   169      660          underflo := true 
   170      660       else 
   171      664          begin i := i + 1; k := k + k end; 
   172      672       end 
   173      672    until underflo; 
   174      674    if ibeta <> 10 then 
   175      679       begin iexp := i + 1; mx := k + k end 
   176      688    else 
   177      689       begin iexp := 2; iz := ibeta; 
   178      695       while k >= iz do 
   179      699          begin iz := iz * ibeta; iexp := iexp + 1 end; 
   180      711       mx := iz + iz - 1; 
   181      717       end; 
   182      717    underflo := false; 
   183      720    repeat 
   184      720       begin 
   185      720       xmin := y; y := y * betain; a := y * one; 
   186      731       if (st(a + a) = zero) or (abs (y) >= xmin) 
   187      743             or (st(y * st(one + eps)) <= y) then 
   188      758          underflo := true 
   189      758       else 
   190      762          k := k + 1; 
   191      766       end 
   192      766    until underflo; 
   193      768    minexp := - k; 
   194      772    if (mx <= k + k - 3) and (ibeta <> 10) then 
   195      785       begin mx := mx + mx; iexp := iexp + 1 end; 
   196      795    maxexp := mx + minexp; i := maxexp + minexp; 
   197      807    if ibeta = 2 then 
   198      812       if (iexp = 8) and (it = 24) and (i = 4) then 
   199      826          maxexp := maxexp - 2 
   200      829       else if (iexp = 11) and (it = 53) and (i = 4) then 
   201      847          maxexp := maxexp - 2 
   202      850       else if i = 0 then 
   203      858          maxexp := maxexp - 1; 
   204      864    if i > 20 then 
   205      868       maxexp := maxexp - 1; 
   206      874    if a <> y then 
   207      878       maxexp := maxexp - 2; 
   208      884    xmax := one - epsneg; 
   209      890    if st(xmax * one) <> xmax then 
   210      900       xmax := one - st(beta * epsneg); 
   211      910    xmax := xmax / (beta * beta * beta * xmin); 
   212      923    i := maxexp + minexp + 3; 
   213      931    for j := 1 to i do 
   214      941       if ibeta = 2 then 
   215      946          xmax := xmax + xmax 
   216      949       else 
   217      954          xmax := xmax * beta; 
   218      970    end; 
   219      971  
   220      971  
   221      971  
   222      971  
   223      971  
   224      971 procedure testequal (x, y: real); 
   225      971 var 
   226      -48    relerror: real; 
   227      -56 begin 
   228      971    if x < y 
   229      974    then 
   230      977       small := small + 1 
   231      978    else 
   232      982       if x = y 
   233      983       then 
   234      986          equal := equal + 1 
   235      987       else 
   236      991          big := big + 1; 
   237      995    relerror := abs ((x - y) / y); 
   238     1002    if relerror > maxerror then 
   239     1006       begin 
   240     1006          maxerror := relerror; 
   241     1008          xmaxerror := x 
   242     1008       end; 
   243     1010    rmserror := rmserror + sqr (relerror) 
   244     1013 end { testequal }; 
   245     1016  
   246     1016 procedure printresults; 
   247     1016 var 
   248      -32    loss, albeta, w: real; 
   249      -56    { Limit for loss in accuracy } 
   250      -56 begin { The limit for loss in accuracy corresponds to 
   251     1016      3 bits for the Maximum Relative Error and to 
   252     1016      half this for the Root Mean Square error. Such limits are 
   253     1016      only exceeded by poor read routines. } 
   254     1016    albeta := ln (ibeta); 
   255     1022    loss := ln (8.0) / albeta; 
   256     1027    rmserror := sqrt (rmserror / items); 
   257     1033    writeln('  THE RESULT WAS TOO LARGE', big:5, ' TIMES,'); 
   258     1048    writeln('                 EQUAL', equal:9, ' TIMES, AND'); 
   259     1063    writeln('                 TOO SMALL', small:5, ' TIMES.'); 
   260     1078    writeln; 
   261     1081    writeln('  THERE ARE', it: 4, ' BASE', ibeta: 4, 
   262     1097       ' SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER'); 
   263     1103    if maxerror <> 0.0 
   264     1104    then 
   265     1107       begin 
   266     1107          support := false; 
   267     1110          w := ln (abs (maxerror)) / albeta 
   268     1113       end 
   269     1116    else 
   270     1117       w := - 999.0; 
   271     1120    writeln('  THE MAXIMUM RELATIVE ERROR OF', maxerror, '=', 
   272     1132       ibeta: 4, ' ** ', w: 7: 2); 
   273     1145    writeln('   OCCURRED FOR X =', xmaxerror); 
   274     1156    if w + it < 0.0 
   275     1160    then 
   276     1163       w := 0.0 
   277     1163    else 
   278     1166       w := w + it; 
   279     1171    writeln('   ESTIMATED LOSS OF BASE', ibeta: 4, 
   280     1180       ' SIGNIFICANT DIGITS IS', w: 7: 2); 
   281     1190    if w > loss then 
   282     1194       failed := true; 
   283     1197    if rmserror <> 0.0 
   284     1198    then 
   285     1201       w := ln (abs (rmserror)) / albeta 
   286     1204    else 
   287     1208       w := - 999.0; 
   288     1211    writeln('  ROOT-MEAN-SQUARE RELATIVE ERROR =', rmserror, 
   289     1220       '=', ibeta: 4, ' ** ', w: 7: 2); 
   290     1236    if w + it < 0.0 
   291     1240    then 
   292     1243       w := 0.0 
   293     1243    else 
   294     1246       w := w + it; 
   295     1251    writeln('   ESTIMATED LOSS OF BASE', ibeta: 4, 
   296     1260       ' SIGNIFICANT DIGITS IS', w: 7: 2); 
   297     1270    if w > 0.5 * loss then 
   298     1276       failed := true; 
   299     1279    writeln 
   300     1279 end { printresults }; 
   301     1283  
   302     1283 begin { readfile } 
   303     1283    machar (ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, 
   304     1294       maxexp, eps, epsneg, xmin, xmax); 
   305     1300    small := 0; 
   306     1302    equal := 0; 
   307     1304    big := 0; 
   308     1306    rmserror := 0.0; 
   309     1308    maxerror := 0.0; 
   310     1310    xmaxerror := 0.0; 
   311     1312    y := 0.5; 
   312     1314    for i := 1 to 29 do 
   313     1324       y := 0.5 * y; 
   314     1338    for number := 1 to items do 
   315     1348       begin 
   316     1348          read (tempfile, x); 
   317     1352          testequal (x, number * y) 
   318     1358       end; 
   319     1369    writeln(' TEST ACCURACY OF READ FOR REALS'); 
   320     1377    printresults 
   321     1377 end { readfile }; 
   322     1380  
   323     1380  
   324     1380 begin { Main program } 
   325     1380    support := true; 
   326     1385    failed := false; 
   327     1388    rewrite(tempfile); 
   328     1390    writefile; 
   329     1392    reset(tempfile); 
   330     1394    readfile; 
   331     1396    writeln(' OUTPUT FROM TEST...6.9.1-6'); 
   332     1404    if support 
   333     1404    then 
   334     1406       writeln(' READ OF REALS SUPPORTED IN SENSE OF W S BROWN') 
   335     1412    else 
   336     1415       writeln(' READ OF REALS IS APPROXIMATE'); 
   337     1423    if failed 
   338     1423    then 
   339     1425       writeln(' FAIL...6.9.1-6') 
   340     1431    else 
   341     1434       writeln(' QUALITY...6.9.1-6') 
   342     1440 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 TEST ACCURACY OF READ FOR REALS
  THE RESULT WAS TOO LARGE   20 TIMES,
                 EQUAL       36 TIMES, AND
                 TOO SMALL   44 TIMES.

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 3.304849933767908e-16=   2 **  -51.43
   OCCURRED FOR X = 4.004687070846556e-08
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   1.57
  ROOT-MEAN-SQUARE RELATIVE ERROR = 1.438154498969476e-16=   2 **  -52.63
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.37

 OUTPUT FROM TEST...6.9.1-6
 READ OF REALS IS APPROXIMATE
 QUALITY...6.9.1-6

program complete

Compiling and running t6p9p1d7

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.9.1-7, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that a list of 30 variable-accesses can 
     4      -32    appear in a read parameter list. } 
     5      -32 {V3.1: Program parameter removed. } 
     6      -32  
     7      -32 program t6p9p1d7(output); 
     8      -32 const 
     9      -32    str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123'; 
    10      -32 var 
    11      -32     c00, c01, c02, c03, c04, c05, c06, c07, c08, c09, 
    12      -32     c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, 
    13      -32     c20, c21, c22, c23, c24, c25, c26, c27, c28, c29 
    14      -32       : char; 
    15      -32    tempfile: text; 
    16      -32 begin 
    17        3    rewrite(tempfile); 
    18        7    writeln(tempfile, str); 
    19       14    reset(tempfile); 
    20       16    read(tempfile, 
    21       17        c00, c01, c02, c03, c04, c05, c06, c07, c08, c09, 
    22       57        c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, 
    23       97        c20, c21, c22, c23, c24, c25, c26, c27, c28, c29); 
    24      138    if (c00 <> 'A') or (c01 <> 'B') or (c02 <> 'C') or 
    25      149       (c03 <> 'D') or (c04 <> 'E') or (c05 <> 'F') or 
    26      161       (c06 <> 'G') or (c07 <> 'H') or (c08 <> 'I') or 
    27      173       (c09 <> 'J') or (c10 <> 'K') or (c11 <> 'L') or 
    28      185       (c12 <> 'M') or (c13 <> 'N') or (c14 <> 'O') or 
    29      197       (c15 <> 'P') or (c16 <> 'Q') or (c17 <> 'R') or 
    30      209       (c18 <> 'S') or (c19 <> 'T') or (c20 <> 'U') or 
    31      221       (c21 <> 'V') or (c22 <> 'W') or (c23 <> 'X') or 
    32      233       (c24 <> 'Y') or (c25 <> 'Z') or (c26 <> '0') or 
    33      245       (c27 <> '1') or (c28 <> '2') or (c29 <> '3') then 
    34      258       writeln(' FAIL...6.9.1-7') 
    35      264    else 
    36      267       writeln(' QUALITY...6.9.1-7') 
    37      273 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.9.1-7

program complete

Compiling and running t6p9p1d8

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.9.1-8, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks the accuracy of copying reals. } 
     4      -32 {  Real values which can be exactly represented in the machine 
     5      -32    should be read into the machine exactly, i.e. without rounding 
     6      -32    error. This presents difficulty on a binary machine since 
     7      -32    the negative powers of two are exactly represented but have 
     8      -32    long decimal representations. This test writes I * (2**(-30)) 
     9      -32    for I = 1 .. 50 to a temporary file in decimal as 
    10      -32    character strings. Then the file is copied 50 times and 
    11      -32    then read back, checking for 
    12      -32    the accuracy of the resulting value. The exponent and position 
    13      -32    of the decimal point are varied in the values written. 
    14      -32    A failure is indicated if the difference from the correct 
    15      -32    result is more than 5 bits in the last place. } 
    16      -32 {V3.1: Program parameter removed and number of 
    17      -32    items reduced from 100 to 50. Machar changed. } 
    18      -32  
    19      -32 program t6p9p1d8(output); 
    20      -32 const 
    21      -32    items = 50; 
    22      -32    copies = 50; 
    23      -32 var 
    24      -32    tempfile: text; 
    25      -32    support, failed: boolean; 
    26      -32    i: 1 .. copies; 
    27      -32  
    28      -32 procedure writefile; 
    29      -32 var 
    30      -32    y: real; 
    31      -40    i, number: integer; 
    32      -48 begin 
    33        3    y := 0.5; 
    34        7    for i := 1 to 29 do 
    35       17      y := 0.5 * y; 
    36       31    for number := 1 to items do 
    37       41      writeln(tempfile, number * y: 33: 30) 
    38       49 end { writefile }; 
    39       62  
    40       62 procedure readfile; 
    41       62 var 
    42      -32    number, i: integer; 
    43      -40    small, equal, big: integer; 
    44      -52    rmserror, xmaxerror, maxerror: real; 
    45      -76    x, y: real; 
    46      -92    ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, maxexp: 
    47      -92       integer; 
    48     -128    eps, epsneg, xmin, xmax: real; 
    49     -160  
    50     -160 function forcestore(x: real): real; 
    51      -40    { see 'st' in 6.6.6.2-11 for details} 
    52      -40    var 
    53      -40       y: array[1..3] of real; 
    54      -64    begin 
    55       62    y[1] := x; y[2] := 0.0; y[3] := y[1] + y[2]; 
    56       97    y[1] := y[3]; forcestore := y[1] + y[2] 
    57      120    end; 
    58      124  
    59      124 procedure machar (var ibeta, it, irnd, ngrd, machep, negep, iexp, 
    60      124       minexp, maxexp: integer; var eps, epsneg, xmin, xmax: real); 
    61      124    { see 6.6.6.2-11 for details } 
    62      124    var 
    63      -84       i, iz, j, k, mx: integer; 
    64     -104       a, b, beta, betain, betam1, one, y, z, zero: real; 
    65     -176       underflo: boolean; 
    66     -177    function st(x: real): real; 
    67      -40       begin 
    68      124       st := forcestore(x); 
    69      130       end; 
    70      131  
    71      131    begin 
    72      131    one := 1.0; zero := 0.0; a := one + one; 
    73      141    while st(st(st(a + one) - a) - one) = zero do 
    74      157       a := a + a; 
    75      162    b := one + one; 
    76      166    while st(st(a + b) - a) = zero do 
    77      178       b := b + b; 
    78      183    ibeta := trunc (st(a + b) - a); beta := ibeta; 
    79      197    it := 0; b := one; 
    80      202    repeat 
    81      202       begin it := it + 1; b := b * beta end 
    82      212    until st(st(st(b + one) - b) - one) <> zero; 
    83      228    irnd := 0; 
    84      231    betam1 := beta - one; 
    85      235    if st(st((a + beta) + betam1) - (a + beta)) <> zero then 
    86      251       irnd := 1; 
    87      254    negep := it + 3; betain := one / beta; a := one; 
    88      266    for i := 1 to negep do 
    89      277       a := a * betain; 
    90      291    b := a; 
    91      293    while st(st(one - a) - one) = zero do 
    92      305       begin a := a * beta; negep := negep - 1 end; 
    93      316    negep := - negep; epsneg := a; 
    94      324    if (ibeta <> 2) and (irnd <> 0) then 
    95      334       begin 
    96      334       a := a * st(one + a) / (one + one); 
    97      346       if st(st(one - a) - one) <> zero then 
    98      358          epsneg := a; 
    99      361       end; 
   100      361    machep := - it - 3; a := b; 
   101      370    while st(st(one + a) - one) = zero do 
   102      382       begin a := a * beta; machep := machep + 1 end; 
   103      393    eps := a; 
   104      396    if (ibeta <> 2) and (irnd <> 0) then 
   105      406       begin 
   106      406       a := a * st(one + a) / (one + one); 
   107      418       if st(st(one + a) - one) <> zero then 
   108      430          eps := a; 
   109      433       end; 
   110      433    ngrd := 0; 
   111      436    if (irnd = 0) and (st(st(one + eps) * one - one) <> zero) then 
   112      456       ngrd := 1; 
   113      459    i := 0; k := 1; z := betain; underflo := false; 
   114      468    repeat 
   115      468       begin 
   116      468       y := z; z := y * y; a := z * one; 
   117      478       if (st(a + a) = zero) or (abs (z) >= y) then 
   118      491          underflo := true 
   119      491       else 
   120      495          begin i := i + 1; k := k + k end; 
   121      503       end 
   122      503    until underflo; 
   123      505    if ibeta <> 10 then 
   124      510       begin iexp := i + 1; mx := k + k end 
   125      519    else 
   126      520       begin iexp := 2; iz := ibeta; 
   127      526       while k >= iz do 
   128      530          begin iz := iz * ibeta; iexp := iexp + 1 end; 
   129      542       mx := iz + iz - 1; 
   130      548       end; 
   131      548    underflo := false; 
   132      551    repeat 
   133      551       begin 
   134      551       xmin := y; y := y * betain; a := y * one; 
   135      562       if (st(a + a) = zero) or (abs (y) >= xmin) 
   136      574             or (st(y * st(one + eps)) <= y) then 
   137      589          underflo := true 
   138      589       else 
   139      593          k := k + 1; 
   140      597       end 
   141      597    until underflo; 
   142      599    minexp := - k; 
   143      603    if (mx <= k + k - 3) and (ibeta <> 10) then 
   144      616       begin mx := mx + mx; iexp := iexp + 1 end; 
   145      626    maxexp := mx + minexp; i := maxexp + minexp; 
   146      638    if ibeta = 2 then 
   147      643       if (iexp = 8) and (it = 24) and (i = 4) then 
   148      657          maxexp := maxexp - 2 
   149      660       else if (iexp = 11) and (it = 53) and (i = 4) then 
   150      678          maxexp := maxexp - 2 
   151      681       else if i = 0 then 
   152      689          maxexp := maxexp - 1; 
   153      695    if i > 20 then 
   154      699       maxexp := maxexp - 1; 
   155      705    if a <> y then 
   156      709       maxexp := maxexp - 2; 
   157      715    xmax := one - epsneg; 
   158      721    if st(xmax * one) <> xmax then 
   159      731       xmax := one - st(beta * epsneg); 
   160      741    xmax := xmax / (beta * beta * beta * xmin); 
   161      754    i := maxexp + minexp + 3; 
   162      762    for j := 1 to i do 
   163      772       if ibeta = 2 then 
   164      777          xmax := xmax + xmax 
   165      780       else 
   166      785          xmax := xmax * beta; 
   167      801    end; 
   168      802  
   169      802  
   170      802  
   171      802  
   172      802  
   173      802  
   174      802 procedure testequal (x, y: real); 
   175      802 var 
   176      -48    relerror: real; 
   177      -56 begin 
   178      802    if x < y 
   179      805    then 
   180      808       small := small + 1 
   181      809    else 
   182      813       if x = y 
   183      814       then 
   184      817          equal := equal + 1 
   185      818       else 
   186      822          big := big + 1; 
   187      826    relerror := abs ((x - y) / y); 
   188      833    if relerror > maxerror then 
   189      837       begin 
   190      837          maxerror := relerror; 
   191      839          xmaxerror := x 
   192      839       end; 
   193      841    rmserror := rmserror + sqr (relerror) 
   194      844 end { testequal }; 
   195      847  
   196      847 procedure printresults; 
   197      847 var 
   198      -32    loss, albeta, w: real; 
   199      -56    { Limit for loss in accuracy } 
   200      -56  
   201      -56 begin { The limit for loss in accuracy corresponds to 
   202      847      5 bits for the Maximum Relative Error and to 
   203      847      half this for the Root Mean Square error. Such limits are 
   204      847      only exceeded by poor read or write routines.  } 
   205      847    albeta := ln (ibeta); 
   206      853    loss := ln (32.0) / albeta; 
   207      858    rmserror := sqrt (rmserror / items); 
   208      864    writeln('  THE RESULT WAS TOO LARGE', big: 5, ' TIMES,'); 
   209      879    writeln('                 EQUAL', equal:9, ' TIMES, AND'); 
   210      894    writeln('                 TOO SMALL', small:5, ' TIMES.'); 
   211      909    writeln; 
   212      912    writeln('  THERE ARE', it: 4, ' BASE', ibeta: 4, 
   213      928       ' SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER'); 
   214      934    if maxerror <> 0.0 
   215      935    then 
   216      938       begin 
   217      938          support := false; 
   218      941          w := ln (abs (maxerror)) / albeta 
   219      944       end 
   220      947    else 
   221      948       w := - 999.0; 
   222      951    writeln('  THE MAXIMUM RELATIVE ERROR OF', maxerror, '=', 
   223      963       ibeta: 4, ' ** ', w: 7: 2); 
   224      976    writeln('   OCCURRED FOR X =', xmaxerror); 
   225      987    if w + it < 0.0 
   226      991    then 
   227      994       w := 0.0 
   228      994    else 
   229      997       w := w + it; 
   230     1002    writeln('   ESTIMATED LOSS OF BASE', ibeta: 4, 
   231     1011       ' SIGNIFICANT DIGITS IS', w: 7: 2); 
   232     1021    if w > loss then 
   233     1025       failed := true; 
   234     1028    if rmserror <> 0.0 
   235     1029    then 
   236     1032       w := ln (abs (rmserror)) / albeta 
   237     1035    else 
   238     1039       w := - 999.0; 
   239     1042    writeln('  ROOT-MEAN-SQUARE RELATIVE ERROR =', rmserror, 
   240     1051       '=', ibeta: 4, ' ** ', w: 7: 2); 
   241     1067    if w + it < 0.0 
   242     1071    then 
   243     1074       w := 0.0 
   244     1074    else 
   245     1077       w := w + it; 
   246     1082    writeln('   ESTIMATED LOSS OF BASE', ibeta: 4, 
   247     1091       ' SIGNIFICANT DIGITS IS', w: 7: 2); 
   248     1101    if w > 0.5 * loss then 
   249     1107       failed := true; 
   250     1110    writeln 
   251     1110 end { printresults }; 
   252     1114  
   253     1114 begin { readfile } 
   254     1114    machar (ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, 
   255     1125       maxexp, eps, epsneg, xmin, xmax); 
   256     1131    small := 0; 
   257     1133    equal := 0; 
   258     1135    big := 0; 
   259     1137    rmserror := 0.0; 
   260     1139    maxerror := 0.0; 
   261     1141    xmaxerror := 0.0; 
   262     1143    y := 0.5; 
   263     1145    for i := 1 to 29 do 
   264     1155       y := 0.5 * y; 
   265     1169    for number := 1 to items do 
   266     1179       begin 
   267     1179          read (tempfile, x); 
   268     1183          testequal (x, number * y) 
   269     1189       end; 
   270     1200    writeln(' TEST ACCURACY OF READ/WRITE FOR REALS'); 
   271     1208    printresults 
   272     1208 end { readfile }; 
   273     1211  
   274     1211 procedure copyfile; 
   275     1211 { copyfile using read and write for reals } 
   276     1211 var 
   277      -32    i: 1 .. items; 
   278      -36    x: array [ 1 .. items ] of real; 
   279     -436 begin 
   280     1211    reset(tempfile); 
   281     1215    for i := 1 to items do 
   282     1226       read(tempfile, x[i]); 
   283     1245    rewrite(tempfile); 
   284     1247    for i := 1 to items do 
   285     1258       writeln(tempfile, x[i]: 33 : 30) 
   286     1268 end { copyfile }; 
   287     1282  
   288     1282 begin { testcopy } 
   289     1282    support := true; 
   290     1287    failed := false; 
   291     1290    rewrite (tempfile); 
   292     1292    writefile; 
   293     1294    for i := 1 to copies do 
   294     1305       copyfile; 
   295     1318    reset (tempfile); 
   296     1320    readfile; 
   297     1322    writeln(' OUTPUT FROM TEST...6.9.1-8'); 
   298     1330    if support 
   299     1330    then 
   300     1332       writeln(' READ/WRITE OF REALS SUPPORTED IN SENSE OF W S BROWN') 
   301     1338    else 
   302     1341       writeln(' READ/WRITE OF REALS IS APPROXIMATE'); 
   303     1349    if failed 
   304     1349    then 
   305     1351       writeln(' FAIL...6.9.1-8') 
   306     1357    else 
   307     1360       writeln(' QUALITY...6.9.1-8') 
   308     1366 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 TEST ACCURACY OF READ/WRITE FOR REALS
  THE RESULT WAS TOO LARGE   10 TIMES,
                 EQUAL       14 TIMES, AND
                 TOO SMALL   26 TIMES.

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 3.947459643111667e-16=   2 **  -51.17
   OCCURRED FOR X = 1.676380634307861e-08
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   1.83
  ROOT-MEAN-SQUARE RELATIVE ERROR = 1.677968771112483e-16=   2 **  -52.40
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.60

 OUTPUT FROM TEST...6.9.1-8
 READ/WRITE OF REALS IS APPROXIMATE
 QUALITY...6.9.1-8

program complete

Compiling and running t6p9p2d2

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.9.2-2, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that a list of 30 variable-accesses can 
     4      -32    appear in a readln-parameter-list. } 
     5      -32 {V3.0: Program parameter removed. } 
     6      -32  
     7      -32 program t6p9p2d2(output); 
     8      -32 const 
     9      -32    str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123'; 
    10      -32 var 
    11      -32     c00, c01, c02, c03, c04, c05, c06, c07, c08, c09, 
    12      -32     c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, 
    13      -32     c20, c21, c22, c23, c24, c25, c26, c27, c28, c29, 
    14      -32     c30  : char; 
    15      -32    tempfile: text; 
    16      -32 begin 
    17        3    rewrite(tempfile); 
    18        7    write(tempfile, str); 
    19       13    writeln(tempfile, 'X'); 
    20       19    writeln(tempfile, '4'); 
    21       25    reset(tempfile); 
    22       27    readln(tempfile, 
    23       28        c00, c01, c02, c03, c04, c05, c06, c07, c08, c09, 
    24       68        c10, c11, c12, c13, c14, c15, c16, c17, c18, c19, 
    25      108        c20, c21, c22, c23, c24, c25, c26, c27, c28, c29); 
    26      150    read(tempfile, c30); 
    27      156    if (c00 <> 'A') or (c01 <> 'B') or (c02 <> 'C') or 
    28      167       (c03 <> 'D') or (c04 <> 'E') or (c05 <> 'F') or 
    29      179       (c06 <> 'G') or (c07 <> 'H') or (c08 <> 'I') or 
    30      191       (c09 <> 'J') or (c10 <> 'K') or (c11 <> 'L') or 
    31      203       (c12 <> 'M') or (c13 <> 'N') or (c14 <> 'O') or 
    32      215       (c15 <> 'P') or (c16 <> 'Q') or (c17 <> 'R') or 
    33      227       (c18 <> 'S') or (c19 <> 'T') or (c20 <> 'U') or 
    34      239       (c21 <> 'V') or (c22 <> 'W') or (c23 <> 'X') or 
    35      251       (c24 <> 'Y') or (c25 <> 'Z') or (c26 <> '0') or 
    36      263       (c27 <> '1') or (c28 <> '2') or (c29 <> '3') 
    37      274       or (c30 <> '4') then 
    38      280       writeln(' FAIL...6.9.2-2') 
    39      286    else 
    40      289       writeln(' QUALITY...6.9.2-2') 
    41      295 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.9.2-2

program complete

Compiling and running t6p9p3d2

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.9.3-2, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that data written appears on the output 
     4      -32    file regardless of the omission of a line marker. } 
     5      -32 {  The common error is to buffer output and fail to flush the 
     6      -32    buffers at end of job. } 
     7      -32 {V3.1: Program parameter removed. } 
     8      -32  
     9      -32 program t6p9p3d2(output); 
    10      -32 begin 
    11        3    write(' QUALITY...6.9.3-2') 
    12       11 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.9.3-2
program complete

Compiling and running t6p9p3d3

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.9.3-3, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that a list of 30 write-parameters can 
     4      -32    appear in a write-parameter-list. } 
     5      -32 {V3.1: program parameter removed. } 
     6      -32  
     7      -32 program t6p9p3d3(output); 
     8      -32 const 
     9      -32    str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ01234'; 
    10      -32 var 
    11      -32    fail: boolean; 
    12      -32    c: char; 
    13      -32    v: packed array [ 1 .. 31 ] of char; 
    14      -32    i: 1 .. 31; 
    15      -32    tempfile: text; 
    16      -32 begin 
    17        3    fail := false; 
    18        8    v := str; 
    19       11    rewrite(tempfile); 
    20       13    write(tempfile, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 
    21       41                    'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 
    22       68                    'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', 
    23       95                    '1', '2', '3'); 
    24      105    writeln(tempfile, '4'); 
    25      111    reset(tempfile); 
    26      113    for i := 1 to 31 do 
    27      124       begin 
    28      124       read(tempfile, c); 
    29      130       if c <> v[i] then 
    30      139          fail := true 
    31      139       end; 
    32      153    if fail then 
    33      155       writeln(' FAIL...6.9.3-3') 
    34      161    else 
    35      164       writeln(' QUALITY...6.9.3-3') 
    36      170 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.9.3-3

program complete

Compiling and running t6p9p3p5p2d2

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.9.3.5.2-2, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This test checks the accuracy of write for reals. } 
     4      -32 {  Real values which can be exactly represented in the machine 
     5      -32    should be read into the machine exactly, i.e. without rounding 
     6      -32    error. This presents difficulty on a binary machine since 
     7      -32    the negative powers of two are exactly represented but have 
     8      -32    long decimal representations. This test writes I * (2**(-30)) 
     9      -32    for I = 1 .. 100 to a temporary file in decimal 
    10      -32    and then reads them back, checking for 
    11      -32    the accuracy of the resulting value. 
    12      -32    A failure is indicated if the difference from the correct 
    13      -32    result is more than 3 bits in the last place. } 
    14      -32 {V3.1: Program parameter removed and number of items 
    15      -32    reduced from 1000 to 100 and test added to avoid 
    16      -32    excessive failure. Machar changed. } 
    17      -32  
    18      -32 program t6p9p3p5p2d2(output); 
    19      -32 const 
    20      -32    items = 100; 
    21      -32 var 
    22      -32    tempfile: text; 
    23      -32    support, failed: boolean; 
    24      -32  
    25      -32 procedure writefile; 
    26      -32 var 
    27      -32    y: real; 
    28      -40    i, number: integer; 
    29      -48 begin 
    30        3    y := 0.5; 
    31        7    for i := 1 to 29 do 
    32       17       y := 0.5 * y; 
    33       31    for number := 1 to items do 
    34       41       writeln(tempfile, number * y: 33: 30) 
    35       49 end { writefile }; 
    36       62  
    37       62 procedure readfile; 
    38       62 const 
    39      -32    length = 30; 
    40      -32    fract = '000000000931322574615478515625'; 
    41      -32    zero = '000000000000000000000000000000'; 
    42      -32 type 
    43      -32    reg = packed array [1..length] of char; 
    44      -32 var 
    45      -32    rfract, rreg, readreg: reg; 
    46     -122    i: integer; 
    47     -128    number: 1 .. items; 
    48     -132    small, equal, big: integer; 
    49     -144    rmserror, xmaxerror, maxerror: real; 
    50     -168    diff, y: real; 
    51     -184    ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, maxexp: 
    52     -184       integer; 
    53     -220    eps, epsneg, xmin, xmax: real; 
    54     -252  
    55     -252 procedure add; 
    56      -32 { Performs rreg := rreg + rfract } 
    57      -32 var 
    58      -32    carry: 0..1; 
    59      -36    d: 0..19; 
    60      -40    i: 1..length; 
    61      -44 begin 
    62       62    carry := 0; 
    63       67    for i := length downto 1 do 
    64       78       begin 
    65       78          d := ord(rreg [i]) + ord(rfract [i]) + carry - 2 * 
    66       96             ord ('0'); 
    67      102          if d >= 10 
    68      103          then 
    69      106             begin 
    70      106                carry := 1; 
    71      109                rreg [i] := chr (d - 10 + ord ('0')) 
    72      121             end 
    73      123          else 
    74      124             begin 
    75      124                carry := 0; 
    76      127                rreg [i] := chr (d + ord ('0')) 
    77      137             end 
    78      139       end 
    79      139 end { add }; 
    80      151  
    81      151 function forcestore(x: real): real; 
    82      151    { see 'st' in 6.6.6.2-11 for details} 
    83      151    var 
    84      -40       y: array[1..3] of real; 
    85      -64    begin 
    86      151    y[1] := x; y[2] := 0.0; y[3] := y[1] + y[2]; 
    87      186    y[1] := y[3]; forcestore := y[1] + y[2] 
    88      209    end; 
    89      213  
    90      213 procedure machar (var ibeta, it, irnd, ngrd, machep, negep, iexp, 
    91      213       minexp, maxexp: integer; var eps, epsneg, xmin, xmax: real); 
    92      213    { see 6.6.6.2-11 for details } 
    93      213    var 
    94      -84       i, iz, j, k, mx: integer; 
    95     -104       a, b, beta, betain, betam1, one, y, z, zero: real; 
    96     -176       underflo: boolean; 
    97     -177    function st(x: real): real; 
    98      -40       begin 
    99      213       st := forcestore(x); 
   100      219       end; 
   101      220  
   102      220    begin 
   103      220    one := 1.0; zero := 0.0; a := one + one; 
   104      230    while st(st(st(a + one) - a) - one) = zero do 
   105      246       a := a + a; 
   106      251    b := one + one; 
   107      255    while st(st(a + b) - a) = zero do 
   108      267       b := b + b; 
   109      272    ibeta := trunc (st(a + b) - a); beta := ibeta; 
   110      286    it := 0; b := one; 
   111      291    repeat 
   112      291       begin it := it + 1; b := b * beta end 
   113      301    until st(st(st(b + one) - b) - one) <> zero; 
   114      317    irnd := 0; 
   115      320    betam1 := beta - one; 
   116      324    if st(st((a + beta) + betam1) - (a + beta)) <> zero then 
   117      340       irnd := 1; 
   118      343    negep := it + 3; betain := one / beta; a := one; 
   119      355    for i := 1 to negep do 
   120      366       a := a * betain; 
   121      380    b := a; 
   122      382    while st(st(one - a) - one) = zero do 
   123      394       begin a := a * beta; negep := negep - 1 end; 
   124      405    negep := - negep; epsneg := a; 
   125      413    if (ibeta <> 2) and (irnd <> 0) then 
   126      423       begin 
   127      423       a := a * st(one + a) / (one + one); 
   128      435       if st(st(one - a) - one) <> zero then 
   129      447          epsneg := a; 
   130      450       end; 
   131      450    machep := - it - 3; a := b; 
   132      459    while st(st(one + a) - one) = zero do 
   133      471       begin a := a * beta; machep := machep + 1 end; 
   134      482    eps := a; 
   135      485    if (ibeta <> 2) and (irnd <> 0) then 
   136      495       begin 
   137      495       a := a * st(one + a) / (one + one); 
   138      507       if st(st(one + a) - one) <> zero then 
   139      519          eps := a; 
   140      522       end; 
   141      522    ngrd := 0; 
   142      525    if (irnd = 0) and (st(st(one + eps) * one - one) <> zero) then 
   143      545       ngrd := 1; 
   144      548    i := 0; k := 1; z := betain; underflo := false; 
   145      557    repeat 
   146      557       begin 
   147      557       y := z; z := y * y; a := z * one; 
   148      567       if (st(a + a) = zero) or (abs (z) >= y) then 
   149      580          underflo := true 
   150      580       else 
   151      584          begin i := i + 1; k := k + k end; 
   152      592       end 
   153      592    until underflo; 
   154      594    if ibeta <> 10 then 
   155      599       begin iexp := i + 1; mx := k + k end 
   156      608    else 
   157      609       begin iexp := 2; iz := ibeta; 
   158      615       while k >= iz do 
   159      619          begin iz := iz * ibeta; iexp := iexp + 1 end; 
   160      631       mx := iz + iz - 1; 
   161      637       end; 
   162      637    underflo := false; 
   163      640    repeat 
   164      640       begin 
   165      640       xmin := y; y := y * betain; a := y * one; 
   166      651       if (st(a + a) = zero) or (abs (y) >= xmin) 
   167      663             or (st(y * st(one + eps)) <= y) then 
   168      678          underflo := true 
   169      678       else 
   170      682          k := k + 1; 
   171      686       end 
   172      686    until underflo; 
   173      688    minexp := - k; 
   174      692    if (mx <= k + k - 3) and (ibeta <> 10) then 
   175      705       begin mx := mx + mx; iexp := iexp + 1 end; 
   176      715    maxexp := mx + minexp; i := maxexp + minexp; 
   177      727    if ibeta = 2 then 
   178      732       if (iexp = 8) and (it = 24) and (i = 4) then 
   179      746          maxexp := maxexp - 2 
   180      749       else if (iexp = 11) and (it = 53) and (i = 4) then 
   181      767          maxexp := maxexp - 2 
   182      770       else if i = 0 then 
   183      778          maxexp := maxexp - 1; 
   184      784    if i > 20 then 
   185      788       maxexp := maxexp - 1; 
   186      794    if a <> y then 
   187      798       maxexp := maxexp - 2; 
   188      804    xmax := one - epsneg; 
   189      810    if st(xmax * one) <> xmax then 
   190      820       xmax := one - st(beta * epsneg); 
   191      830    xmax := xmax / (beta * beta * beta * xmin); 
   192      843    i := maxexp + minexp + 3; 
   193      851    for j := 1 to i do 
   194      861       if ibeta = 2 then 
   195      866          xmax := xmax + xmax 
   196      869       else 
   197      874          xmax := xmax * beta; 
   198      890    end; 
   199      891  
   200      891  
   201      891  
   202      891  
   203      891  
   204      891 procedure analyse; 
   205      891 var 
   206      -32    relerror: real; 
   207      -40  
   208      -40 begin 
   209      891    if diff < 0.0 
   210      894    then 
   211      897       small := small + 1 
   212      898    else 
   213      902       if diff = 0.0 
   214      903       then 
   215      906          equal := equal + 1 
   216      907       else 
   217      911          big := big + 1; 
   218      915    relerror := abs (diff / (number * y)); 
   219      923    if relerror > maxerror then 
   220      927       begin 
   221      927          maxerror := relerror; 
   222      929          xmaxerror := number * y 
   223      930       end; 
   224      934    rmserror := rmserror + sqr (relerror) 
   225      937 end { analyse }; 
   226      940  
   227      940 procedure readline; 
   228      940 { Sets the variable readreg with the fractional digits 
   229      940      of value on line  } 
   230      940 var 
   231      -32    i: integer; 
   232      -36    ch: char; 
   233      -37 begin 
   234      940    repeat 
   235      942       begin 
   236      942          get (tempfile); 
   237      944          ch := tempfile ^ 
   238      947       end 
   239      950    until ch = '.'; 
   240      954    for i := 1 to 30 do 
   241      964       begin 
   242      964          get (tempfile); 
   243      966          ch := tempfile ^; 
   244      972          if (ch < '0') or (ch > '9') 
   245      978          then 
   246      980             begin 
   247      980             if not failed then 
   248      983                begin 
   249      983                writeln(' INPUT INCORRECT: NON-DIGIT (',ch,') READ'); 
   250      998                readreg[i] := '0'; 
   251     1006                failed := true 
   252     1006                end 
   253     1009             end 
   254     1009         else 
   255     1010             readreg [i] := ch 
   256     1015       end 
   257     1018 end { readline }; 
   258     1029  
   259     1029 procedure calculatedifference; 
   260     1029 { Sets variable diff with the difference of the 
   261     1029   variable read and calculated } 
   262     1029 var 
   263      -32    positive: boolean; 
   264      -33    negdiff: reg; 
   265      -63  
   266      -63 procedure subtract (var a, b: reg); 
   267      -40 { Sets negdiff := a - b } 
   268      -40 var 
   269      -40    carry: 0..1; 
   270      -44    d: - 10..9; 
   271      -48    i: 1..length; 
   272      -52 begin 
   273     1029    carry := 0; 
   274     1034    for i := length downto 1 do 
   275     1045       begin 
   276     1045          d := ord (a [i]) - ord (b [i]) - carry; 
   277     1064          if d < 0 
   278     1065          then 
   279     1068             begin 
   280     1068                carry := 1; 
   281     1071                negdiff [i] := chr (d + 10 + ord ('0')) 
   282     1083             end 
   283     1085          else 
   284     1086             begin 
   285     1086                carry := 0; 
   286     1089                negdiff [i] := chr (d + ord ('0')) 
   287     1099             end 
   288     1101       end 
   289     1101 end { subtract }; 
   290     1113  
   291     1113 procedure float; 
   292     1113 {Sets diff := float(negdiff), accuracy not critical} 
   293     1113 var 
   294      -32    i: 1..length; 
   295      -36    y: real; 
   296      -44 begin 
   297     1113    diff := 0.0; 
   298     1117    y := 0.1; 
   299     1119    for i := 1 to length do 
   300     1130       begin 
   301     1130          if negdiff [i] <> '0' then 
   302     1139             diff := diff + (ord(negdiff[i]) - ord('0')) * y; 
   303     1155          y := y / 10 
   304     1156       end 
   305     1160 end { float }; 
   306     1172  
   307     1172 begin {calculatedifference} 
   308     1172    if readreg = zero 
   309     1175    then 
   310     1178       diff := 0.0 
   311     1178    else 
   312     1181       begin 
   313     1181          if readreg < rreg 
   314     1182          then 
   315     1185             begin 
   316     1185                positive := true; 
   317     1188                subtract (rreg, readreg) 
   318     1191             end 
   319     1192          else 
   320     1193             begin 
   321     1193                positive := false; 
   322     1196                subtract (readreg, rreg) 
   323     1199             end; 
   324     1200          float; 
   325     1202          if not positive then 
   326     1205             diff := - diff 
   327     1205       end 
   328     1208 end { calculatedifference }; 
   329     1209  
   330     1209 procedure printresults; 
   331     1209 var 
   332      -32    loss, albeta, w: real; 
   333      -56    { Limit for loss in accuracy } 
   334      -56 begin { The limit for loss in accuracy corresponds to 
   335     1209      3 bits for the Maximum Relative Error and to 
   336     1209      half this for the Root Mean Square error. Such limits are 
   337     1209      only exceeded by poor read routines.  } 
   338     1209    albeta := ln (ibeta); 
   339     1215    loss := ln (8.0) / albeta; 
   340     1220    rmserror := sqrt (rmserror / items); 
   341     1226    writeln('  THE RESULT WAS TOO LARGE', big:5, ' TIMES,'); 
   342     1241    writeln('                 EQUAL', equal:9, ' TIMES, AND'); 
   343     1256    writeln('                 TOO SMALL', small: 5, ' TIMES.'); 
   344     1271    writeln; 
   345     1274    writeln('  THERE ARE', it: 4, ' BASE', ibeta: 4, 
   346     1290       ' SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER'); 
   347     1296    if maxerror <> 0.0 
   348     1297    then 
   349     1300       begin 
   350     1300          support := false; 
   351     1303          w := ln (abs (maxerror)) / albeta 
   352     1306       end 
   353     1309    else 
   354     1310       w := - 999.0; 
   355     1313    writeln('  THE MAXIMUM RELATIVE ERROR OF', maxerror, '=', 
   356     1325       ibeta: 4, ' ** ', w: 7: 2); 
   357     1338    writeln('   OCCURRED FOR X =', xmaxerror); 
   358     1349    if w + it < 0.0 
   359     1353    then 
   360     1356       w := 0.0 
   361     1356    else 
   362     1359       w := w + it; 
   363     1364    writeln('   ESTIMATED LOSS OF BASE', ibeta: 4, 
   364     1373       ' SIGNIFICANT DIGITS IS', w: 7: 2); 
   365     1383    if w > loss then 
   366     1387       failed := true; 
   367     1390    if rmserror <> 0.0 
   368     1391    then 
   369     1394       w := ln (abs (rmserror)) / albeta 
   370     1397    else 
   371     1401       w := - 999.0; 
   372     1404    writeln('  ROOT-MEAN-SQUARE RELATIVE ERROR =', rmserror, 
   373     1413       '=', ibeta: 4, ' ** ', w: 7: 2); 
   374     1429    if w + it < 0.0 
   375     1433    then 
   376     1436       w := 0.0 
   377     1436    else 
   378     1439       w := w + it; 
   379     1444    writeln('   ESTIMATED LOSS OF BASE', ibeta: 4, 
   380     1453       ' SIGNIFICANT DIGITS IS', w: 7: 2); 
   381     1463    if w > 0.5 * loss then 
   382     1469       failed := true; 
   383     1472    writeln 
   384     1472 end { printresults }; 
   385     1476  
   386     1476 begin { readfile } 
   387     1476    machar (ibeta, it, irnd, ngrd, machep, negep, iexp, minexp, 
   388     1487       maxexp, eps, epsneg, xmin, xmax); 
   389     1493    small := 0; 
   390     1495    equal := 0; 
   391     1497    big := 0; 
   392     1499    rmserror := 0.0; 
   393     1501    maxerror := 0.0; 
   394     1503    xmaxerror := 0.0; 
   395     1505    y := 0.5; 
   396     1507    for i := 1 to 29 do 
   397     1517       y := 0.5 * y; 
   398     1531    rreg := fract; 
   399     1534    rfract := fract; 
   400     1537    for number := 1 to items do 
   401     1548       begin 
   402     1548          readline; 
   403     1550          calculatedifference; 
   404     1552          analyse; 
   405     1554          add 
   406     1554       end; 
   407     1567    writeln(' TEST ACCURACY OF WRITE FOR REALS'); 
   408     1575    printresults 
   409     1575 end { readfile }; 
   410     1578  
   411     1578 begin { Main program } 
   412     1578    support := true; 
   413     1583    failed := false; 
   414     1586    rewrite (tempfile); 
   415     1588    writefile; 
   416     1590    reset (tempfile); 
   417     1592    readfile; 
   418     1594    writeln(' OUTPUT FROM TEST...6.9.3.5.2-2'); 
   419     1602    if support 
   420     1602    then 
   421     1604       writeln(' WRITE OF REALS SUPPORTED IN SENSE OF W S BROWN') 
   422     1610    else 
   423     1613       writeln(' WRITE OF REALS IS APPROXIMATE'); 
   424     1621    if failed 
   425     1621    then 
   426     1623       writeln(' FAIL...6.9.3.5.2-2') 
   427     1629    else 
   428     1632       writeln(' QUALITY...6.9.3.5.2-2') 
   429     1638 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 TEST ACCURACY OF WRITE FOR REALS
  THE RESULT WAS TOO LARGE    0 TIMES,
                 EQUAL      100 TIMES, AND
                 TOO SMALL    0 TIMES.

  THERE ARE  53 BASE   2 SIGNIFICANT DIGITS IN A FLOATING-POINT NUMBER
  THE MAXIMUM RELATIVE ERROR OF 0.000000000000000e+00=   2 ** -999.00
   OCCURRED FOR X = 0.000000000000000e+00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00
  ROOT-MEAN-SQUARE RELATIVE ERROR = 0.000000000000000e+00=   2 ** -999.00
   ESTIMATED LOSS OF BASE   2 SIGNIFICANT DIGITS IS   0.00

 OUTPUT FROM TEST...6.9.3.5.2-2
 WRITE OF REALS SUPPORTED IN SENSE OF W S BROWN
 QUALITY...6.9.3.5.2-2

program complete

Compiling and running t6p9p4d2

P5 Pascal compiler vs. 1.4.x
Pascal-P5 complies with the requirements of level 0 of ISO/IEC 7185.


     1      -32 {TEST 6.9.4-2, CLASS=QUALITY} 
     2      -32  
     3      -32 {: This program checks that a list of 30 write-parameters can 
     4      -32    appear in a writeln-parameter-list. } 
     5      -32 {V3.1: Program parameter removed. } 
     6      -32  
     7      -32 program t6p9p4d2(output); 
     8      -32 const 
     9      -32    str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123'; 
    10      -32 var 
    11      -32    fail: boolean; 
    12      -32    c: char; 
    13      -32    v: packed array [ 1 .. 30] of char; 
    14      -32    i: 1 .. 30; 
    15      -32    tempfile: text; 
    16      -32 begin 
    17        3    fail := false; 
    18        8    v := str; 
    19       11    rewrite(tempfile); 
    20       13    writeln(tempfile, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 
    21       41                    'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 
    22       68                    'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', 
    23       95                    '1', '2', '3'); 
    24      106    reset(tempfile); 
    25      108    for i := 1 to 30 do 
    26      119       begin 
    27      119       read(tempfile, c); 
    28      125       if c <> v[i] then 
    29      134          fail := true 
    30      134       end; 
    31      148    if not eoln(tempfile) then 
    32      152       fail := true; 
    33      155    if fail then 
    34      157       writeln(' FAIL...6.9.4-2') 
    35      163    else 
    36      166       writeln(' QUALITY...6.9.4-2') 
    37      172 end. 

Errors in program: 0
P5 Pascal interpreter vs. 1.4.x

Assembling/loading program
Running program

 QUALITY...6.9.4-2

program complete
